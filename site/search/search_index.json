{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"01-introduction/welcome/","title":"Background","text":"<p>In August, 2022, I attempted to solve Constrained Latin Squares, a recently published puzzle by @darkhorse64 on CodinGame. I noticed @5DN1L had, a week earlier, posted a link to Puzzles solvable by Algorithm X / Dancing Links, a post where he had compiled a list of puzzles on CodinGame he had solved with Algorithm X. I love processes that are repeatable and the idea of using a single algorithm to solve a long list of medium/hard puzzles intrigued me.</p> <p>For the next 18 months, I worked on @5DN1L\u2019s list, reaching out to him over and over again with questions and ideas. I saw tremendous opportunity for not only a reusable software architecture, but also a repeatable engineering process for solving Exact Cover problems. Eventually, he suggested I build an Algorithm X playground, and here we are!</p> <p>I can\u2019t thank @5DN1L enough for all of his guidance, support, ideas, encouragement, questions, answers, poking, prodding, reviewing, etc. This playground is his creation every bit as much as it is mine. His influence has made a permanent mark on who I am and how I approach problems. I am forever grateful.</p>"},{"location":"01-introduction/welcome/#what-is-algorithm-x","title":"What is Algorithm X?","text":"<p>Algorithm X is a promise. If you can build a proper model to a particular problem space, Algorithm X promises to find all solutions to that problem space. Papers have been written and projects have been done to demonstrate \u201chow\u201d Algorithm X works. That is not the goal here. Instead, the focus of this exercise is to build expertise in the realm of modeling. The goal is to build models that Algorithm X easily digests and returns solutions. Only a cursory understanding of Algorithm X is required, and the implementation details will barely be covered. Instead, you will be asked to build models of problems and you will have the opportunity to see how well you modeled each problem simply by seeing how easily Algorithm X converts your models into solutions.</p>"},{"location":"01-introduction/welcome/#whats-in-it-for-you","title":"What\u2019s in It for You?","text":"<p>A quick Google search will surely bring you to countless implementations of Algorithm X, usually solving a 9x9 Sudoku grid using the famous Dancing Links (DLX) technique proposed by the brilliant Donald Knuth. This playground is NOT just another Sudoku demonstration. By the time you finish working your way through this material, you should feel confident solving any Exact Cover problem you run across, including\u2026</p> <p>Exact Cover (Algorithm X Candidate) Puzzles Created for this Playground: Mrs. Knuth \u2013 Part I (+50 XP) Mrs. Knuth \u2013 Part II (+50 XP) Mrs. Knuth \u2013 Part III (+50 XP) Equation Search (+50 XP) Ye_ An_th_r W_rd Se_rch (+50 XP)</p> <p>Support Puzzles Covered in this Playground Shikaku Skill Builder (+50 XP) Networking (+50 XP)</p> <p>Great Candidates for Algorithm X: Sudoku Solver (+50 XP) 16x16 Sudoku (+50 XP) 25x25 Sudoku (+50 XP) Mini Sudoku Solver (+50 XP) Constrained Latin Squares (+50 XP) Literary Alfabet Soupe (+50 XP) Shikaku Solver (+50 XP) Dominoes Solver (+50 XP) Paving with Bricks (+50 XP) n Queens (+50 XP) Finish the Eight Queens (+50 XP) Optimized Coloring (+50 XP) Einstein\u2019s Riddle Solver (+50 XP) Winamax (+250 XP) \ud83d\ude80\ud83d\ude80\ud83d\ude80 Three Little Piggies (+50 XP) Breaking Bifid (+50 XP) Futoshiki Solver (+50 XP) Suguru Solver (+50 XP) Dumbbells Solver (+50 XP) Hitori Solver (+50 XP) \ud83c\udfae There Is No Spoon \u2013 Episode 2 (+250 XP) \ud83d\ude80\ud83d\ude80\ud83d\ude80 Takuzu Solver (+50 XP) High-Rise Buildings (+50 XP) Killer Sudoku Solver (+50 XP) Kakuro Solver (+50 XP) Killer Sudoku Extreme Challenge (+50 XP) Tetris Floor (+50 XP) Agent X, Mission 2\u2014Mysterious Cryptogram (+50 XP) Harmless Rooks (+50 XP) Periodic Table Spelling (+50 XP) Kids Blocks (+50 XP) Depot Organization (+50 XP) Fix the Spaces (+50 XP) Who Dunnit? (+50 XP) Picture Puzzle (+50 XP) Nonogram Inversor (+50 XP) \ud83c\udfae Polyominoes (+50 XP) \ud83c\udfae Tetrasticks (+50 XP) Haunted Manor (+50 XP) Completed Mahjong Hands (+50 XP) Crossword (+50 XP) \ud83c\udfae Pips (+50 XP) \ud83c\udfae Battleship Solitaire (+50 XP) \ud83c\udfae Magnets (+50 XP) \ud83c\udfae Connect the Colours - Part I (+50 XP) \ud83c\udfae Connect the Colours - Part II (+50 XP)</p> <p>\ud83c\udfae = Solo Game with special visual effects that nicely demonstrate the exact cover.</p>"},{"location":"01-introduction/welcome/#my-promise-to-you","title":"My Promise to You","text":"<p>I wholeheartedly believe that working through this playground and the accompanying puzzles will be a great experience on multiple levels. How can I say this? All these things happened for me as I studied Algorithm X and applied it to as many puzzles as possible. I promise\u2026</p> <ul> <li>You will become proficient with a powerful and repeatable problem-solving technique known as Algorithm X.</li> <li>You will experience the compelling nature of reusable software architectures.</li> <li>You will find every puzzle listed above significantly easier than it would have been otherwise. I\u2019m not saying they\u2019ll all be easy, but they will indeed be easier.</li> <li>You will have a lot of fun.</li> <li>You will earn up to 3050 CodinGame XP!</li> </ul>"},{"location":"01-introduction/welcome/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Intermediate level knowledge of Python, including object-oriented programming concepts such as classes and class method overriding. However, if you are new to Python, going through this playground will identify some intermediate level concepts that you might consider moving to the top of your to-study list.</p> </li> <li> <p>Cursory understanding of backtracking. To complete this playground, it is more important that you understand the general concept of backtracking than it is you be able to code a backtracking algorithm.</p> </li> </ul>"},{"location":"01-introduction/welcome/#language-translations","title":"Language Translations","text":"<p>The CodinGame community is wide and diverse. Although much of this playground has been written for the Python programmer, it did not take long for language translations of the provided <code>AlgorithmXSolver</code> to appear. Be sure to visit the translations section to see if a translation to your preferred language already exists.</p>"},{"location":"01-introduction/welcome/#future-updates","title":"Future Updates","text":"<p>If this is not your first time visiting this playground, be sure to click here to see if any major updates (e.g. new puzzle) have been made since your last visit.</p> <p></p>"},{"location":"02-exact-cover/01-exact-cover/","title":"Exact Cover Definition","text":"<p>This playground is titled Algorithm X and we will get to that, but we need to start by understanding what types of problems can be classified as \u201cExact Cover\u201d problems. Algorithm X is a backtracking algorithm proposed by Donald Knuth for solving exact cover problems. So, how do we identify candidate problems for Algorithm X?</p> <p>Let\u2019s start with the formal explanation on Wikipedia:</p> <p>Wikipedia - Exact Cover</p> <p>If you've got the math background to understand all that, I applaud you! (I'm also a bit jealous.) Unfortunately, I am, at best, an amateur mathematician, so please forgive me for skipping over a few of the intricate details.</p>"},{"location":"02-exact-cover/01-exact-cover/#a-less-formal-discussion","title":"A Less Formal Discussion","text":"<p>Now that we have covered the formal definition, I will restate it in my own words. An exact cover problem is a type of problem that can be modeled as a set of constraints and a set of options where solutions are made up of a subset of the options that exactly satisfies all the constraints. Rather than using the terms constraints and options, I\u2019m going to use the terms requirements and actions.</p> <p>An exact cover problem has a set of requirements that a proper solution must satisfy. Let\u2019s consider the most widely-used example, Sudoku. What are the requirements of Sudoku? There must be a 1 in the first row, there must be a 1 in the first column, there must be a 2 in the first row, there must be a 2 in the first column, there must be a 1 in the top-left 3x3 box, there must be a 2 in the top-left 3x3 box, etc. </p> <p>Actions are exactly what they sound like. They are the steps that can be taken to build a solution. What are the actions you can take to solve a Sudoku? You can place a 1 in row 1, col 1 or you can place a 2 in row 1, col 1, or you might place a 7 in row 3, col 4, etc.</p> <p>The last thing you need to build a complete model of an exact cover problem is a mapping of actions to requirements. For each action, you must identify which requirements are satisfied if that action is added to the solution. In Sudoku, if you put a 1 in col 1, row 1, three distinct requirements are satisfied: there must be a 1 in row 1, there must be a 1 in col 1 and there must be a 1 in the top-left 3x3 box.</p> <p>Believe it or not, a proper model of 9x9 Sudoku has 243 individual requirements and 729 possible actions. Those numbers can seem a bit overwhelming at this point and because of that, I\u2019d like to introduce you to Mrs. Knuth\u2026</p> <p></p>"},{"location":"02-exact-cover/02-mrs-knuth/","title":"A Long-Lost Relative?","text":"<p>It is highly unlikely that Mrs. Knuth is any relation to Donald Knuth, but one never knows. Mrs. Knuth is the school band teacher, and she needs help scheduling her students for lessons during the summer. We haven\u2019t even covered how Algorithm X works, but we are going to use it to help Mrs. Knuth with her scheduling problem and solve the first Mrs. Knuth puzzle:</p> <p>Mrs. Knuth \u2013 Part I</p>"},{"location":"02-exact-cover/02-mrs-knuth/#puzzle-overview","title":"Puzzle Overview","text":"<p>Of course, you will need to properly organize your input and format your output, but the algorithm for building the schedules is a perfect candidate for Algorithm X. For your convenience, I have copied the scheduling portion of the puzzle's goal section here:</p> <p>Mrs. Knuth, the school band teacher, has asked you to write an algorithm to generate her weekly private lesson schedule for the summer. Her availability is different from week to week, but she will always teach between 1 and 5 days per week. On each day that she teaches, she will teach between 2 and 8 hours. Because she likes consistency, she will teach the same number of hours on each day she teaches, but the actual time slots during which she is available might be different from day to day.</p> <p>Mrs. Knuth is a creature of habit. Her workday starts at 8am every day and ends at 5pm with an hour break for lunch each day from noon to 1pm. Although she is at school 9 total hours every day, she might not be available to teach on some days, she might have partial teaching availability on other days or she might have a day where she teaches every free minute other than during lunch.</p> <p>Mrs. Knuth is also a bit odd when it comes to music. To keep her mind fresh, she refuses to teach more than a single hour per day for any particular instrument. If she teaches 3 hours in one day, those lessons must be for 3 different instruments. If she teaches 8 hours in one day, all 8 instruments that day must be different.</p> <p>Given Mrs. Knuth\u2019s open availability and each student\u2019s instrument and lesson availability, generate a schedule for Mrs. Knuth that allows her to work with each student one time per week and meets her quirky demands.</p>"},{"location":"02-exact-cover/02-mrs-knuth/#example-test-case","title":"Example Test Case","text":"<p>To make this a bit more concrete, let\u2019s look at the example test case input:</p> <pre><code>M Tu W Th 2 3 4 F\n3\nAyla Trumpet M Tu W Th 2 F\nBob Drums M Tu W Th 2 3 F\nAlex Tuba M Tu W Th 2 4 F\n</code></pre> <p>In this example problem, Mrs. Knuth is only available at 2, 3 and 4 on Thursday. There are 3 students that need to be scheduled. Ayla (Trumpet) is available only at 2 on Thursday, Bob (Drums) is available at 2 and 3 on Thursday, and Alex (Tuba) is available at 2 and 4 on Thursday.</p> <p>This initial Part I puzzle also has some interesting puzzle constraints that should be considered as we build our understanding of the problem.</p> <ol> <li> <p><code>numStudents</code> = Mrs. Knuth's available hours per week.</p> </li> <li> <p>count of each type of <code>instrument</code> = count of days with hours in <code>teacherAvailability</code>, meaning the student roster will always contain the appropriate number of instruments to make sure no duplication of instruments on any one day is possible.</p> </li> </ol> <p>Why are these constraints important? Because of (1), we know that all of Mrs. Knuth\u2019s available slots must be filled. Because of (2) above, we know that each instrument must show up on each day Mrs. Knuth teaches. Our initial analysis identifies 3 areas for potential requirements:</p> <ol> <li> <p>Each student must be put on Mrs. Knuth\u2019s schedule.</p> </li> <li> <p>Each slot in Mrs. Knuth\u2019s availability must get filled.</p> </li> <li> <p>Each instrument must show up once on each day Mrs. Knuth teaches.</p> </li> </ol> <p>Our next step is to formally identify each requirement a potential solution must satisfy.</p> <p></p>"},{"location":"02-exact-cover/03-requirements/","title":"Capturing Requirements","text":"<p>My Algorithm X journey was heavily influenced by Ali Assaf\u2019s Algorithm X in 30 Lines!. Toward the bottom is a link to Assaf\u2019s Sudoku Solver. I found his technique for capturing requirements and actions very helpful in my debugging and I\u2019m going to suggest you also use that format.</p> <p>For each requirement, a human readable tuple of data clearly identifies the requirement. First, consider that each student must be put on Mrs. Knuth\u2019s schedule. Since there are three students in our initial example, we start with the following 3 requirements:</p> <pre><code>    ('student scheduled', 'Ayla')\n    ('student scheduled', 'Bob')\n    ('student scheduled', 'Alex')\n</code></pre> <p>If we take any one of those requirements, it is very easy to answer \u201cyes\u201d or \u201cno\u201d to the following question: Has this requirement been satisfied yet or not? Ayla has either been placed on the schedule or she has not. There is no in-between. This is a critical feature of requirements, they must be black or white. It must be obvious if the requirement has been satisfied or not.</p> <p>Next, we\u2019ll add requirements for Mrs. Knuth\u2019s availability. She only teaches at 2, 3 and 4 on Thursday. Each one of those slots must be filled:</p> <pre><code>    ('slot filled', 'Th', 2)\n    ('slot filled', 'Th', 3)\n    ('slot filled', 'Th', 4)\n</code></pre> <p>Two pieces of data uniquely identify each requirement: the day and the time of the slot. Because this initial test case is very minimal and Mrs. Knuth only teaches one day, we could omit the day from the requirement specification, but we would quickly run into problems as soon as Mrs. Knuth teaches on 2 or more days. </p> <p>Lastly, we need to add requirements to make sure each instrument is taught on each day. Again, we could omit these requirements for this simple example where Mrs. Knuth only teaches one day, but, just like before, we quickly run into problems as soon as Mrs. Knuth teaches more than one day per week.</p> <p>Looking at the input, we see the instruments being taught are Trumpet, Drums and Tuba. Each of those instruments must show up on each day Mrs. Knuth teaches. Since she only teaches one day, we only need three more requirements:</p> <pre><code>    ('instrument on day', 'Th', 'Trumpet')\n    ('instrument on day', 'Th', 'Drums')\n    ('instrument on day', 'Th', 'Tuba')\n</code></pre> <p>That\u2019s all we need! A complete list of requirements for this first test case looks like this:</p> <pre><code>    ('student scheduled', 'Ayla')\n    ('student scheduled', 'Bob')\n    ('student scheduled', 'Alex')\n    ('slot filled', 'Th', 2)\n    ('slot filled', 'Th', 3)\n    ('slot filled', 'Th', 4)\n    ('instrument on day', 'Th', 'Trumpet')\n    ('instrument on day', 'Th', 'Drums')\n    ('instrument on day', 'Th', 'Tuba')\n</code></pre> <p>Look through that list again and ask yourself this question: Does each requirement clearly identify something that must happen? Ayla must get scheduled. Bob must get scheduled. Alex must get scheduled. Thursday at 3 on Mrs. Knuth\u2019s schedule must get filled. A Tuba lesson must be scheduled on Thursday. I think you get the idea.</p> <p>Keep in mind, each one of these requirements must be satisfied exactly one time by any proposed solution. This is where the term \u201cexact\u201d comes from in exact cover. All requirements must be covered exactly once by a proper solution. None can be left uncovered and none can be covered multiple times by overlapping actions.</p>"},{"location":"02-exact-cover/03-requirements/#structuring-your-requirements","title":"Structuring Your Requirements","text":"<p>To use the Algorithm X solver provided in this playground, requirements need to be structured as tuples and each tuple must be unique. I strongly recommend you adopt the format used in this section where the first element of each tuple is a string that describes the category the requirement belongs to. These strings are technically unnecessary, but they have essentially zero cost to the provided solver and they will help you avoid situations where you think all your tuples are unique when you actually have problematic duplicates. You will also see benefits when it comes time for troubleshooting.</p>"},{"location":"02-exact-cover/03-requirements/#constraining-the-realm-of-possibility","title":"Constraining the Realm of Possibility","text":"<p>I have chosen to use the word \u201crequirement\u201d, but you will often see the word \u201cconstraint\u201d used with Algorithm X. Each word is powerful in its own way. I want to briefly demonstrate where the word \u201cconstraint\u201d really helps us understand the big picture of Algorithm X.</p> <p>Consider Mrs. Knuth\u2019s desire to avoid teaching more than one lesson per day for any instrument. An alternate approach to what was discussed above might be to build all possible schedules and then check each schedule to see if any day has a repeated instrument. Because Algorithm X is less constrained, it will generate many solutions that eventually get eliminated when the days are checked for duplicate instrument lessons.</p> <p>How many solutions get eliminated? Because all test cases in Mrs. Knuth - Part I are guaranteed to have a unique solution, we know all possible solutions except one will be eliminated. That doesn\u2019t really make the point I want to make unless we look at how many solutions need to be checked.</p> <p>The first two test cases only have Mrs. Knuth teaching on a single day, so there is no impact to those test cases. However, starting with Test Case 3, the unconstrained results grow rapidly. Remember, every one of these possible solutions might need to be checked to make sure no instrument is taught more than once on the same day!</p> Test Case Possible Solutions To Test for Duplicate Instruments (Theoretical Maximum) 3 - Two-Day Workweek 96 4 - Three Reasonable Days 1,818 5 - Three Long Days 11,414 6 - Four Moderate Days 130,235 7 - Five Long Days 241,460,379 <p>There is a moral to this story. It is best to restrict Algorithm X as much as possible with constraints (requirements). You will not always be able to eliminate the need to further validate potential solutions after Algorithm X finds them, but, by maximizing the knowledge passed to Algorithm X, you will probably be rewarded with a significantly smaller set of possible solutions, and in many cases, you will be rewarded with the only valid solution.</p> <p></p>"},{"location":"02-exact-cover/04-actions/","title":"Identifying Actions","text":"<p>The 9 requirements, identified previously, perfectly define the problem in Test Case #1. All we have to do now is find a set of actions that \u201cexactly covers\u201d these requirements, but first we have to identify actions that could be taken as we try to build a solution.</p> <p>A schedule is built for Mrs. Knuth by placing students into her available teaching slots. Every action we could take to build a solution comes down to placing one student into one slot. Of course, we need to make sure the student\u2019s availability and Mrs. Knuth\u2019s availability are properly honored, but I\u2019ll leave those details to you. Let\u2019s look at each student independently.</p> <p>Ayla is available on Thursday at 2, so only one action is possible: We can place Ayla on the schedule on Thursday at 2. Again, we will distinguish each action with a human readable tuple.</p> <pre><code>('place student', 'Ayla', 'Th', 2)\n</code></pre> <p>Notice that 3 pieces of data are required to distinguish one potential action from another. We need to know the name of the student being placed, the day and the hour.</p> <p>Bob is available on Thursday at 2 and 3. Alex is available on Thursday at 2 and 4. We need to add two possible actions for placing Bob on the schedule and 2 more possible actions for placing Alex on the schedule. If we add these 4 actions to the one action we already identified, our full list of possible actions looks like this:</p> <pre><code>('place student', 'Ayla', 'Th', 2)\n('place student', 'Bob', 'Th', 2)\n('place student', 'Bob', 'Th', 3)\n('place student', 'Alex', 'Th', 2)\n('place student', 'Alex', 'Th', 4)\n</code></pre>"},{"location":"02-exact-cover/04-actions/#linking-actions-to-requirements","title":"Linking Actions to Requirements","text":"<p>So far, we\u2019ve built a complete list of requirements that must be satisfied by any potential solution and we have a list of actions that can be used to build potential solutions. The last thing we need to define is a map between the actions and the requirements. For each action, we must identify the requirements satisfied by that action. </p> <p>Let's look at the first action in our list: <code>('place student', 'Ayla', 'Th', 2)</code>. If we add this action to a potential solution, which requirements from our requirements list will be satisfied? A simple example like this makes it easy to go through the requirements one by one to determine which requirements are satisfied and we end up with the following:</p> <pre><code>Action: ('place student', 'Ayla', 'Th', 2)\n    Satisfied Requirements: ('student scheduled', 'Ayla')\n                            ('slot filled', 'Th', 2)\n                            ('instrument on day', 'Th', 'Trumpet')\n</code></pre> <p>The first two should be obvious, but what about the 3rd requirement? Why is that requirement satisfied? We know from the input that Ayla plays the Trumpet. We could keep a separate list of instruments played by each student, but I recommend another approach. Because each student has exactly one instrument, my preference is to update our list of actions to include each student\u2019s instrument:</p> <pre><code>('place student', 'Ayla', 'Trumpet', 'Th', 2)\n('place student', 'Bob', 'Drums', 'Th', 2)\n('place student', 'Bob', 'Drums', 'Th', 3)\n('place student', 'Alex', 'Tuba', 'Th', 2)\n('place student', 'Alex', 'Tuba', 'Th', 4)\n</code></pre> <p>Instead of \u201cplacing Ayla on Thursday at 2\u201d, we are now \u201cplacing Ayla, with her Trumpet, on Thursday at 2. Later in this playground I will explain why these human readable tuples never impact our <code>AlgorithXSolver</code>\u2019s performance, which is why I always prefer having a little extra data in a tuple as compared to having to keep track of a separate list that identifies what instrument each student plays.</p>"},{"location":"02-exact-cover/04-actions/#a-complete-model","title":"A Complete Model","text":"<p>The Texas Gateway for Online Resources makes this simple statement about models on their website: </p> <p>Models can help you visualize, or picture in your mind, something that is difficult to see or understand. Models can help scientists communicate their ideas, understand processes, and make predictions.</p> <p>Models show up everywhere in life. Architects build models of buildings. Engineers build models of new products. Computer Scientists use the Unified Modeling Language (UML) to build models of software solutions before writing code.</p> <p>We have now created a model of the problem using requirements, actions and a mapping from actions to satisfied requirements. Putting it all in one place looks like this:</p> <pre><code>Requirements:\n    ('student scheduled', 'Ayla')\n    ('student scheduled', 'Bob')\n    ('student scheduled', 'Alex')\n    ('slot filled', 'Th', 2)\n    ('slot filled', 'Th', 3)\n    ('slot filled', 'Th', 4)\n    ('instrument on day', 'Th', 'Trumpet')\n    ('instrument on day', 'Th', 'Drums')\n    ('instrument on day', 'Th', 'Tuba')\n\nAction: ('place student', 'Ayla', 'Trumpet', 'Th', 2)\n    Satisfied Requirements: ('student scheduled', 'Ayla')\n                            ('slot filled', 'Th', 2)\n                            ('instrument on day', 'Th', 'Trumpet')\n\nAction: ('place student', 'Bob', 'Drums', 'Th', 2)\n    Satisfied Requirements: ('student scheduled', 'Bob')\n                            ('slot filled', 'Th', 2)\n                            ('instrument on day', 'Th', 'Drums')\n\nAction: ('place student', 'Bob', 'Drums', 'Th', 3)\n    Satisfied Requirements: ('student scheduled', 'Bob')\n                            ('slot filled', 'Th', 3)\n                            ('instrument on day', 'Th', 'Drums')\n\nAction: ('place student', 'Alex', 'Tuba', 'Th', 2)\n    Satisfied Requirements: ('student scheduled', 'Alex')\n                            ('slot filled', 'Th', 2)\n                            ('instrument on day', 'Th', 'Tuba')\n\nAction: ('place student', 'Alex', 'Tuba', 'Th', 4)\n    Satisfied Requirements: ('student scheduled', 'Alex')\n                            ('slot filled', 'Th', 4)\n                            ('instrument on day', 'Th', 'Tuba')\n</code></pre> <p>This text-based model might work well for you, but for those of you that prefer a more visual model, we must step into the matrix...</p> <p></p>"},{"location":"02-exact-cover/05-matrix/","title":"Visualizing the Model","text":"<p>An exact cover problem is often displayed as a matrix. The problem requirements are listed across the top as column headers. The possible actions are listed down the left side as row headers. <code>1</code>s are placed in the appropriate boxes to indicate which requirements are covered by each action. <code>0</code>s are often placed in the other cells, but I am going to leave those cells blank in order to draw your attention to the locations of the <code>1</code>s. Let\u2019s take a look.</p> <p></p> <p>The visual above should help you see where the term exact cover comes from. A proper solution is made up of a subset of rows that exactly covers all the columns. In our simple example, it is easy to see this can be accomplished by selecting rows 1, 3 and 5.</p> <p></p> <p>Let's eliminate the unused rows to really highlight the \"exact cover\".</p> <p></p> <p>Think about the size of the matrix for 9x9 Sudoku: 243 columns and 729 rows, yet Algorithm X easily processes a matrix of that size to find all solutions! Later in this playground, I\u2019ll demonstrate how Algorithm X works. For now, I need you to trust me. If you can build a proper model (requirements, actions and a mapping from actions to the satisfied requirements), Algorithm X will easily find all the solutions.</p> <p>In the next section, I\u2019ll show you how to use an out-of-the-box <code>AlgorithmXSolver</code> to generate solutions for your models.</p> <p></p>"},{"location":"03-AlgorithmXSolver/01-the-AlgorithmXSolver/","title":"Background","text":"<p>My original attempt at building a reusable solver involved taking Ali Assaf\u2019s Algorithm X in 30 Lines! and wrapping it inside of an <code>AlgorithmXSolver</code> class that I could initialize with a list of requirements and a dictionary of actions. Each action (key) in the dictionary had a list of requirements covered by that action. Although I had good success with that solver, I knew I eventually wanted to implement Donald Knuth's Dancing Links (DLX).</p> <p>I have learned a ton these past several years looking at other CodinGamers' solutions after I submit a puzzle solution. I noticed @RoboStac had implemented DLX for Constrained Latin Squares. I eventually took @RoboStac's code and swapped out the engine of my <code>AlgorithmXSolver</code>. The interfaces remained the same, but I now had better horsepower under the hood! </p> <p>Here's the best news of all. You are welcome to study DLX and implement it yourself, but you don't need to do that to solve all the puzzles on @5DN1L's list. I'm going to give you my <code>AlgorithmXSolver</code>. Would it be beneficial to study DLX and implement it yourself? Absolutely! However, this playground is not about coding up DLX. This playground is about building models that Algorithm X can easily digest and solve. In the big (theoretical) picture of life, DLX only needs to be implemented one time, while the number of problems that might need to be modeled and solved is endless.</p> <p>Reminder: All detailed examples in this playground are coded in Python. Make sure to check the translations section for other language options!</p>"},{"location":"03-AlgorithmXSolver/01-the-AlgorithmXSolver/#using-the-algorithmxsolver-class","title":"Using the <code>AlgorithmXSolver</code> Class","text":"<p>In this playground, I will simplify code examples by using the following import statement.</p> <pre><code>from AlgorithmX import AlgorithmXSolver\n</code></pre> <p>This import statement will not work in your coding environment unless you have the ability to import from files outside your main code file. In an IDE like CodinGame, you will need to copy all of the following code into your source file.</p> <pre><code>#  This solution uses Knuth's Algorithm X and his Dancing Links (DLX):\n#  (DLX-Based Algorithm X Solver Last Revised 01 December 2024)\n#\n#  For a detailed explanation and tutorial, please see the Algorithm X\n#  playground on Tech.io by following the link in @Timinator's CodinGame profile:\n#\n#  https://www.codingame.com/profile/2df7157da821f39bbf6b36efae1568142907334/playgrounds\n#\n\n#  DLXCell is one cell in the Algorithm X matrix. This implementation was mostly\n#  copied from @RoboStac's solution to Constrained Latin Squares on www.codingame.com.\n#\n#  https://www.codingame.com/training/medium/constrained-latin-squares\n#\nclass DLXCell:\n    def __init__(self, title=None):\n        self.prev_x = self\n        self.next_x = self\n        self.prev_y = self\n        self.next_y = self\n\n        self.col_header = None\n        self.row_header = None\n\n        # Only used for column and row headers.\n        self.title = title\n\n        # Size quickly identifies how many rows are in any particular column.\n        self.size = 0\n\n    def remove_x(self):\n        self.prev_x.next_x = self.next_x\n        self.next_x.prev_x = self.prev_x\n\n    def remove_y(self):\n        self.prev_y.next_y = self.next_y\n        self.next_y.prev_y = self.prev_y\n\n    def restore_x(self):\n        self.prev_x.next_x = self\n        self.next_x.prev_x = self\n\n    def restore_y(self):\n        self.prev_y.next_y = self\n        self.next_y.prev_y = self\n\n    def attach_horiz(self, other):\n        n = self.prev_x\n        other.prev_x = n\n        n.next_x = other\n        self.prev_x = other\n        other.next_x = self\n\n    def attach_vert(self, other):\n        n = self.prev_y\n        other.prev_y = n\n        n.next_y = other\n        self.prev_y = other\n        other.next_y = self\n\n    def remove_column(self):\n        self.remove_x()\n        node = self.next_y\n        while node != self:\n            node.remove_row()\n            node = node.next_y\n\n    def restore_column(self):\n        node = self.prev_y\n        while node != self:\n            node.restore_row()\n            node = node.prev_y\n        self.restore_x()\n\n    def remove_row(self):\n        node = self.next_x\n        while node != self:\n            node.col_header.size -= 1\n            node.remove_y()\n            node = node.next_x\n\n    def restore_row(self):\n        node = self.prev_x\n        while node != self:\n            node.col_header.size += 1\n            node.restore_y()\n            node = node.prev_x\n\n    def select(self):\n        node = self\n        while 1:\n            node.remove_y()\n            node.col_header.remove_column()\n            node = node.next_x\n            if node == self:\n                break\n\n    def unselect(self):\n        node = self.prev_x\n        while node != self:\n            node.col_header.restore_column()\n            node.restore_y()\n            node = node.prev_x\n        node.col_header.restore_column()\n        node.restore_y()\n\n\nclass AlgorithmXSolver():\n    # R - a list of requirements. The __init__() method converts R to a dictionary, but R must\n    #     originally be passed in as a simple list of requirements. Each requirement is a tuple\n    #     of values that uniquely identify that requirement from all other requirements.\n    #\n    # A - must be passed in as a dictionary - keys are actions, values are lists of covered requirements\n    #\n    # O - list of optional requirements. They can be covered, but they never cause failure.\n    #     Optional requirements are important because if they get covered, no other action can \n    #     also cover that same requirement. Also referred to as \"at-most-one-time constraints\".\n    #\n    def __init__(self, R: list, A: dict, O: list = []):\n        self.A = A\n        self.R = R + list(O)\n        self.O = set(O)\n\n        # The list of actions (rows) that produce the current path through the matrix.\n        self.solution = []\n        self.solution_count = 0\n\n        # A history can be added to a subclass to allow Algorithm X to handle \"multiplicity\".\n        # In the basic Solver, nothing is ever put into the history. A subclass can override\n        # the _process_row_selection() method to add history in cases of multiplicity. \n        self.history = [set()]\n\n        # For the basic Algorithm X Solver, all solutions are always valid. However, a subclass\n        # can add functionality to check solutions as they are being built to steer away from\n        # invalid solutions. The basic Algorithm X Solver never modifies this attribute.\n        self.solution_is_valid = True\n\n        # Create a column in the matrix for every requirement.\n        self.matrix_root = DLXCell()\n        self.matrix_root.size = 10000000\n        self.matrix_root.title = 'root'\n\n        self.col_headers = [DLXCell(requirement) for requirement in self.R]\n\n        # Row headers are never attached to the rest of the DLX matrix. They are only used \n        # currently to keep track of the action associated with each row.\n        self.row_headers = {action:DLXCell(action) for action in self.A}\n\n        self.R = {requirement:self.col_headers[i] for i, requirement in enumerate(self.R)}\n\n        for i in range(len(self.col_headers)):\n            self.matrix_root.attach_horiz(self.col_headers[i])\n\n        # Create a row in the matrix for every action.\n        for action in self.A:\n            previous_cell = None\n            for requirement in A[action]:\n                next_cell = DLXCell()\n                next_cell.col_header = self.R[requirement]\n                next_cell.row_header = self.row_headers[action]\n                next_cell.col_header.attach_vert(next_cell)\n                next_cell.col_header.size += 1\n\n                if previous_cell:\n                    previous_cell.attach_horiz(next_cell)\n                else:\n                    previous_cell = next_cell\n\n\n    def solve(self):\n\n        # Algorithm X Step 1:\n        #\n        # Choose the column (requirement) with the best value for \"sort criteria\". For\n        # the basic implementation of sort criteria, Algorithm X always chooses the column\n        # covered by the fewest number of actions. Optional requirements are not eligible \n        # for this step.\n        best_column = self.matrix_root\n        best_value  = 'root'\n\n        node = self.matrix_root.next_x\n        while node != self.matrix_root:\n\n            # Optional requirements (at-most-one-time constraints) are never chosen as best.\n            if node.title not in self.O:\n\n                # Get the sort criteria for this requirement (column).\n                value = self._requirement_sort_criteria(node)\n                if best_column == self.matrix_root or value &lt; best_value:\n                    best_column = node\n                    best_value  = value\n                node = node.next_x\n\n            else:\n\n                # Optional requirements stop the search for the best column.\n                node = self.matrix_root\n\n        if best_column == self.matrix_root:\n            self._process_solution()\n            if self.solution_is_valid:\n                self.solution_count += 1\n                yield self.solution\n        else:\n\n            # Build a list of all actions (rows) that cover the chosen requirement (column).\n            actions = []\n            node = best_column.next_y\n            while node != best_column:\n                actions.append(node)\n                node = node.next_y\n\n            # The next step is to loop through all possible actions. To prepare for this,\n            # a new level of history is created. The history for this new level starts out\n            # as a complete copy of the most recent history.\n            self.history.append(self.history[-1].copy())    \n\n            # Loop through the possible actions sorted by the given sort criteria. A basic\n            # Algorithm X implementation does not provide sort criteria. Actions are tried\n            # in the order they happen to occur in the matrix.\n            for node in sorted(actions, key=lambda n:self._action_sort_criteria(n.row_header)):\n                self.select(node=node)\n                if self.solution_is_valid:\n                    for s in self.solve():\n                        yield s\n                self.deselect(node=node)\n\n                # All backtracking results in going back to a solution that is valid.\n                self.solution_is_valid = True\n\n            self.history.pop()\n\n    # Algorithm X Step 4 - Details:\n    #\n    # The select method updates the matrix when a row is selected as part of a solution.\n    # Other rows that satisfy overlapping requirements need to be deleted and in the end,\n    # all columns satisfied by the selected row get removed from the matrix.\n    def select(self, node):\n\n        node.select()\n        self.solution.append(node.row_header.title)\n        self._process_row_selection(node.row_header.title)\n\n\n    # Algorithm X Step 4 - Clean Up:\n    #\n    # The select() method selects a row as part of the solution being explored. Eventually that\n    # exploration ends and it is time to move on to the next row (action). Before moving on,\n    # the matrix and the partial solution need to be restored to their prior states.\n    def deselect(self, node):\n\n        node.unselect()\n        self.solution.pop()\n        self._process_row_deselection(node.row_header.title)\n\n\n    # In cases of multiplicity, this method can be used to ask Algorithm X to remember that\n    # it has already tried certain things. For instance, if Emma wants two music lessons per\n    # week, trying to put her first lesson on Monday at 8am is no different than trying to put\n    # her second lesson on Monday at 8am. See the Algorithm X Playground for more details, \n    # specifically Mrs. Knuth - Part III.\n    def _remember(self, item_to_remember: tuple) -&gt; None:\n        if item_to_remember in self.history[-1]:\n            self.solution_is_valid = False\n        else:\n            self.history[-1].add((item_to_remember))\n\n\n    # In some cases it may be beneficial to have Algorithm X try certain paths through the matrix.\n    # This can be the case when there is reason to believe certain actions have a better chance than\n    # other actions at producing complete paths through the matrix. The method included here does\n    # nothing, but can be overridden to influence the order in which Algorithm X tries rows (actions) \n    # that cover some particular column.\n    def _action_sort_criteria(self, row_header: DLXCell):\n        return 0\n\n\n    # In some cases it may be beneficial to have Algorithm X try covering certain requirements\n    # before others as it looks for paths through the matrix. The default is to sort the requirements\n    # by how many actions cover each requirement, but in some cases there might be several \n    # requirements covered by the same number of actions. By overriding this method, the\n    # Algorithm X Solver can be directed to break ties a certain way or consider another way\n    # of prioritizing the requirements.\n    def _requirement_sort_criteria(self, col_header: DLXCell):\n        return col_header.size\n\n\n    # The following method can be overridden by a subclass to add logic to perform more detailed solution\n    # checking if invalid paths are possible through the matrix. Some problems have requirements that\n    # cannot be captured in the basic requirements list passed into the __init__() method. For instance,\n    # a solution might only be valid if it fits certain parameters that can only be checked at intermediate\n    # steps. In a case like that, this method can be overridden to add the functionality necessary to \n    # check the solution.\n    #\n    # If the subclass logic results in an invalid solution, the 'solution_is_valid' attribute should be set\n    # to False instructing Algorithm X to stop progressing down this path in the matrix.\n    def _process_row_selection(self, row):\n        pass\n\n\n    # This method can be overridden by a subclass to add logic to perform more detailed solution\n    # checking if invalid paths are possible through the matrix. This method goes hand-in-hand with the\n    # _process_row_selection() method above to \"undo\" what was done above.\n    def _process_row_deselection(self, row):\n        pass\n\n\n    # This method can be overridden to instruct Algorithm X to do something every time a solution is found.\n    # For instance, Algorithm X might be looking for the best solution or maybe each solution must be\n    # validated in some way. In either case, the solution_is_valid attribute can be set to False\n    # if the current solution should not be considered valid and should not be generated.\n    def _process_solution(self):\n        pass\n</code></pre> <p></p>"},{"location":"03-AlgorithmXSolver/02-your-solver/","title":"Create an <code>AlgorithmXSolver</code> Subclass","text":"<p>Creating a customized solver only has two required steps. First, create a solver class that inherits from <code>AlgorithmXSolver</code>. Second, override the constructor to build your requirements and actions. Let's create a solver to help Mrs. Knuth:</p> <pre><code>class MrsKnuthPartISolver(AlgorithmXSolver):\n\n    def __init__(self):\n\n        requirements = list()\n        actions = dict()\n\n        super().__init__(requirements, actions)\n</code></pre> <p>The last line might be a bit unfamiliar. When overriding a method, such as the constructor in this case, the goal is sometimes to simply add functionality to the existing functionality. There is actually a lot going on in the <code>AlgorithmXSolver</code> constructor and it all depends on having a list of requirements and a dictionary of actions that are needed to build the matrix. Once the requirements and actions are built, use <code>super()</code> to invoke the inherited <code>AlgorithmXSolver</code> constructor with the newly identified requirements and actions.</p>"},{"location":"03-AlgorithmXSolver/02-your-solver/#build-the-requirements","title":"Build the Requirements","text":"<p>Of course, <code>MrsKnuthPartISolver</code> needs to know about Mrs. Knuth's availability and all the students that need to be scheduled. For now, I will add parameters to the constructor, but I will leave the details of those parameters to you. For this toy example, I will ignore those parameters and I will  hard code the actions and requirements. Obviously, this will not be sufficient for anything other than the first test case in the puzzle.</p> <pre><code>class MrsKnuthPartISolver(AlgorithmXSolver):\n\n    def __init__(self, teacher_availability, students):\n\n        requirements = [('student scheduled', 'Ayla'),\n                        ('student scheduled', 'Bob'),\n                        ('student scheduled', 'Alex'),\n                        ('slot filled', 'Th', 2),\n                        ('slot filled', 'Th', 3),\n                        ('slot filled', 'Th', 4),\n                        ('instrument on day', 'Th', 'Trumpet'),\n                        ('instrument on day', 'Th', 'Drums'),\n                        ('instrument on day', 'Th', 'Tuba')]\n\n        actions = dict()\n\n        super().__init__(requirements, actions)\n</code></pre>"},{"location":"03-AlgorithmXSolver/02-your-solver/#build-the-actions","title":"Build the Actions","text":"<p>Notice that I copied those requirements right out of our previous discussion. The last thing we need to do is build the dictionary of actions and for each action, I need to add a list of requirements that are satisfied if that action is included in the solution. The complete, customized solver looks like this:</p> <pre><code>class MrsKnuthPartISolver(AlgorithmXSolver):\n\n    def __init__(self, teacher_availability, students):\n\n        requirements = [('student scheduled', 'Ayla'),\n                        ('student scheduled', 'Bob'),\n                        ('student scheduled', 'Alex'),\n                        ('slot filled', 'Th', 2),\n                        ('slot filled', 'Th', 3),\n                        ('slot filled', 'Th', 4),\n                        ('instrument on day', 'Th', 'Trumpet'),\n                        ('instrument on day', 'Th', 'Drums'),\n                        ('instrument on day', 'Th', 'Tuba')]\n\n        actions = dict()\n\n        action = ('place student', 'Ayla', 'Trumpet', 'Th', 2)\n\n        actions[action] = [('student scheduled', 'Ayla'),\n                           ('slot filled', 'Th', 2),\n                           ('instrument on day', 'Th', 'Trumpet')]\n\n        action = ('place student', 'Bob', 'Drums', 'Th', 2)\n\n        actions[action] = [('student scheduled', 'Bob'),\n                           ('slot filled', 'Th', 2),\n                           ('instrument on day', 'Th', 'Drums')]\n\n        action = ('place student', 'Bob', 'Drums', 'Th', 3)\n\n        actions[action] = [('student scheduled', 'Bob'),\n                           ('slot filled', 'Th', 3),\n                           ('instrument on day', 'Th', 'Drums')]\n\n        action = ('place student', 'Alex', 'Tuba', 'Th', 2)\n\n        actions[action] = [('student scheduled', 'Alex'),\n                           ('slot filled', 'Th', 2),\n                           ('instrument on day', 'Th', 'Tuba')]\n\n        action = ('place student', 'Alex', 'Tuba', 'Th', 4)\n\n        actions[action] = [('student scheduled', 'Alex'),\n                           ('slot filled', 'Th', 4),\n                           ('instrument on day', 'Th', 'Tuba')]\n\n        super().__init__(requirements, actions)\n</code></pre> <p>That's it! We have an (almost) fully functional <code>MrsKnuthPartISolver</code>. You will make it fully functional when you build the requirements and the actions from the parameters rather than hard coding them like I did. Next, we need to ask our new solver to find the solution for us!</p> <p></p>"},{"location":"03-AlgorithmXSolver/03-finding-solutions/","title":"Create a Solver Instance","text":"<p>So far, all we have is a <code>MrsKnuthPartISolver</code> class. We need to create an instance of that class. You\u2019ll need to get the input data and organize that data so you can pass it to the constructor.</p> <pre><code># Coding the following input is left to you.\n\n# teacher_availability = \n# students =\n\nsolver = MrsKnuthPartISolver(teacher_availability, students)\n</code></pre>"},{"location":"03-AlgorithmXSolver/03-finding-solutions/#solversolve","title":"<code>solver.solve()</code>","text":"<p>The last step is to ask our solver to give us the solutions. Some exact cover problems have multiple solutions and <code>AlgorithmXSolver</code> will always search for all solutions. Each solution found is returned one-by-one via a generator and each solution is a list of actions that make up that solution. Even if your problem is guaranteed to have a single solution, you should use the following format to get all solutions from your solver.</p> <pre><code>for solution in solver.solve():\n    for action in solution:\n        # use the action to build your problem's answer\n</code></pre> <p>I prefer to \"unpack\" the action tuple so that I have easy access to the information I need. For Mrs. Knuth Part I, each action is a tuple with 5 pieces of data - a title (not needed right now), name, instrument, day and hour.</p> <pre><code>schedule = some data structure to manage the answer to the puzzle\n\nfor solution in solver.solve():\n    for _, name, instrument, day, hour in solution:\n        # add name/instrument on day/hour to schedule\n\nprint(schedule)    # Don't forget how particular Mrs. Knuth is about her schedule formatting.\n</code></pre>"},{"location":"03-AlgorithmXSolver/03-finding-solutions/#solversolve-only-one-solution","title":"<code>solver.solve()</code> \u2013 Only One Solution","text":"<p>Some exact cover problems are guaranteed to have a single solution. When that is the case, you can add a <code>break</code> statement after processing the first solution to prevent Algorithm X from looking for more solutions that you know are not to be found. The <code>break</code> statement will decrease the amount of time required to finish the problem, and, in extreme cases, this may be exactly what your code needs to finish the problem within the given time limit.</p> <pre><code>for solution in solver.solve():\n    for action in solution:\n        # use the action to build your problem's answer\n\n    break\n</code></pre> <p>It can be helpful to leave the <code>break</code> statement out of your code until you are fairly confident in your solution. If your solver is incorrectly generating multiple solutions, the <code>break</code> statement will possibly hide your error from you. After you are confident that your code is working properly, add the <code>break</code> statement if you need to minimize processing time.</p>"},{"location":"03-AlgorithmXSolver/03-finding-solutions/#putting-it-all-together","title":"Putting it All Together","text":"<p>Let's put this all together now. As you look over this code example, keep in mind that the details of how Algorithm X works have been abstracted away. Solving Mrs. Knuth's Exact Cover problem comes down to these fairly reasonable steps:</p> <ul> <li> <p>Identify the Requirements</p> </li> <li> <p>Identify the Actions</p> </li> <li> <p>Identify the Requirements Satisfied by Each Action</p> </li> <li> <p>Process a List of Actions Algorithm X Identified as a Valid Solution</p> </li> </ul> <pre><code># Unless your coding environment will let you create an AlgorithmX package,\n# you will need to copy all of the AlgorithmXSolver code into your code.\n\nfrom AlgorithmX import AlgorithmXSolver\n\nclass MrsKnuthPartISolver(AlgorithmXSolver):\n\n    def __init__(self, teacher_availability, students):\n\n        requirements = [('student scheduled', 'Ayla'),\n                        ('student scheduled', 'Bob'),\n                        ('student scheduled', 'Alex'),\n                        ('slot filled', 'Th', 2),\n                        ('slot filled', 'Th', 3),\n                        ('slot filled', 'Th', 4),\n                        ('instrument on day', 'Th', 'Trumpet'),\n                        ('instrument on day', 'Th', 'Drums'),\n                        ('instrument on day', 'Th', 'Tuba')]\n\n        actions = dict()\n\n        action = ('place student', 'Ayla', 'Trumpet', 'Th', 2)\n\n        actions[action] = [('student scheduled', 'Ayla'),\n                           ('slot filled', 'Th', 2),\n                           ('instrument on day', 'Th', 'Trumpet')]\n\n        action = ('place student', 'Bob', 'Drums', 'Th', 2)\n\n        actions[action] = [('student scheduled', 'Bob'),\n                           ('slot filled', 'Th', 2),\n                           ('instrument on day', 'Th', 'Drums')]\n\n        action = ('place student', 'Bob', 'Drums', 'Th', 3)\n\n        actions[action] = [('student scheduled', 'Bob'),\n                           ('slot filled', 'Th', 3),\n                           ('instrument on day', 'Th', 'Drums')]\n\n        action = ('place student', 'Alex', 'Tuba', 'Th', 2)\n\n        actions[action] = [('student scheduled', 'Alex'),\n                           ('slot filled', 'Th', 2),\n                           ('instrument on day', 'Th', 'Tuba')]\n\n        action = ('place student', 'Alex', 'Tuba', 'Th', 4)\n\n        actions[action] = [('student scheduled', 'Alex'),\n                           ('slot filled', 'Th', 4),\n                           ('instrument on day', 'Th', 'Tuba')]\n\n        super().__init__(requirements, actions)\n\n\nteacher_availability = None\nstudents = None\n\nsolver = MrsKnuthPartISolver(teacher_availability, students)\n\nfor solution in solver.solve():\n    print(f'These are the steps to build a solution:')\n    for _, name, instrument, day, hour in solution:\n        print(f'   Add {name}/{instrument} to Mrs. Knuth\\'s schedule on {day} at {hour}.')\n</code></pre> <p>As is always the case with computer programming, bugs will work their way into your code. In the next section, I'll give you some debugging tips when using <code>AlgorithmXSolver</code>.</p> <p></p>"},{"location":"03-AlgorithmXSolver/04-troubleshooting/","title":"Print Your Requirements &amp; Actions","text":"<p>The first troubleshooting step to take is simply printing the requirements, the actions and the requirements satisfied by each action. Hopefully, this can be done on a small test case. If the test case is big and there are a lot of requirements and actions, sifting through the printed data can be daunting.</p> <p>When printing the requirements and actions, I suggest doing it right before you invoke the inherited <code>AlgorithmXSolver</code> constructor, similar to this:</p> <pre><code>        for r in requirements:\n            print(r)\n\n        for a in actions:\n            print(a)\n            for r in actions[a]:\n                print('   ', r)\n\n        super().__init__(requirements, actions)\n</code></pre>"},{"location":"03-AlgorithmXSolver/04-troubleshooting/#study-your-errors","title":"Study Your Errors","text":"<p>It is critical the tuples you use for requirements and actions always line up with each other so you do not get <code>KeyError</code>s when <code>AlgorithmXSolver</code> is setting up the DLX matrix. For instance, <code>('slot filled', 'Th', 4)</code> is not the same as <code>('slot filled', 'Thurs', 4)</code>. I\u2019m sure that seems obvious, but when you get a <code>KeyError</code>, look for places you might have requirement specs that are supposed to be the same, but are slightly different.</p> <pre><code>Traceback (most recent call last):\n  File \"/project/target/part_I_generate_solutions_test.py\", line 51, in &lt;module&gt;\n    main_program()\n  File \"/project/target/part_I_generate_solutions.py\", line 70, in main_program\n    solver = MrsKnuthPartISolver(teacher_availability, students)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/project/target/part_I_generate_solutions.py\", line 62, in __init__\n    super().__init__(requirements, actions)\n  File \"/project/target/AlgorithmX.py\", line 201, in __init__\n    current_col_header   = self.R[requirement]\n                           ~~~~~~^^^^^^^^^^^^^\nKeyError: ('slot filled', 'Thurs', 4)\n</code></pre>"},{"location":"03-AlgorithmXSolver/04-troubleshooting/#no-solutions-found","title":"No Solutions Found","text":"<p>Algorithm X not finding any solutions can be the most frustrating situation of all, and it always comes down to some issue with your model. Assuming your problem is guaranteed to have a solution, the only reason Algorithm X will fail to find a solution is that something in your model is not sufficient. The requirements cannot be perfectly covered by any possible combination of actions. Something is wrong in your mapping of satisfied requirements for each action.</p> <p>Although this can be frustrating, you will get better and better at building models with practice. The flip side of this frustration is that after you become proficient at building models you will experience elation when you surprise yourself by solving an exact cover problem much faster than you ever expected!</p>"},{"location":"03-AlgorithmXSolver/04-troubleshooting/#practice-makes-perfect","title":"Practice Makes Perfect","text":"<p>This exercise will help you understand how Algorithm X depends on precise mappings between requirements and actions \u2014 and how even small inconsistencies can cause runtime or logical errors.</p> <p>On the previous page, you saw a hard-coded solution to the Mrs. Knuth Part I example test case. Copy that code into your coding environment. Make sure the <code>AlgorithmX</code> solver code is available \u2014 either include it directly or place it in a separate file and import it.</p> <p>Now, explore and experiment with the code as follows:</p>"},{"location":"03-AlgorithmXSolver/04-troubleshooting/#1-inspect-the-data-structures","title":"1. Inspect the Data Structures","text":"<p>Print out all of the following:</p> <ul> <li>The requirements</li> <li>The actions</li> <li>The list of requirements satisfied by each action</li> </ul> <p>Verify that:</p> <ul> <li>Every requirement is covered by at least one action.</li> <li>The structure of your data matches what the solver expects.</li> </ul> <p>This step helps you confirm that your constraint data is correctly linked before running the solver.</p>"},{"location":"03-AlgorithmXSolver/04-troubleshooting/#2-introduce-a-keyerror","title":"2. Introduce a <code>KeyError</code>","text":"<p>Make a tiny edit that breaks the connection between requirements and actions. For example:</p> <ul> <li>Change <code>\"R3\"</code> to <code>\"R-3\"</code> in one place, or</li> <li>Remove a single requirement from the dictionary.</li> </ul> <p>Run the solver again and observe the <code>KeyError</code> message. Which part of the algorithm raised the error? Why did it fail there?</p>"},{"location":"03-AlgorithmXSolver/04-troubleshooting/#3-create-a-silent-failure","title":"3. Create a \u201cSilent Failure\u201d","text":"<p>Now make a different small change \u2014 one that doesn\u2019t cause a runtime error but still prevents Algorithm X from finding a solution. For instance:</p> <ul> <li>Remove one action that is essential for satisfying all requirements</li> </ul> <p>Run the solver. It should complete without crashing, but no solution will be found. Is it clear what happened?</p> <p></p>"},{"location":"04-your-turn/01-mrs-knuth-part-I/","title":"Time to Finish Mrs. Knuth - Part I","text":"<p>You have everything you need to finish Mrs. Knuth's first puzzle and get her through the summer. Again, this puzzle can be found here:</p> <p>Mrs. Knuth - Part I</p> <p>Here is a little pseudocode to help as you put together your full solution:</p> <pre><code>copy all the AlgorithmX code\n\ndefine MrsKnuthPartISolver as a subclass of AlgorithmXSolver \n    override the constructor to build your requirements and actions from \n    the passed in teacher_availability and students\n\nread all input\norganize input\n    teacher_availability\n    students\n\ncreate an instance of your new MrsKnuthPartISolver class, passing teacher_availability and students to the constructor\n\nfor each solution in solver.solve()\n    for each action in solution\n        add the student/instrument to schedule at hour/day\n\nprint the schedule\n</code></pre> <p>If you run into trouble, review the previous sections in this playground and you will find everything you need. Now that Mrs. Knuth is ready to go, let's look at a few other puzzles you are already fully prepared to solve!</p> <p></p>"},{"location":"04-your-turn/02-9x9-sudoku/","title":"Sudoku Solver","text":"<p>Puzzle: Sudoku Solver</p> <p>Author: @AllTheKingsMen</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: If Only They Were All This Straightforward</p>"},{"location":"04-your-turn/02-9x9-sudoku/#strategy","title":"Strategy","text":"<p>Sudoku is an excellent starting point because every basic Sudoku puzzle begins with a partial solution already in place \u2014 some of the grid\u2019s cells are prefilled. In other words, a number of actions have already been taken and must remain part of any complete solution.</p> <p>In the following sections, I will compare key portions of Ali Assaf\u2019s Sudoku implementation with my current version. This comparison will lead to a discussion of several strategies for handling partial solutions \u2014 that is, how to initialize Algorithm X when part of the solution is already known.</p>"},{"location":"04-your-turn/02-9x9-sudoku/#identify-requirements-a-la-ali-assaf","title":"Identify Requirements \u2013 \u00e0 la Ali Assaf","text":"<p>Note: In Assaf's code, <code>R</code> and <code>C</code> are the numbers of rows and columns in a Sudoku box or sub grid. A 9x9 Sudoku grid has 9 boxes and each box is 3x3. For a traditional 9x9 Sudoku, <code>N</code> = 9 in Assaf's code, but <code>R</code> and <code>C</code> are both 3.</p> <pre><code>    R, C = size\n    N = R * C\n    X = ([(\"rc\", rc) for rc in product(range(N), range(N))] +\n         [(\"rn\", rn) for rn in product(range(N), range(1, N + 1))] +\n         [(\"cn\", cn) for cn in product(range(N), range(1, N + 1))] +\n         [(\"bn\", bn) for bn in product(range(N), range(1, N + 1))])\n</code></pre>"},{"location":"04-your-turn/02-9x9-sudoku/#identify-requirements-a-la-timinator","title":"Identify Requirements \u2013 \u00e0 la Timinator","text":"<p>My tuples are flatter, and my strings are a bit longer. These tuples are stored in header nodes in my DLX implementation where they have no impact on performance. Assaf\u2019s code assumes integer values in the Sudoku cells. Because I know 16x16 Sudoku and 25x25 Sudoku both use letters of the alphabet, I have chosen to always use characters for this basic solver.</p> <pre><code>        requirements = [('cell covered', row, col) for row in range(size) for col in range(size)] + \\\n                       [('value in row', row, val) for row in range(size) for val in all_possible_values] + \\\n                       [('value in col', col, val) for col in range(size) for val in all_possible_values] + \\\n                       [('value in box', box, val) for box in range(size) for val in all_possible_values]\n</code></pre>"},{"location":"04-your-turn/02-9x9-sudoku/#identify-actions-a-la-ali-assaf","title":"Identify Actions \u2013 \u00e0 la Ali Assaf","text":"<p>Assaf builds a dictionary of actions (<code>Y</code>). Notice that all possible actions are included in the dictionary. Assaf does not limit the actions for cells that already contain a value.</p> <pre><code>    Y = dict()\n    for r, c, n in product(range(N), range(N), range(1, N + 1)):\n        b = (r // R) * R + (c // C) # Box number\n        Y[(r, c, n)] = [\n            (\"rc\", (r, c)),\n            (\"rn\", (r, n)),\n            (\"cn\", (c, n)),\n            (\"bn\", (b, n))]\n</code></pre>"},{"location":"04-your-turn/02-9x9-sudoku/#identify-actions-a-la-timinator","title":"Identify Actions \u2013 \u00e0 la Timinator","text":"<p>Here is a key difference between Assaf\u2019s code and mine. As I build the dictionary of actions, I limit the actions to only what is possible. A cell that is prefilled only has one candidate, while a blank cell has many candidates. I have also chosen to include an identifier string in my action tuples due to benefits realized while debugging.</p> <pre><code>        actions = dict()\n        for row in range(size):\n            for col in range(size):\n                box = (row // box_size) * box_size + (col // box_size) \n                for val in grid[(row, col)].candidates:\n                    action = ('place value', row, col, val)\n                    actions[action] = [('cell covered', row, col),\n                                       ('value in row', row, val),\n                                       ('value in col', col, val),\n                                       ('value in box', box, val)]\n</code></pre>"},{"location":"04-your-turn/02-9x9-sudoku/#preselect-known-actions-a-la-ali-assaf","title":"Preselect Known Actions \u2013 \u00e0 la Ali Assaf","text":"<p>After the matrix is built and ready to go, Assaf uses the following code to add actions to the solution before asking Algorithm X to use backtracking to find the remaining actions that solve the entire Sudoku. For each cell in the Sudoku grid that is prefilled with a number (<code>n</code>), Assaf makes a call to <code>select</code> to add the appropriate action to the solution and make the necessary adjustments to the matrix.</p> <pre><code>    for i, row in enumerate(grid):\n        for j, n in enumerate(row):\n            if n:\n                select(X, Y, (i, j, n))\n</code></pre>"},{"location":"04-your-turn/02-9x9-sudoku/#preselect-known-actions-a-la-timinator","title":"Preselect Known Actions \u2013 \u00e0 la Timinator","text":"<p>Because I have limited the actions to only what is possible, no preselection is done. Algorithm X has no choice but to select the appropriate actions to include the prefilled numbers as part of the solution.</p> <p>I believe Assaf's code has been vital to me and other Python programmers studying Algorithm X. My <code>AlgorithmXSolver</code> has been heavily influenced by Assaf, but I have intentionally left out the ability to preselect actions as Assaf has done above. Although Assaf's technique is elegant, I have chosen to limit actions as a standard process across all solutions. I want to point this out for anyone that might be familiar with Assaf's solver and wonder why it is not possible to preselect actions with the <code>AlgorithmXSolver</code> provided in this playground.</p>"},{"location":"04-your-turn/02-9x9-sudoku/#preselection-can-be-problematic","title":"Preselection Can Be Problematic","text":"<p>The DLX matrix is not meant to handle the selection of improper actions. Every time an action is selected to be part of a solution, DLX removes any impossible actions from the realm of possibility. When Algorithm X is in charge, it is impossible to select an action that cannot possibly be part of the final solution.</p> <p>Consider the following example. Do solutions exist for the Sudoku board below?</p> <pre><code>0 0 6 0 0 0 6 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 0\n</code></pre> <p>You and I can easily see there are two 6s in the first row, making it impossible to find a proper solution. This is a toy example, but play along with me.  Assume you want to use Algorithm X to determine if the Sudoku can be solved or not. You first create the requirements and the actions. Then you try to preselect the action that puts a 6 in row 1, col 3 and the action that puts a 6 in row 1, col 7. As soon as you preselect the first action, the DLX matrix is adjusted and there is no longer an option to put the second 6 in row 1, col 7. You tried to preselect an action that is no longer possible. You will either get an error, or your solver might produce many solutions since it is starting with a blank Sudoku with a single 6 preselected in row 1, col 3. </p> <p>The solution is to leave Algorithm X in charge. Next, I will discuss options that handle preselected cells, but since Algorithm X is in charge, error situations are more easily avoided.</p> <p></p>"},{"location":"04-your-turn/03-sudoku-cont/","title":"Alternative Approaches","text":"<p>The following 3 options always leave Algorithm X in charge. Instead of preselecting any cells of the Sudoku, Algorithm X will be instructed to try to put certain values in certain cells. Algorithm X is great at \u201ctrying\u201d things. After all, that is the general idea of any backtracking technique.</p>"},{"location":"04-your-turn/03-sudoku-cont/#option-1-restrict-possible-actions","title":"Option 1: Restrict Possible Actions","text":"<p>Rather than preselecting certain cells, restrict Algorithm X to a single option for those cells. Algorithm X will immediately select these options because there are no other paths forward. For instance, to restrict the possible actions in a 9x9 Sudoku, loop through all the cells of the grid. If the cell is empty, add 9 possible actions. If the cell already has a value, only add a single action. The pseudocode looks like this:</p> <pre><code>    for each cell in the grid\n        if the cell is empty\n            possible values = all possible values\n        else\n            possible values = cell value\n\n        for each value in possible values\n            add an action for placing this value in this cell\n</code></pre> <p>Algorithm X will immediately select the actions associated with pre-filled cells because they are the only actions that cover the requirements that values be placed in those cells. Notice that the process of restricting the option does not need to be exhaustive. At this time, the goal is to simply force Algorithm X to choose preselected options. The goal is not to perfectly minimize the full list of options available to Algorithm X.</p>"},{"location":"04-your-turn/03-sudoku-cont/#option-2-use-hints","title":"Option 2: Use Hints","text":"<p>If you search the internet for DLX Sudoku solutions, you will find solutions that use hints to guide Algorithm X. Rather than restricting the options available to Algorithm X, hints are used to force Algorithm X to make certain selections. Each hint is a must-be-covered requirement, and each hint is covered by a single action, giving Algorithm X no choice but to select the actions associated with the hints. The pseudocode looks like this:</p> <pre><code>    for each cell in the grid\n        if the cell is prefilled\n            add a new requirement -&gt; (\u2018hint\u2019, row, col)\n        for v in all possible values\n            add an action for placing v in the cell\n            if the cell is prefilled and v = the cell's prefilled value\n                add the new \"hint\" to the list of satisfied requirements\n</code></pre> <p>I have not used hints as part of any exact cover solution, but you will run into this technique if you study other Algorithm X solutions found online.</p>"},{"location":"04-your-turn/03-sudoku-cont/#option-3-give-algorithm-x-a-partial-problem","title":"Option 3: Give Algorithm X a Partial Problem","text":"<p>In some puzzles, a portion of the solution can be determined before Algorithm X begins backtracking and what remains for Algorithm X feels like a puzzle that can stand alone. In these cases, I have chosen to maintain a list of actions that must be part of the final solution, while then giving Algorithm X a smaller version of the problem to solve. The smaller problem feels identical to the larger problem in all ways except size. Later in the playground, I will identify a couple of puzzles where this third technique fits much better than the first two alternatives.</p> <p></p>"},{"location":"04-your-turn/04-sudoku-challenge/","title":"A Sudoku Challenge","text":"<p>Between Assaf\u2019s code, my <code>AlgorithmXSolver</code> and my suggestions, you should be able to complete the Sudoku Solver puzzle. However, there are  3 more puzzles on CodinGame that are all Sudokus of different sizes:</p> <p>16x16 Sudoku</p> <p>25x25 Sudoku</p> <p>Mini Sudoku Solver</p> <p>My challenge to you is to create a solver that works for all 4 Sudoku puzzles on CodinGame. The only difference between one Sudoku and another is the size of the grid and the values that can be put in each cell. Let me get you started:</p> <pre><code>class SudokuSolver(AlgorithmXSolver):\n\n    def __init__(self, grid: list[list[str]], values: str):\n</code></pre> <p>All Sudokus on CodinGame have equal width and height, so that is easy enough to determine by the width or height of the grid. It might not be possible to determine all possible values that may be used to fill the grid, so those values need to be explicitly passed in via the <code>values</code> parameter.</p> <p>Good luck!</p> <p></p>"},{"location":"04-your-turn/05-16x16-sudoku/","title":"16x16 Sudoku","text":"<p>Puzzle: 16x16 Sudoku</p> <p>Author: @yoch</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Straightforward</p>"},{"location":"04-your-turn/05-16x16-sudoku/#strategy","title":"Strategy","text":"<p>Everything you need to know about this puzzle has already been covered in the section on 9x9 Sudoku. However, I do want to add a few comments.</p> <p>I provided a fair amount of input to @yoch when this puzzle was reviewed and approved. Although this puzzle is straightforward if solved with Algorithm X, it is also a nice challenge without Algorithm X. Non-Algorithm-X solutions that work for 9x9 grids might not work on these 16x16 grids. A more significant algorithm is required to solve the larger puzzles, making for a very worthwhile learning experience.</p> <p></p>"},{"location":"04-your-turn/06-25x25-sudoku/","title":"25x25 Sudoku","text":"<p>Puzzle: 25x25 Sudoku</p> <p>Author: @yoch</p> <p>Published Difficulty: Very Hard</p> <p>Algorithm X Complexity: Should Be Straightforward, but Can Be Challenging (see below)</p>"},{"location":"04-your-turn/06-25x25-sudoku/#strategy","title":"Strategy","text":"<p>You can successfully finish 25x25 Sudoku just with what you have learned so far, but you might run into timing issues. These large Sudoku grids translate into large Algorithm X matrices that take time to process. Depending on your choice of data structures, you might find that running your code multiple times produces very different run times and there is a reason for that. To understand why that might happen, it is important to identify how many rows make up the matrix for each test case.</p> <p>Using the basic strategy laid out for 9x9 Sudoku, each known cell only adds one row to the matrix, while each unknown cell adds 25 rows to the matrix. Looking at each test case results in the following:</p> Unknown Cells (U) Known Cells (K) Rows in the Matrix (25 * U + K) Test Case 1: Test 1 276 349 7249 Test Case 2: Test 2 331 294 8569 Test Case 3: Test 3 324 301 8401 Test Case 4: Test 4 321 304 8329 Test Case 5: Test 5 326 299 8449"},{"location":"04-your-turn/06-25x25-sudoku/#the-nature-of-searching","title":"The Nature of Searching","text":"<p>Seven to eight thousand rows is manageable for Algorithm X, but how those rows are ordered makes a difference. If Algorithm X is trying to cover the cell at <code>(0, 0)</code> and there are 10 options to try, the order in which those 10 options are tried impacts run time. While Algorithm X will always try to optimize the order in which it tries rows and columns, there are times when a handful of options appear to be equally viable. In that case, if the correct option is toward the beginning of the list vs the end of the list makes a difference.</p> <p>If you would like to see this in action, try the following. For unknown cells, shuffle the list of candidates before you build the actions dictionary. You could use a <code>set</code> since members of a <code>set</code> are unordered or you could use <code>random.shuffle()</code>. Either way, you will experience run times that vary quite a bit.</p>"},{"location":"04-your-turn/06-25x25-sudoku/#where-to-go-from-here","title":"Where to Go From Here","text":"<p>If patience is not your strong suit, you might be able to pass all test cases and validators just by making sure your matrix is shuffled up a bit each time you run your code. Later in the playground, I will revisit 25x25 Sudoku when I discuss using logic to reduce the problem space. By logically filling in a few more cells of the grid and reducing the candidates for unknown cells, you can shrink the size of the matrix and create a solution that works 100% of the time completely independent of how your matrix gets constructed.</p> <p></p>"},{"location":"04-your-turn/07-mini-sudoku-solver/","title":"Mini Sudoku Solver","text":"<p>Puzzle: Mini Sudoku Solver</p> <p>Author: @nicola</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Straightforward</p>"},{"location":"04-your-turn/07-mini-sudoku-solver/#strategy","title":"Strategy","text":"<p>Everything you need to know about this puzzle has already been covered in the section on 9x9 Sudoku.</p>"},{"location":"04-your-turn/08-constrained-latin-squares/","title":"Constrained Latin Squares","text":"<p>Puzzle: Constrained Latin Squares</p> <p>Author: @darkhorse64</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Straightforward</p>"},{"location":"04-your-turn/08-constrained-latin-squares/#strategy","title":"Strategy","text":"<p>Did you create a single SudokuSolver class that was able to solve the 4 Sudoku puzzles? If you did, you might consider starting with that structure and applying it to this puzzle since Sudoku is a special kind of Latin Square. Keep in mind a Latin Square is less restrictive than a Sudoku, so it feels like a thing or two might need to be removed from your Sudoku solver.</p> <p>You will also need to handle grids of different sizes in the same puzzle. In all 4 Sudoku puzzles, all test case grids within a puzzle were the same size.</p>"},{"location":"04-your-turn/08-constrained-latin-squares/#counting-multiple-solutions","title":"Counting Multiple Solutions","text":"<p>This is the first puzzle in this playground where no single solution has any meaningful importance. Rather, it is only necessary to count the solutions. You always have the option to keep it simple:</p> <pre><code>count = 0\nfor solution in solver.solve():\n    count += 1\n\nprint(count)\n</code></pre> <p><code>AlgorithmXSolver</code> automatically counts the number of solutions it returns. You still need to loop through all the solutions due to the nature of the generator used to return solutions one-by-one, but you can then access the <code>solution_count</code> attribute.</p> <pre><code>for solution in solver.solve():\n    pass\n\nprint(solver.solution_count)\n</code></pre> <p></p>"},{"location":"04-your-turn/09-literary-alfabet-soupe/","title":"Literary Alfabet Soupe","text":"<p>Puzzle: Literary Alfabet Soupe</p> <p>Author: @David Augusto Villa</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Straightforward</p>"},{"location":"04-your-turn/09-literary-alfabet-soupe/#strategy","title":"Strategy","text":"<p>This puzzle provides an opportunity to practice Algorithm X with a very basic and straightforward setup. There is just one little problem. Understanding, analyzing and organizing the problem space is challenging enough on its own to make this puzzle deserving of its \u201cmedium\u201d rating. What do I mean by that?</p> <p>You are given 13 excerpts and 13 languages. You need to identify the language used in each excerpt. Before you can even consider Algorithm X, you need to use the information (inclusions and exclusions) provided about each language to determine which languages could match each excerpt. This is a very nice algorithmic challenge with many ways in which it can be approached, and that is all I have to say about that.</p> <p>Let\u2019s assume you are at a point where you have some number of \u201ccandidate\u201d languages for each excerpt. Some excerpts might have just one candidate language while others might have 2, 3, 4 or more candidate languages. Because every language must be assigned to exactly one excerpt, Algorithm X can easily take it from here.</p> <p>What are the requirements? Every excerpt must be assigned a language. What are the actions? Each candidate language translates to one action that matches that language to that excerpt. That is all there is to it, textbook Algorithm X.</p> <p>Identifying the candidate languages for the excerpts is quite a bit more challenging than finding an exact cover that uniquely matches the 13 languages to the 13 excerpts. Later in this playground, I will revisit this puzzle with a bit more information on options once you have identified candidate languages for each excerpt. If you want to jump ahead, click here.</p> <p></p>"},{"location":"05-generating-actions/01-finding-all/","title":"Tiles on a Gameboard","text":"<p>Every exact cover problem I have looked at could be visualized as placing tiles or game pieces on a grid or board to build a solution. Mrs. Knuth has a blank weekly calendar with the unavailable slots greyed out. A bunch of tiles need to be placed on the calendar. Each tile has a different student name and instrument on it. The task is to place those tiles on the calendar such that all constraints are obeyed and all requirements are satisfied. Every tile represents one possible action that could be taken as part of building a solution.</p> <p>9x9 Sudoku is fairly easy to visualize since most of us have seen a 9x9 Sudoku grid. What are the tiles? We think of completing a Sudoku grid with a pen or pencil, but can it fit into the tile analogy? Sure it can! Consider that you have 81 tiny tiles and 9 of those tiles have a <code>1</code> on them, 9 have a <code>2</code> on them, etc. Sudoku grids normally start with some numbers already in the grid. Don\u2019t think of these tiles already being in place. Instead, consider that the Sudoku grid has some numbers already \u201cpenciled in\u201d. What are you going to do first? You are going to take the appropriate tiles and immediately place them on top of the \u201cpenciled in\u201d numbers. </p>"},{"location":"05-generating-actions/01-finding-all/#critical-skill-generating-all-actions","title":"Critical Skill: Generating All Actions","text":"<p>I call the process of \u201cplacing a tile/game piece on the grid/board\u201d an action. These actions are the steps that can be taken to build a solution. It is critical that an exhaustive list of all possible actions be created and given to Algorithm X so that Algorithm X can find all valid solutions.</p> <p>Visualizing the grid/board and the tiles/pieces is often a powerful first step when trying to tackle an exact cover problem and build a complete model for Algorithm X. For many of the puzzles covered later, I will go over how I visualize the problem. This is not a completely objective process, so you might come up with ways that work better for you. Even if we visualize a problem differently, we both still need to come up with an exhaustive list of possible actions to feed into Algorithm X.</p> <p>How about a little practice?</p> <p></p>"},{"location":"05-generating-actions/02-shikaku-skill-builder/","title":"Shikaku Skill Builder","text":"<p>Puzzle: Shikaku Skill Builder</p> <p>Author: @Timinator</p> <p>Published Difficulty: Easy</p>"},{"location":"05-generating-actions/02-shikaku-skill-builder/#visualizing-the-problem","title":"Visualizing the Problem","text":"<p>Shikaku is a great place to start because the directions have a decent chance of putting you on a path that might lead to a dead end. According to the Shikaku Solver puzzle specification:</p> <p>The objective is to divide the grid into rectangular pieces such that each piece contains exactly one number, and that number represents the area of the rectangle.</p> <p>That is all true, but \u201cdividing\u201d is not something we have discussed in terms of visualizing an exact cover problem. Let\u2019s look at Shikaku a different way. Consider that you start with an outline of the grid with some numbers penciled in. You also have a large pile of rectangular tiles, each one having a certain width and height. Your job is to place tiles on the grid one-by-one, covering the penciled-in numbers with appropriately-sized tiles (tile area equal to number on grid), until the entire grid is covered with tiles.</p> <p>Algorithm X doesn\u2019t know how to \u201cdivide\u201d things up. Algorithm X is extremely good at finding a subset of a \u201clarge pile\u201d of options and it is critical that we give Algorithm X a complete set of \u201ctiles\u201d from which it can pick and choose to build valid solutions.</p>"},{"location":"05-generating-actions/02-shikaku-skill-builder/#skill-building","title":"Skill Building","text":"<p>In the Shikaku Skill Builder puzzle, the grids start very small and even the largest grid is just the smallest test case from the Shikaku Solver puzzle. The goal of Shikaku Skill Builder is to practice enumerating all the possible actions. Let\u2019s test your understanding.</p>"},{"location":"05-generating-actions/02-shikaku-skill-builder/#start-out-easy","title":"Start Out Easy","text":"<pre><code>          0 0 0\n          0 9 0\n          0 0 0\n</code></pre> <p>Given the grid above, how many ways can you place a tile with area 9 on the grid such that the number 9 is covered?</p> <p>\"Starting out easy\" might have been an understatement, right? There are only 3 ways to create a rectangle with area equal to 9: 3x3, 1x9 and 9x1. Since the grid is only 3 squares wide and 3 squares high, the only option is a 3x3 square that covers the entire grid.</p> <p></p>"},{"location":"05-generating-actions/02-shikaku-skill-builder/#2x1-vs-1x2","title":"2x1 vs 1x2","text":"<pre><code>          0 2 0 0\n          0 0 4 0\n          0 0 0 0\n</code></pre> <p>Given the grid above, how many ways can you place a tile with area 2 on the grid such that the number 2 is covered? Remember your tile must cover the 2, but it MUST NOT cover any other number.</p> <p>In this second example, rectangles of different widths and heights exist. In the puzzle, you will need to find every combination of height and width that creates the proper area and then figure out each location you could put the top-left corner and only cover the number in question.</p> <p></p>"},{"location":"05-generating-actions/02-shikaku-skill-builder/#rectangles-cannot-cover-two-numbers","title":"Rectangles Cannot Cover Two Numbers","text":"<pre><code>          0 2 0 0\n          0 0 4 0\n          0 0 0 0\n</code></pre> <p>Given the grid above, how many ways can you place a tile with area 4 on the grid such that the number 4 is covered? Remember your tile must cover the 4, but it MUST NOT cover any other number.</p> <p>In this third example, we see there is one place a 2x2 grid will not work because it covers a second number. Don\u2019t forget to try all combinations of width and height! Just looking at this grid visually, it is easy to miss the 1x4 rectangle.</p> <p></p>"},{"location":"05-generating-actions/02-shikaku-skill-builder/#ready-for-the-puzzle","title":"Ready for the Puzzle!","text":"<p>With the Shikaku Skill Builder puzzle, the goal is not to cover the grid. The goal is to identify every rectangle that could be used to build a potential solution. As I mentioned earlier, Algorithm X is really good at finding a set of actions that make a valid solution, but it cannot do its job unless you give it a full set of possible actions to consider. Hopefully this seems obvious and somewhat easy right now. As the puzzles grow in complexity, this process will get more and more challenging!</p> <p></p>"},{"location":"06-your-turn/01-shikaku-solver/","title":"Shikaku Solver","text":"<p>Puzzle: Shikaku Solver</p> <p>Author: @Westicles</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: The Puzzle Will Make You Smile</p>"},{"location":"06-your-turn/01-shikaku-solver/#strategy","title":"Strategy","text":"<p>I distinctly remember when I first finished the Shikaku Solver puzzle. I had just gotten started with Algorithm X and, if I remember correctly, this was the first exact cover puzzle I solved that did not feel like some sort of Sudoku. I came up with an exhaustive list of rectangles that could be placed on the grid, I fed those rectangles into Algorithm X and I was immediately rewarded with a list of solutions. I remember thinking to myself, \"Wow, this is so cool!\" I did not have to think about the backtracking at all. Algorithm X simply worked as advertised.</p> <p>The skill building in the last section should have given you a strong foundation with which to get started on this puzzle, but you still have some challenging work to do. Even if you successfully build a full list of possible rectangles and Algorithm X gives you solutions, determining the correct output will require some attention to detail.</p> <p>At the time of this writing, only 180 CodinGamers had finished this puzzle in the 5 years since it was published. I hope this playground inspires many, many more people to finish it. I believe the skills learned by this deep dive into Shikaku will serve you well as you move into some of the more complex exact cover problems still to come. </p> <p></p>"},{"location":"06-your-turn/02-dominoes-solver/","title":"Dominoes Solver","text":"<p>Puzzle: Dominoes Solver</p> <p>Author: @VilBoub</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: A Reasonable Challenge</p>"},{"location":"06-your-turn/02-dominoes-solver/#visualizing-the-problem","title":"Visualizing the Problem","text":"<p>The goal of Dominoes Solver is to:</p> <p>find the disposition of [the] dominoes.</p> <p>Did you ever do a color-by-number when you were young? Similar to the picture with numbers in the areas to color, we have a grid with numbers and we need to lay the dominoes down on the grid, making sure the numbers of the dominoes match up with the grid. It seems clear the actions we can take to solve the puzzle are simply putting each domino somewhere on the grid.</p>"},{"location":"06-your-turn/02-dominoes-solver/#strategy","title":"Strategy","text":"<p>How do you distinguish one action from another? Is it enough to say \u201cplace a domino at location <code>(row=0, col=0)</code> on the grid\u201d. No, it is not. Which domino are you placing at that location? How about \u201cplace domino <code>1-1</code> at location <code>(row=0, col=0)</code>\u201d? That is still not enough! Are you placing the domino horizontally or are you placing the domino vertically?</p> <p>When distinguishing actions for Algorithm X, it is critical that each action specification be enough to distinguish that action from all other actions. Remember too, only include legitimate actions. If there is a <code>2</code> at location <code>(row=0, col=0)</code>, you are not allowed to place domino <code>1-1</code> anywhere that covers <code>(row=0, col=0)</code>.</p> <p>How about the requirements? We know from the Output specification that all lines of output consist of only <code>|</code> or <code>=</code>, so we know the entire grid must be covered with dominoes. This seems similar to 9x9 Sudoku where the entire grid must be covered with numbers.</p> <p>Just covering the grid is not enough. There is another category of requirements you will need to distinguish to complete a model for Algorithm X. What else must happen to build a full solution? I\u2019ll give you a hint: the number of requirements in the second category of requirements is equal to <code>(n + 1) * (n + 2) / 2</code>.</p> <p>Dominoes Solver is a beautiful example of Exact Cover. All dominoes must be used, but no two dominoes are allowed to overlap. All spaces on the grid must be covered. The numbers on the grid must be properly covered by matching dominoes. From a modeling perspective, Dominoes Solver is a perfect opportunity to increase the model complexity a bit before moving into the next category of Exact Cover problems, Generalized Exact Cover.</p> <p></p>"},{"location":"06-your-turn/03-paving-with-bricks/","title":"Paving with Bricks","text":"<p>Puzzle: Paving with Bricks</p> <p>Author: @Sylvain0675</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: This is a Closed Book Test</p>"},{"location":"06-your-turn/03-paving-with-bricks/#strategy","title":"Strategy","text":"<p>The goal statement for this puzzle is so short, I will copy it all here:</p> <p>Your task is to determine how many pavings are possible for a rectangle using bricks of dimension 1 x 2 only.</p> <p>A paving is a way to cover all the surface with bricks (partition)</p> <p>Interesting! These bricks are the same <code>1 x 2</code> shape as the dominoes we just finished arranging. This puzzle asks us to count the number of possible solutions, just like we recently did in Constrained Latin Squares.</p> <p>Put your study materials away. Keep your eyes on your own work. This is a test! Start your timer. You have 60 minutes.</p> <p></p>"},{"location":"07-generalized-exact-cover/01-generalized-exact-cover/","title":"Generalized Exact Cover","text":"<p>If you completed all, or at least some portion, of the suggested puzzles, you should be gaining confidence in your ability to use Algorithm X to find solutions to an exact cover problem. Until now, I have been completely focused on requirements and actions, as summarized in the following table.</p> Playground Term Equivalent Terms Definition requirements items (preferred by Knuth)constraintscolumnsprimary itemsprimary constraintsprimary columns Must be satisfied exactly once. actions options (preferred by Knuth)rows The individual steps that can be taken to build a solution. <p>Hold everything! What is up with the word \"primary\"?</p> <p>This is the first time I have used the terms \u201cprimary constraint\u201d and \u201cprimary column\u201d, and there is a good reason for that. Generalized Exact Cover adds the concept of \u201csecondary constraints\u201d, sometimes referred to as \u201csecondary columns\u201d when referenced in terms of a matrix. I want you to know these terms, but in this playground, I\u2019m going to use the term \u201coptional requirement\u201d.</p> <p>What is the difference between a requirement (primary constraint/column) and an optional requirement (secondary constraint/column)? A requirement must be satisfied exactly once by a proper solution. It may not be left uncovered and it may not be covered more than once. On the other hand, an optional requirement is just what it says. It is optional. It does not need to be covered, but if it is covered, it can only be covered once.</p> <p>I\u2019m going to add one last equivalent term to the updated table below: At-Most-One-Time Constraint. The requirement may be covered, at most, one time, restricting the options to being covered zero times or exactly one time.</p> <p>There is a reason the term \u201coptional requirement\u201d works for me. There is only one difference between a requirement and an optional requirement. With an optional requirement, not being covered never causes failure. As Algorithm X is looking for solutions, having no ability to cover a remaining requirement causes a failure condition and Algorithm X backtracks. That is not the case with optional requirements. Algorithm X doesn\u2019t care if these optional requirements get covered at all, but Algorithm X very much cares that these optional requirements never get covered more than once.</p> Playground Term Equivalent Terms Definition requirements itemsconstraintscolumnsprimary itemsprimary constraintsprimary columns Must be satisfied exactly once. optional requirements secondary itemssecondary constraintssecondary columnsat-most-one-time constraints May be satisfied, but if so, one time only. actions optionsrows The individual steps that can be taken to build a solution. <p>To demonstrate a generalized exact cover, I will use the well-known, and widely-studied, Eight Queens Puzzle.</p> <p></p>"},{"location":"07-generalized-exact-cover/02-eight-queens/","title":"Eight Queens Problem","text":"<p>Wikipedia concisely states:</p> <p>The eight queens puzzle is the problem of placing eight chess queens on an 8\u00d78 chessboard so that no two queens threaten each other; thus, a solution requires that no two queens share the same row, column, or diagonal.</p>"},{"location":"07-generalized-exact-cover/02-eight-queens/#requirements","title":"Requirements","text":"<p>Obviously, the first requirement is that 8 queens be placed somewhere on the chessboard. Since there are only 8 rows and 8 columns and no two queens are allowed to be in the same row or column, we can say that a queen must be placed in each row and a queen must be placed in each column. To fully specify these requirements, we will need 16 distinct requirements:</p> <pre><code>('queen in row', 1)\n('queen in col', 1)\n('queen in row', 2)\n('queen in col', 2)\n\n[\u2026]\n\n('queen in row', 8)\n('queen in col', 8)\n</code></pre> <p>But, what about the diagonals? Take a look at the following image I found on math.stackexchange.com</p> <p></p> <p>There are 15 diagonals in the image and those are just the up-and-to-the-right diagonals. That doesn\u2019t include another 15 down-and-to-the-right diagonals. We only have 8 queens, making it impossible to fully cover either set of 15 diagonals. However, if a diagonal is occupied by a queen, it is critical that no other queen be in that same diagonal.</p> <p>These diagonals perfectly fit the definition of an optional requirement. While rows and columns on the board must have exactly one queen, the diagonals may or may not have a queen, but if a diagonal is covered by a queen, it must not be covered by more than one queen.</p> <p>The picture above assigns a unique integer to each of the up-and-to-the-right diagonals. For completeness, let\u2019s assign the numbers 16 to 30 to the down-and-to-the-right diagonals, starting in the bottom-left corner. This results in the following 30 distinct optional requirements:</p> <pre><code>('queen in diagonal', 1)\n('queen in diagonal', 2)\n('queen in diagonal', 3)\n\n[\u2026]\n\n('queen in diagonal', 28)\n('queen in diagonal', 29)\n('queen in diagonal', 30)\n</code></pre> <p>Our complete set of requirements looks like this:</p> <pre><code>requirements = 8 rows + 8 columns\n\noptional_requirements = 30 diagonals\n</code></pre>"},{"location":"07-generalized-exact-cover/02-eight-queens/#actions","title":"Actions","text":"<p>Hopefully, you already see there are 64 actions that can be taken. You can place a queen on any one of the 64 squares. The hardest part about the 8 Queens puzzle is building the list of requirements satisfied by each action. Assuming rows are numbered from top to bottom and columns are numbered from left to right, let's look at placing a queen in the top left corner.</p> <pre><code>action = ('place queen', 1, 1)\n\ncovered requirements = ('queen in row', 1)\n                       ('queen in col', 1)\n                       ('queen in diagonal', 1)\n                       ('queen in diagonal', 23)\n</code></pre> <p>Remember, I previously suggested numbering the down-and-to-the-right diagonals from 16 to 30, starting in the bottom-left corner. When solving the 8 Queens puzzle with Algorithm X, you might find determining the unique identifiers of the diagonals to be challenging. You won't want to hard-code all of your actions and requirements, so you will need to develop a formula that takes a (row, col) combination and gives you two diagonal identifiers.</p>"},{"location":"07-generalized-exact-cover/02-eight-queens/#moving-on","title":"Moving On...","text":"<p>That is all there is to it! Looking at the 8 Queens puzzle as a generalized exact cover makes the entire problem easier to digest. Before we apply these new concepts to a few puzzles, we need to take a look at one of the most common places optional requirements show up in models...mutual exclusivity.</p> <p></p>"},{"location":"07-generalized-exact-cover/03-mutually-exclusive-actions/","title":"Mutual Exclusivity","text":"<p>The Merriam-Webster Dictionary defines mutually exclusive as:</p> <p>: being related such that each excludes or precludes the other</p> <p>mutually exclusive events</p> <p>Assume I have an exact cover problem and the possible actions are <code>(A, B, C, D)</code>. Also assume the solution will consist of two actions, but we know <code>A</code> and <code>C</code> are mutually exclusive. It's pretty easy to see the possible solutions are <code>(A, B)</code>, <code>(A, D)</code>, <code>(B, C)</code>, <code>(B, D)</code> or <code>(C, D)</code>. It is not possible for <code>(A, C)</code> to be a proper solution since <code>A</code> and <code>C</code> are mutually exclusive and cannot both be part of the same solution. How can we include this knowledge in the model we build to feed Algorithm X?</p>"},{"location":"07-generalized-exact-cover/03-mutually-exclusive-actions/#optional-requirements-to-the-rescue","title":"Optional Requirements to the Rescue","text":"<p>Mutual exclusivity comes up frequently in generalized exact cover problems and the solution is fairly simple. For each set of mutually exclusive actions, create a new optional requirement. The example above only needs a single optional requirement:</p> <pre><code>('A', 'C')\n</code></pre> <p>This optional requirement must be added to the lists of satisfied requirements for both <code>A</code> and <code>C</code>. Since both actions satisfy the requirement and all requirements can only be satisfied, at most, one time, there is no way for <code>A</code> and <code>C</code> to both show up in the same solution.</p>"},{"location":"07-generalized-exact-cover/03-mutually-exclusive-actions/#what-exactly-are-a-and-c","title":"What Exactly are <code>'A'</code> and <code>'C'</code>?","text":"<p>Let\u2019s say I need an algorithm to identify smoothie recipes that meet certain criteria, one of which is that I never want bananas and kale in the same smoothie. Neither ingredient is required for a proper smoothie, but if either is used, the other must not be added to the mix. To address this, I create the following optional requirement:</p> <pre><code>('banana', 'kale')\n</code></pre> <p>Putting bananas in a smoothie satisfies this requirement. Putting kale in a smoothie satisfies this requirement. Because Algorithm X will only allow this requirement to be satisfied, at most, one time, there is no way for both bananas and kale to end up in the same smoothie.</p> <p>Unfortunately, the mutually exclusive elements are rarely (*see note below) as simple as <code>'banana'</code> and <code>'kale'</code>. More often, a tuple of data is needed to distinguish the mutually exclusive elements. In logic puzzles, numbers are often being placed on a grid. Consider a puzzle where each cell of a grid must not have the same number as any cell with which it shares a horizontal or a vertical border. To fully implement this rule requires a bunch of optional requirements to enforce mutual exclusivity. Let\u2019s assume we have chosen to use tuples of the form <code>(row, col, number)</code>. Each new requirement takes this form:</p> <pre><code>((0, 0, 4), (0, 1, 4))       # ((row, col, number), (row, col, number))\n</code></pre> <p>What does this requirement tell us? The number <code>4</code> can be put in <code>(row 0, col 0)</code> or the number <code>4</code> can be put in <code>(row 0, col 1)</code>, but both cannot happen in the same solution. You should see that two distinct actions cover this one requirement. Putting a <code>4</code> in <code>(row 0, col 0)</code> covers this requirement. Putting a <code>4</code> in <code>(row 0, col 1)</code> covers this requirement. Because the requirement may only be covered once, all solutions produced by Algorithm X will fall into one of 3 categories:</p> <ol> <li> <p>The solution does not have a <code>4</code> in <code>(row 0, col 0)</code>, nor does it have a <code>4</code> in <code>(row 0, col 1)</code></p> </li> <li> <p>The solution has a <code>4</code> in <code>(row 0, col 0)</code>, and some other number in <code>(row 0, col 1)</code>.</p> </li> <li> <p>The solution has a <code>4</code> in <code>(row 0, col 1)</code>, and some other number in <code>(row 0, col 0)</code>.</p> </li> </ol> <p>This might seem like an excruciating amount of detail, but mastering mutual exclusivity will feel like a superpower as you solve more and more challenges with Algorithm X.</p> <p>Note: I intentionally avoided the word never. It does happen, so never rule out the simple approach!</p>"},{"location":"07-generalized-exact-cover/03-mutually-exclusive-actions/#breaking-news","title":"BREAKING NEWS","text":"<p>Believe it or not, another school year has flown by, and Mrs. Knuth needs your help again. She has a few features she would like you to add, and oddly enough, her requests will give you a marvelous opportunity to practice using optional requirements to implement mutual exclusivity.</p> <p></p>"},{"location":"07-generalized-exact-cover/04-mrs-knuth-requirements/","title":"Puzzle Overview - Mrs. Knuth is Back!","text":"<p>How about the good news first? Most of the input and all of the output has not changed for Mrs. Knuth \u2013 Part II. Let\u2019s see what changes she has requested\u2026</p> <p>Puzzle: Mrs. Knuth \u2013 Part II</p> <p>Mrs. Knuth's schedule needs to be more flexible than she first thought. She isn't able to always teach the same number of hours on her teaching days. She also doesn't always have enough students to completely fill her <code>teacherAvailability</code>. You'll need to adjust your algorithm to handle her <code>teacherAvailability</code> possibly containing different numbers of hours for each day she teaches and you'll need to be able to handle hours in her <code>teacherAvailability</code> for which there ends up being no student scheduled.</p> <p>Mrs. Knuth might have more hours of availability than students. In Part I, it was required that each slot in Mrs. Knuth\u2019s availability get filled. It appears now that some slots might not get filled. Of course, she cannot teach two students at the same time, so if a slot is filled, it can only be filled with one student. Hmmm\u2026.sounds like an optional requirement.</p> <p>You might be impressed with Mrs. Knuth's newfound flexibility, but don't get too relaxed. She still requires that no instrument be taught more than one hour on any one day.</p> <p>It is important to note that Mrs. Knuth might not teach the same number of hours on each day and because of that, it is not guaranteed that she will teach all the same instruments on each day. Still, we must make sure she does not teach a single instrument more than one time per day, but it is also possible certain instruments will not be taught on certain days.</p> <p>On top of that, she has struggled with <code>loudInstrument</code>s, specifically the Trumpet, the Drums and the Trombone. In the interest of her long-term hearing, she has asked that you make sure no two <code>loudInstrument</code>s are ever scheduled back-to-back. (A lesson at 11am and a lesson at 1pm are not considered back-to-back since there is an hour lunch break between the two.)</p> <p>No two loud instruments are ever to be scheduled back-to-back, meaning, if a trumpet is scheduled on Friday at 10, we must not schedule a trombone on Friday at 11. Definitely sounds like mutual exclusivity, doesn\u2019t it?</p> <p>For the most part, the kids in school are good kids, but some kids get a bit rowdy when they are with certain friends. To avoid disruptions to her schedule, Mrs. Knuth has given you a list of <code>troublesomePair</code>s. It's important the individuals in these pairs never be scheduled back-to-back. There must be at least an hour of time between the two individuals to ensure they don't get each other wound up and start causing trouble.</p> <p>Here we see another classic example of mutual exclusivity. If Emma and Anna are a troublesome pair, we need to make sure they are not scheduled back-to-back.</p> <p>Despite Mrs. Knuth's wacky requests, all students must get a spot on her schedule.</p> <p>It definitely seems like each student being scheduled remains a requirement.</p>"},{"location":"07-generalized-exact-cover/04-mrs-knuth-requirements/#example-test-case","title":"Example Test Case","text":"<p>Let's take a look at the example test case:</p> <pre><code>M Tu W Th F 8 9 10 11 1\n3\nDrew Trombone M Tu W Th F 10 11 1\nElla Flute M Tu W Th F 10 1\nLola Drums M Tu W Th F 11 1\n1\nDrew Ella\n</code></pre> <p>Mrs. Knuth is available on Fridays at 8, 9, 10, 11 and 1. Three students need to be scheduled. Drew (trombone) is available on Friday at 10, 11 and 1, Ella (flute) is available on Friday at 10 and 1, and Lola (drums) is available on Friday at 11 and 1. We know all students must be scheduled, so these are standard, must-be-covered-exactly-one-time requirements.</p> <pre><code>Requirements:\n    ('student scheduled', 'Drew')\n    ('student scheduled', 'Ella')\n    ('student scheduled', 'Lola')\n</code></pre> <p>What about filling the teacher availability slots? We already know some slots might remain empty and we know that is definitely the case here since there are 3 students and 5 teacher slots. Even though slots don\u2019t need to be filled, any slot that is filled can only be filled once. This perfectly fits the definition of an optional requirement.</p> <pre><code>Optional Requirements:\n    ('slot filled', 'F', 8)\n    ('slot filled', 'F', 9)\n    ('slot filled', 'F', 10)\n    ('slot filled', 'F', 11)\n    ('slot filled', 'F', 1)\n</code></pre> <p>You may have noticed that none of the students are available on Friday before 10, so you could reduce the problem space and eliminate the top two optional requirements. However, I don\u2019t recommend doing that currently. I\u2019ll talk about problem space reduction later in the playground. For now, stick to the process as there is a more-than-reasonable chance that later test cases will be more complex and might not be conducive to the same reductions.</p> <p>Let\u2019s think ahead a bit about the <code>instrument on day</code> requirements. In this simple example, there are three instruments and there is only one day, but we know from the problem statement that Mrs. Knuth might not teach the same number of hours on every day. During any one day of teaching, an instrument might not be taught or it might be taught one time. It cannot be taught more than one time on the same day. We will add these requirements to our list of optional requirements.</p> <pre><code>Optional Requirements:\n    ('slot filled', 'F', 8)\n    ('slot filled', 'F', 9)\n    ('slot filled', 'F', 10)\n    ('slot filled', 'F', 11)\n    ('slot filled', 'F', 1)\n    ('instrument on day', 'F', 'Trombone')\n    ('instrument on day', 'F', 'Drums')\n    ('instrument on day', 'F', 'Flute')\n</code></pre>"},{"location":"07-generalized-exact-cover/04-mrs-knuth-requirements/#troublesome-pairs","title":"Troublesome Pairs","text":"<p>What about Drew and Ella being a troublesome pair? We need to look at the availability of Drew and and the availability of Ella and identify where we could have a situation we need to avoid. Based on their availability, the only way we could create a problem is by scheduling Ella on Friday at 10 and Drew on Friday at 11. We need to create an optional requirement that can make sure this never happens. It is important this new requirement have two components, similar to the <code>(A, C)</code> used in the previous mutual exclusivity example. We will use a tuple of two tuples. One of the tuples applies to Ella and the other applies to Drew.</p> <pre><code>Optional Requirements to Handle Mutual Exclusivity of Troublesome Pairs:\n    (('Ella', 'F', 10), ('Drew', 'F', 11))\n</code></pre>"},{"location":"07-generalized-exact-cover/04-mrs-knuth-requirements/#loud-instruments","title":"Loud Instruments","text":"<p>The last detail we need to handle is making sure no two loud instruments are scheduled back-to-back. Because this is a very simple test case, it will be tempting to look at the students and see where two loud instruments might conflict, like what we did above with Ella and Drew. Do your best to avoid that temptation! As the test cases get harder, this will be more challenging and it just is not necessary. Instead, only focus on Mrs. Knuth\u2019s availability and add an optional requirement for every pair of back-to-back time slots:</p> <pre><code>Optional Requirements to Handle Mutual Exclusivity of Back-to-Back Loud Instruments:\n    (('loud instrument', 'F', 8), ('loud instrument', 'F', 9))\n    (('loud instrument', 'F', 9), ('loud instrument', 'F', 10))\n    (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))\n</code></pre> <p>The first requirement states, I can put a loud instrument in the Friday at 8 timeslot or I can put a loud instrument in the Friday at 9 timeslot, but I cannot do both. I can't do both because actions in our scheduling domain all involve placing one student with that student's instrument on some day at some time. Since the requirement may only be covered once, either the first action could happen or the second action could happen, not both.</p>"},{"location":"07-generalized-exact-cover/04-mrs-knuth-requirements/#the-full-list-of-requirements","title":"The Full List of Requirements","text":"<p>Putting all the requirements in one place results in the following:</p> <pre><code>Requirements:\n    ('student scheduled', 'Drew')\n    ('student scheduled', 'Ella')\n    ('student scheduled', 'Lola')\n\nOptional Requirements:\n    ('slot filled', 'F', 8)\n    ('slot filled', 'F', 9)\n    ('slot filled', 'F', 10)\n    ('slot filled', 'F', 11)\n    ('slot filled', 'F', 1)\n    ('instrument on day', 'F', 'Trombone')\n    ('instrument on day', 'F', 'Drums')\n    ('instrument on day', 'F', 'Flute')\n    (('Ella', 'F', 10), ('Drew', 'F', 11))\n    (('loud instrument', 'F', 8), ('loud instrument', 'F', 9))\n    (('loud instrument', 'F', 9), ('loud instrument', 'F', 10))\n    (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))\n</code></pre> <p>That is a bunch more requirements than we needed to model Mrs. Knuth - Part I. There is a lot more going on now with more slots than students and the mutual exclusivity that affects troublesome pairs and back-to-back loud instruments. Each of the 3 requirements must be covered exactly once. The 12 optional requirements may or may not be covered, but if they are, they can only be covered one time.</p> <p>Before we finish our model for Mrs. Knuth - Part II, let's see if we can quantify, just a bit, how much more power is given to Algorithm X by identifying these optional requirements.</p> <p></p>"},{"location":"07-generalized-exact-cover/05-mrs-knuth-analysis/","title":"Constraining the Realm of Possibility","text":"<p>Could you use the solver you wrote for Mrs. Knuth \u2013 Part I to solve this new Part II? You sure could, but your Part I solver doesn\u2019t know anything about Troublesome Pairs and Loud Instruments. If you used that original solver, solutions found by Algorithm X would simply need to be checked after they were generated. The puzzle guarantees that every test case has a unique solution, so you could stop checking solutions as soon as you found the proper one, but, in the worst-case scenario, here are the numbers of solutions you have to check in order to find the proper solution.</p> Test Case Solutions To Test if Not Handling Mutual Exclusivity 1 - Basic 3 2 - Still Pretty Easy 10 3 - Long Day of Potential Conflicts 27 4 - Two Moderate Days 94 5 - Three-Day Workweek 290 6 - Four Moderate Days 362 7 - Four Days with Many Options 5,578 8 - Significant Free Time 114 9 - Five-Day Workweek 7,738 10 - Five Very Full Days I 25,281 11 - Five Very Full Days II 65,887 <p>The execution times required to find and count all these solutions are significantly higher than the time it takes Algorithm X to completely process the matrix and find the unique solution. When I say \u201ccompletely process the matrix\u201d, I mean that I am not using a <code>break</code> statement to stop Algorithm X after if finds the first solution. To compare total processing time, Algorithm X continues searching for a second solution until it has exhausted all options.</p> <p>My analysis simply counts the solutions that need to be tested. None of the time required to check those solutions has been included. Even the most efficient checking code would need to be executed up to 65,887 times to find the correct solution for Test Case 11.</p> <p>Just like in Mrs. Knuth \u2013 Part I, we see tremendous power in providing as much knowledge as possible to Algorithm X. Later in this playground, we will work with situations that require additional processing outside the standard Algorithm X backtracking. For now, I want to emphasize, Algorithm X and DLX are specifically designed to efficiently handle the backtracking and maximizing the knowledge passed to Algorithm X will maximize speed and overall problem efficiency.</p> <p>Next, we will take a look at the actions, the relationship between the requirements and the actions, and the matrix.</p> <p></p>"},{"location":"07-generalized-exact-cover/06-mrs-knuth-actions/","title":"Mrs Knuth Part II - Actions","text":"<p>Actions in Mrs. Knuth - Part II are identical in format to actions in Mrs. Knuth - Part I. One possible action is needed for each student for each day/hour of the student\u2019s availability. The possible actions in the example test case are:</p> <pre><code>('place student', 'Drew', 'Trombone', 'F', 10)\n('place student', 'Drew', 'Trombone', 'F', 11)\n('place student', 'Drew', 'Trombone', 'F', 1)\n('place student', 'Ella', 'Flute', 'F', 10)\n('place student', 'Ella', 'Flute', 'F', 1)\n('place student', 'Lola', 'Drums', 'F', 11)\n('place student', 'Lola', 'Drums', 'F', 1)\n</code></pre> <p>Next, we identify the requirements satisfied by each of those actions. I\u2019ll add the full list of requirements and optional requirements so that the next segment captures a full model of the example test case for Mrs. Knuth \u2013 Part II.</p> <pre><code>Requirements:\n    ('student scheduled', 'Drew')\n    ('student scheduled', 'Ella')\n    ('student scheduled', 'Lola')\n\nOptional Requirements:\n    ('slot filled', 'F', 8)\n    ('slot filled', 'F', 9)\n    ('slot filled', 'F', 10)\n    ('slot filled', 'F', 11)\n    ('slot filled', 'F', 1)\n    ('instrument on day', 'F', 'Trombone')\n    ('instrument on day', 'F', 'Drums')\n    ('instrument on day', 'F', 'Flute')\n    (('Ella', 'F', 10), ('Drew', 'F', 11))\n    (('loud instrument', 'F', 8), ('loud instrument', 'F', 9))\n    (('loud instrument', 'F', 9), ('loud instrument', 'F', 10))\n    (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))\n\nAction: ('place student', 'Drew', 'Trombone', 'F', 10)\n    Satisfied Requirements: ('student scheduled', 'Drew')\n                            ('slot filled', 'F', 10)\n                            ('instrument on day', 'F', 'Trombone')\n                            (('loud instrument', 'F', 9), ('loud instrument', 'F', 10))\n                            (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))\n\nAction: ('place student', 'Drew', 'Trombone', 'F', 11)\n    Satisfied Requirements: ('student scheduled', 'Drew')\n                            ('slot filled', 'F', 11)\n                            ('instrument on day', 'F', 'Trombone')\n                            (('Ella', 'F', 10), ('Drew', 'F', 11))\n                            (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))\n\nAction: ('place student', 'Drew', 'Trombone', 'F', 1)\n    Satisfied Requirements: ('student scheduled', 'Drew')\n                            ('slot filled', 'F', 1)\n                            ('instrument on day', 'F', 'Trombone')\n\nAction: ('place student', 'Ella', 'Flute', 'F', 10)\n    Satisfied Requirements: ('student scheduled', 'Ella')\n                            ('slot filled', 'F', 10)\n                            ('instrument on day', 'F', 'Flute')\n                            (('Ella', 'F', 10), ('Drew', 'F', 11))\n\nAction: ('place student', 'Ella', 'Flute', 'F', 1)\n    Satisfied Requirements: ('student scheduled', 'Ella')\n                            ('slot filled', 'F', 1)\n                            ('instrument on day', 'F', 'Flute')\n\nAction: ('place student', 'Lola', 'Drums', 'F', 11)\n    Satisfied Requirements: ('student scheduled', 'Lola')\n                            ('slot filled', 'F', 11)\n                            ('instrument on day', 'F', 'Drums')\n                            (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))\n\nAction: ('place student', 'Lola', 'Drums', 'F', 1)\n    Satisfied Requirements: ('student scheduled', 'Lola')\n                            ('slot filled', 'F', 1)\n                            ('instrument on day', 'F', 'Drums')\n</code></pre> <p></p>"},{"location":"07-generalized-exact-cover/07-mrs-knuth-matrix/","title":"Visualizing the Model - Mrs Knuth Part II","text":"<p>The matrix below shows which requirements are satisfied by each action. Mrs. Knuth - Part II does not add an overwhelming amount of complexity, yet the matrix has grown enough, even on the tiny example exercise, that it is no longer trivial to identify an exact cover just by looking at it.</p> <p></p> <p>In the next matrix, the rows that make up the only solution are highlighted. It is very easy to see columns that are not necessary since they are not covered by any rows. Eventually, it may be important to optimize your matrix where possible, but you can trust me for now, Algorithm X quickly handles all Mrs. Knuth test cases without any effort to make sure empty columns have been eliminated.</p> <p></p> <p>Like we have done before, let's hide the unused rows to highlight the exact cover.</p> <p></p> <p>In the next section, I\u2019ll discuss how to add optional requirements to your <code>AlogrithmXSolver</code> subclass.</p> <p></p>"},{"location":"07-generalized-exact-cover/08-your-solver/","title":"Extending your <code>AlgorithmXSolver</code> Subclass","text":"<p>Adding optional requirements to your solver is as easy as passing a third argument to the <code>AlgorithmXSolver</code> constructor. Before I walk through the code, I need to address an alternate option that allows Algorithm X to handle a generalized exact cover. In the Wikipedia Exact Cover discussion, you will see the following:</p> <p>As Knuth explains, a generalized exact cover problem can be converted to an equivalent exact cover problem by simply appending one row for each secondary column, containing a single 1 in that column.[6] If in a particular candidate solution a particular secondary column is satisfied, then the added row isn't needed. But if the secondary column isn't satisfied, as is allowed in the generalized problem but not the standard problem, then the added row can be selected to ensure the column is satisfied.</p> <p>The next paragraph in the Wikipedia article continues with:</p> <p>But Knuth goes on to explain that it is better working with the generalized problem directly, because the generalized algorithm is simpler and faster: A simple change to his Algorithm X allows secondary columns to be handled directly. [emphasis added]</p> <p>With my <code>AlgorithmXSolver</code>, you never need to add extra rows as is suggested in the first paragraph. Could you? Yes, you could. You could add the extra rows and only use the requirements argument. You could do some of both. However, I don\u2019t recommend any of that.</p> <p>Conceptually, problems have requirements (primary constraints/columns) and optional requirements (secondary constraints/columns). I recommend always keeping them separate, passing them to the <code>AlgorithmXSolver</code> constructor separately, and letting the <code>AlgorithmXSolver</code> handle the needed algorithmic changes.</p> <p>In the general sense, your new solver subclass takes the following form:</p> <pre><code>class MrsKnuthPartIISolver(AlgorithmXSolver):\n\n    def __init__(self, arguments):\n\n        requirements = list()\n        optional_requirements = list()\n\n        actions = dict()\n\n        super().__init__(requirements, actions, optional_requirements)\n</code></pre> <p>The following hard-coded solution brings all the previous concepts together. Copy this code into your coding environment and experiment with it. If needed, include the full AlgorithmXSolver code directly instead of relying on the <code>import</code> statement.</p> <pre><code># Unless your coding environment will let you create an AlgorithmX package,\n# you will need to copy all of the AlgorithmXSolver code into your code.\n\nfrom AlgorithmX import AlgorithmXSolver\n\nclass MrsKnuthPartIISolver(AlgorithmXSolver):\n\n    def __init__(self, teacher_availability, students):\n\n        requirements = [('student scheduled', 'Drew'),\n                        ('student scheduled', 'Ella'),\n                        ('student scheduled', 'Lola')]\n\n        optional_requirements = [('slot filled', 'F', 8),\n                                 ('slot filled', 'F', 9),\n                                 ('slot filled', 'F', 10),\n                                 ('slot filled', 'F', 11),\n                                 ('slot filled', 'F', 1),\n                                 ('instrument on day', 'F', 'Trombone'),\n                                 ('instrument on day', 'F', 'Drums'),\n                                 ('instrument on day', 'F', 'Flute'),\n                                 (('Ella', 'F', 10), ('Drew', 'F', 11)),\n                                 (('loud instrument', 'F', 8), ('loud instrument', 'F', 9)),\n                                 (('loud instrument', 'F', 9), ('loud instrument', 'F', 10)),\n                                 (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        actions = dict()\n\n        action = ('place student', 'Drew', 'Trombone', 'F', 10)\n        actions[action] = [('student scheduled', 'Drew'),\n                           ('slot filled', 'F', 10),\n                           ('instrument on day', 'F', 'Trombone'),\n                           (('loud instrument', 'F', 9), ('loud instrument', 'F', 10)),\n                           (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        action = ('place student', 'Drew', 'Trombone', 'F', 11)\n        actions[action] = [('student scheduled', 'Drew'),\n                           ('slot filled', 'F', 11),\n                           ('instrument on day', 'F', 'Trombone'),\n                           (('Ella', 'F', 10), ('Drew', 'F', 11)),\n                           (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        action = ('place student', 'Drew', 'Trombone', 'F', 1)\n        actions[action] = [('student scheduled', 'Drew'),\n                           ('slot filled', 'F', 1),\n                           ('instrument on day', 'F', 'Trombone')]\n\n        action = ('place student', 'Ella', 'Flute', 'F', 10)\n        actions[action] = [('student scheduled', 'Ella'),\n                           ('slot filled', 'F', 10),\n                           ('instrument on day', 'F', 'Flute'),\n                           (('Ella', 'F', 10), ('Drew', 'F', 11))]\n\n        action = ('place student', 'Ella', 'Flute', 'F', 1)\n        actions[action] = [('student scheduled', 'Ella'),\n                           ('slot filled', 'F', 1),\n                           ('instrument on day', 'F', 'Flute')]\n\n        action = ('place student', 'Lola', 'Drums', 'F', 11)\n        actions[action] = [('student scheduled', 'Lola'),\n                           ('slot filled', 'F', 11),\n                           ('instrument on day', 'F', 'Drums'),\n                           (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        action = ('place student', 'Lola', 'Drums', 'F', 1)\n        actions[action] = [('student scheduled', 'Lola'),\n                           ('slot filled', 'F', 1),\n                           ('instrument on day', 'F', 'Drums')]\n\n        super().__init__(requirements, actions, optional_requirements)\n\n\nteacher_availability = None\nstudents = None\n\nsolver = MrsKnuthPartIISolver(teacher_availability, students)\n\nfor solution in solver.solve():\n    print(f'These are the steps to build a solution:') \n    for _, name, instrument, day, hour in solution:\n        print(f'   Add {name}/{instrument} to Mrs. Knuth\\'s schedule on {day} at {hour}.')\n</code></pre> <p></p>"},{"location":"08-your-turn/01-mrs-knuth-part-II/","title":"Time to Finish Mrs. Knuth - Part II","text":"<p>You have everything you need to finish up Mrs. Knuth - Part II. Before you embark on that journey, I want to give you a bit of insight into one coding technique I use over and over when dealing with mutually exclusive (ME) requirements. I keep them separate from the other requirements until I am ready to pass them to the <code>AlgorithmXSolver</code> constructor. I do that so I can easily add the appropriate ME requirements to the list of requirements satisfied by each action. The following is a mix of Python and pseudocode that you might find helpful as you organize your subclass constructor code.</p> <pre><code>class MrsKnuthPartIISolver(AlgorithmXSolver):\n\n    # Add a class attribute to identify loud instruments.\n    LOUD_INSTRUMENTS = ['Trumpet', 'Trombone', 'Drums']\n\n    def __init__(self, teacher_availability, students):\n\n        # In this example, the requirements are still hard-coded for the example test case.\n\n        requirements = [('student scheduled', 'Drew'),\n                        ('student scheduled', 'Ella'),\n                        ('student scheduled', 'Lola')]\n\n        optional_requirements = [('slot filled', 'F', 8),\n                                 ('slot filled', 'F', 9),\n                                 ('slot filled', 'F', 10),\n                                 ('slot filled', 'F', 11),\n                                 ('slot filled', 'F', 1),\n                                 ('instrument on day', 'F', 'Trombone'),\n                                 ('instrument on day', 'F', 'Drums'),\n                                 ('instrument on day', 'F', 'Flute')]\n\n        # Keep the ME requirements separate until after the actions are built.\n        me_requirements = [(('Ella', 'F', 10), ('Drew', 'F', 11)),\n                           (('loud instrument', 'F', 8), ('loud instrument', 'F', 9)),\n                           (('loud instrument', 'F', 9), ('loud instrument', 'F', 10)),\n                           (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        # Rather than hard-coding the actions, I will provide more generic pseudocode.\n        actions = dict()\n\n        for each student:\n            for each day in the students availability:\n                for each hour of availability on this day:\n                    action = ('place student', student name, student instrument, day, hour)\n                    actions[action] = [('student scheduled', student name),\n                                       ('slot filled', day, hour),\n                                       ('instrument on day', day, instrument)]\n\n                    # At this point, only the requirements and optional requirements have been\n                    # added to the list. We still need to add ME requirements for potential\n                    # troublesome pairs and/or loud instrument conflicts.\n\n                    # Use a list comprehension to add any applicable troublesome pair ME requirements.\n                    actions[action] += [me for me in me_requirements if (student name, day, hour) in me]\n\n                    # Use a list comprehension to add any applicable loud instrument ME requirements.\n                    if the student plays a loud instrument\n                        actions[action] += [me for me in me_requirements if ('loud instrument', day, hour) in me]\n\n        # Now that relationships between requirements and actions have been identified, make sure the\n        # ME requirements are properly included with the rest of the optional requirements.\n\n        optional_requirements += me_requirements \n\n        super().__init__(requirements, actions, optional_requirements)\n</code></pre> <p>Problems that feature mutual exclusivity can have a significant number of <code>me_requirements</code>. Keeping the <code>me_requirements</code> separate until the rest of your setup is complete makes it easy to use a list comprehension to filter out and include just the appropriate <code>me_requirements</code>.</p> <p>Now, on to the puzzle!</p> <p></p>"},{"location":"08-your-turn/02-n-queens/","title":"n Queens","text":"<p>Puzzle: n Queens</p> <p>Author: @VilBoub</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Straightforward</p>"},{"location":"08-your-turn/02-n-queens/#strategy","title":"Strategy","text":"<p>The proper answer for each n Queens test case is widely known and well documented. Still, coding a working solution using Algorithm X is a must as n Queens is one of the all-time great exact cover examples. Using what you learned from the 8 Queens discussion, you should be able to fly through this exercise, assuming you come up with a good way to map a (row, col) location to a diagonal.</p> <p></p>"},{"location":"08-your-turn/03-finish-eight-queens/","title":"Finish the Eight Queens","text":"<p>Puzzle: Finish the Eight Queens</p> <p>Author: @Ondra77</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Straightforward</p>"},{"location":"08-your-turn/03-finish-eight-queens/#strategy","title":"Strategy","text":"<p>It should be fairly simple to use your code from n Queens to create a solution for this puzzle. You need to limit the possible actions so that Algorithm X is forced to place queens on board locations prefilled with a <code>Q</code>. The hard way to do that is to completely restrict the actions to only locations on the board where a queen could be placed. I will let you figure out the easier way!</p> <p></p>"},{"location":"08-your-turn/04-optimized-coloring/","title":"Optimized Coloring","text":"<p>Puzzle: Optimized Coloring</p> <p>Author: @flopy78</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: If At First You Don't Succeed, Try Again!</p>"},{"location":"08-your-turn/04-optimized-coloring/#identifying-zones","title":"Identifying Zones","text":"<p>Before putting any thought into an Algorithm X approach to this puzzle, the cells of the picture must be organized into zones. From the problem statement:</p> <p>Having an empty sheet of paper divided into some zones</p> <p>A zone is made of \"space\" characters.</p> <p>I will move forward assuming you have created a list of zones where each zone is a list of row, col <code>(r, c)</code> <code>tuple</code>s. Each <code>(r, c)</code> <code>tuple</code> identifies one \u201cspace\u201d character found in the zone. Again from the problem statement:</p> <p>two adjacent zones must be filled with two different colors.</p> <p>Let\u2019s call \u201ctwo adjacent zones\u201d a set of neighbors and let\u2019s rephrase the statement above as:</p> <p>two neighbors must never be filled with the same color</p> <p>Algorithm X needs to know every set of neighbor zones so it can make sure no neighbors are ever assigned the same color. And, how do we ensure that does not happen? Correct! Mutual exclusivity.</p> Spoiler Alert: Python suggestions for finding neighbor zones. <p>You need to look at every combination of 2 zones and determine if those two zones are neighbors. This is a great opportunity to use <code>itertools.combinations</code>.</p> <pre><code># assumed data structure\n# zones : List[List[tuple]] \u2013 each zone in zones is a list of (r, c) tuples\n\nfrom itertools import combinations\n\nneighbors = []\nfor zone_1, zone_2 in combinations(zones, 2):\n    for (r1, c1) in zone_1:\n        for (r2, c2) in zone_2:\n            if the two cells indicate the zones are neighbors:\n                add (zone_1, zone_2) to the list of neighbors\n                stop checking and move on to the next combination of zones\n</code></pre> <p>If you really want to make your code \u201cPythonic\u201d, try this:</p> <pre><code># assumed data structure\n# zones : List[List[tuple]] \u2013 each zone in zones is a list of (r, c) tuples\n\nfrom itertools import combinations\n\nneighbors = []\nfor zone_1, zone_2 in combinations(zones, 2):\n    if any((r1, c1, r2, c2 indicate zones are neighbors) for (r1, c1) in zone_1 for (r2, c2) in zone_2):\n        add (zone_1, zone_2) to the list of neighbors\n</code></pre> <p>The code is still very readable, but the use of <code>any</code> has shortened the code and eliminated the need to do further checking to break out of the nested <code>for</code> loops.</p> <p>In the Python code above, I have intentionally left out the details needed to replace <code>(r1, c1, r2, c2 indicate zones are neighbors)</code> with code. Several CodinGamers have asked for clarification on how to determine when two zones are neighbors and when they are not neighbors. Almost every puzzle on CodinGame has a discussion tab and if you need more help determining neighbors, click here to open this puzzle\u2019s discussion tab.</p>"},{"location":"08-your-turn/04-optimized-coloring/#algorithm-x-setup","title":"Algorithm X Setup","text":"<p>This puzzle asks us to find the least number of colors with which the picture can successfully be colored without any two neighbor zones having the same color. Depending on where you are in your Algorithm X journey, something might seem a bit odd. Compare this puzzle\u2019s request to another hypothetical puzzle that might ask:</p> <p>Given 5 different colors, find all possible ways a picture can be colored, such that no two neighbor zones are colored the same.</p> <p>In this hypothetical puzzle, what are the requirements? Each zone must be colored. How do we make sure no two neighbors are colored the same? We create an optional requirement to handle mutual exclusivity for every color for every set of neighbors. For instance, assume zone 1 and zone 2 are neighbors. If zone 1 is assigned color 1, then zone 2 must not be assigned color 1. This sentence could be restated as: If zone 1 and zone 2 are neighbors, one or the other can be assigned color 1, but not both.</p> <p>Assuming the problem has <code>x</code> zones and <code>y</code> colors, there are <code>x * y</code> actions. Each action assigns a specific color to a specific zone. Each action then covers exactly one requirement and 0 or more <code>me_requirements</code> that make sure none of the neighbors receive the same color.</p> <p>Knowing how to approach this hypothetical puzzle should put you on a path to solving Optimized coloring. If you are stuck and want further guidance, click below.</p> Spoiler Alert: Transitioning from the hypothetical puzzle to the actual puzzle. <p>The thought exercise above asked you to position Algorithm X to find all solutions to a hypothetical problem using 5 distinct colors. What if the solver returns zero solutions? There are no proper ways to color the entire picture with only 5 colors. If you really need to get this picture colored, what should you try next?</p> Spoiler Alert: Quit being so cryptic. Just tell me what to do! <p>I really thought about providing more details, but I believe the hypothetical problem and the questions above are enough of a push in the right direction. Good luck!</p> <p></p>"},{"location":"08-your-turn/05-einstein-riddle/","title":"Einstein's Riddle Solver","text":"<p>Puzzle: Einstein's Riddle Solver</p> <p>Author: @OroshiX</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: A Subtle Shift In Perspective Can Make Life a Lot Easier</p>"},{"location":"08-your-turn/05-einstein-riddle/#strategy","title":"Strategy","text":"<p>Einstein\u2019s Riddle Solver lends itself perfectly to the tiles on a gameboard analogy. Even the problem statement directs you to\u2026</p> <p>solve the riddle and print it as a grid, separated by space and newline, with each person in their own column and each characteristic category on its own line.</p> <p>And what are the tiles? They are the characteristics, of course. Your job is to place all the tiles on the grid. I am sure that sounds familiar.</p> <p>In Sudoku, some cells are prefilled and I suggested handling that by limiting the actions available for those cells to a single action, putting the correct number tile on each prefilled grid position. This puzzle has essentially prefilled the entire first row:</p> <p>The characteristics in the first line will be ordered alphabetically\u2026</p> <p>You can choose to put any characteristic in any column, as long as you obey the rules. The examples given in the problem statement are:</p> <ol> <li> <p>Georges &amp; Salad which means Georges eats Salad</p> </li> <li> <p>Georges ! Salad which means Georges doesn't eat Salad.</p> </li> </ol> <p>Number 2 is very clear. You cannot put salad in the same column as Georges! Sounds like mutual exclusivity, right? But what about number 1? How can we handle actions that must happen together?</p> <p>Assume I have a set of options: <code>{a, b, c, d, e}</code> and it is given that <code>a</code> and <code>c</code> are tightly bound to each other. I have to choose two options from the set, but if I choose <code>a</code>, I must also choose <code>c</code> or if I first choose <code>c</code>, I must also choose <code>a</code>. Any combination of <code>b</code>, <code>d</code> and <code>e</code> would be fine. In this playground, we have only covered mutual exclusivity, never inclusivity. Is there a way we can handle this situation with what we already know? There sure is!</p> <p>If <code>a</code> and <code>c</code> must be chosen together, I could shift my perspective and say:</p> <ul> <li><code>a</code> must not be chosen with <code>b</code></li> <li><code>a</code> must not be chosen with <code>d</code></li> <li><code>a</code> must not be chosen with <code>e</code></li> <li><code>c</code> must not be chosen with <code>b</code></li> <li><code>c</code> must not be chosen with <code>d</code></li> <li><code>c</code> must not be chosen with <code>e</code></li> </ul> <p>The only options left are to choose both <code>a</code> and <code>c</code> or to choose some combination of  <code>b</code>, <code>d</code> and <code>e</code>.</p> <p>If Georges must have Salad, you can accomplish that by making sure Georges cannot have any of the other food options and Salad cannot go with anybody except Georges. Later in the playground, I will discuss another technique, but changing the tightly bound requirements to a set of mutually exclusive requirements is an easy and often effective solution that works wonderfully on Einstein's various riddles.</p> <p></p>"},{"location":"08-your-turn/06-winamax/","title":"Winamax Sponsored Contest","text":"<p>Puzzle: Winamax Sponsored Contest</p> <p>Difficulty: Hard</p> <p>Algorithm X Complexity: Requirements are Straightforward, Actions are Not (You May Need Aspirin)</p>"},{"location":"08-your-turn/06-winamax/#big-payoff","title":"Big Payoff","text":"<p>250 XP! Need I say more? Puzzles on CodinGame that offer unusually high XP are always popular. This puzzle is so creative, I am not sure it even needs the high XP.</p>"},{"location":"08-your-turn/06-winamax/#visualizing-the-problem","title":"Visualizing the Problem","text":"<p>Let\u2019s start with a quote from the problem statement:</p> <p>In this puzzle, you are given a grid representing a golf course. On each course is a certain amount of balls and an equal amount of holes. The objective is to find the route for each ball to a different hole without their paths ever crossing.</p> <p>Using the analogy of laying tiles on a grid, it seems pretty obvious the grid is the map of the golf course given in the input. Per the statement above, the grid will indicate where the holes are and where the balls are. Later in the problem statement, we are told the grid also identifies water hazards and open fairway spaces.</p> <p>What are the tiles we can lay down on the grid? It might be tempting to consider each individual ball movement a tile, but that is like considering each cell in a Shikaku rectangle a separate tile. In Shikaku, Algorithm X needed a full list of possible rectangles and each one of those rectangles, possibly covering many grid cells, is a tile that can be placed on the grid. Let\u2019s again look to the problem statement for a hint:</p> <p>The objective is to find the route for each ball to a different hole without their paths ever crossing. [emphasis added]</p> <p>Each possible route from a ball to a hole is a tile that could be placed on the grid. Given 5 balls and 5 holes and a bunch of possible routes from the balls to the holes, Algorithm X will find a set of routes where each ball goes \u201cto a different hole without their paths ever crossing\u201d.</p>"},{"location":"08-your-turn/06-winamax/#enumerating-the-actions","title":"Enumerating the Actions","text":"<p>I have recommended you use human readable tuples to identify actions for an exact cover problem and the information in those tuples needs to uniquely identify each action from all other actions. What information is needed to uniquely identify a route? Since a route can zig and zag in all kinds of directions, the only way to uniquely identify a route is with a full set of grid coordinates that make up the route. What about short routes vs long routes? This seems like it could be challenging, but there is an easy solution.</p> <p>Let\u2019s say you have 10 possible routes from the first ball to the various holes. Give every route a unique integer ID and include that unique ID in your action specification, possibly something like <code>('select route', bx, by, route id)</code> where bx and by are the ball location. The combination of ball location and route id clearly identifies one route from all other routes. </p> <p>Going back to the tiles on a board analogy, each tile now has a ball location, <code>(bx, by)</code>, and a route number on it, but what does that tile look like? Since we had to generate all the routes and we know all grid coordinates that make up each route, you can visualize each tile as the zigzagging route determined by its coordinates. Algorithm X is going to get a pile of various shaped, sometimes zigzagging, tiles to be placed on the grid, each tile representing one possible route.</p> <p>Of course, you will need a data structure where you store all the cells for each route. When Algorithm X tells you route 15 for the ball at <code>(3, 4)</code> is part of the solution, you will need to know how to display that route in your output.</p> <p>To be honest, generating an exhaustive list of routes in this puzzle is harder than setting up Algorithm X.</p>"},{"location":"08-your-turn/06-winamax/#identifying-requirements","title":"Identifying Requirements","text":"<p>The Winamax problem statement is very well written. From the problem statement excerpt above we know all ball locations must be covered and all hole locations must be covered. What about the requirement that paths never cross? Since any two paths would cross at a single point on the grid, it sounds like any point on the grid that is not a ball or a hole does not need to be covered by any route, but if it is covered, it can only be covered once. That is a pretty straightforward optional requirement.</p> <p>What about the requirement that a \"ball [...] cannot stop in a water hazard.\"? Is that something Algorithm X needs to know about? No, it is not. This requirement is part of your algorithm that generates all possible routes from balls to holes. A route is not legitimate if any section of that route lands in a water hazard. By the time these routes get to Algorithm X, they need to be proper routes.</p>"},{"location":"08-your-turn/06-winamax/#putting-it-all-together","title":"Putting It All Together","text":"<p>Winamax is a great fit for Algorithm X. Once you separate the process of identifying routes and the process of finding a set of routes that exactly matches up the balls to the holes, the problem becomes much more manageable than it might have seemed at first. You still need to carefully identify every requirement covered by each route, but when you do, Algorithm X will quickly return a solution.</p> <p></p>"},{"location":"08-your-turn/07-three-little-piggies/","title":"Three Little Piggies","text":"<p>Puzzle: Three Little Piggies</p> <p>Author: @nicola</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Pigs In Houses? Day? Night? Lots of Options Create Complexity</p>"},{"location":"08-your-turn/07-three-little-piggies/#strategy","title":"Strategy","text":"<p>Three Little Piggies is likely to get you going in circles and wondering why you seem to be right back where you started. The situation is different at night than during the day. Houses can be rotated any number of times. This probably doesn\u2019t help, but the key to success is to keep it simple.</p>"},{"location":"08-your-turn/07-three-little-piggies/#requirements","title":"Requirements","text":"<p>The three main requirements of the puzzle are that each of the three houses be placed on the gameboard. If it is nighttime, it is also required that all pig locations on the gameboard be covered. Additionally, all <code>X</code> locations on the gameboard may be covered by a house, but if they are covered by a house, they can only be covered by one house. Easy enough right? The actions are not quite so straightforward.</p>"},{"location":"08-your-turn/07-three-little-piggies/#enumerating-the-actions","title":"Enumerating the Actions","text":"<p>It is time to once again use what you learned in Shikaku Skill Builder. Unfortunately, building an exhaustive list of locations you could place each house is no easy task. Here are the key issues you need to work around:</p> <ul> <li> <p>A house cannot cover any tree location on the gameboard.</p> </li> <li> <p>If it is daytime, a house cannot cover a pig location.</p> </li> <li> <p>If it is nighttime:</p> <ul> <li> <p>A house cannot cover the wolf\u2019s location</p> </li> <li> <p>Each pig location must be covered by a house and the pig must be in the proper location of the house.</p> </li> </ul> </li> </ul> <p>Setting Algorithm X up for success comes down to generating an exhaustive list of every possible location a house could be placed on the gameboard in such a way that all rules are obeyed. Of course, that includes all rotations of the house. </p> <p>This puzzle is another great fit for Algorithm X, but setting up the matrix will take some time and a lot of attention to detail.</p>"},{"location":"08-your-turn/07-three-little-piggies/#rotating-a-2-dimensional-array","title":"Rotating a 2-Dimensional Array","text":"<p>I first learned how to rotate a 2-dimensional array by looking at another CodinGamer\u2019s code on another puzzle. I can\u2019t say enough about what can be learned by looking at other solutions after submitting your own. Let\u2019s look at rotating the brick house.</p> <pre><code># store the brick house as a 2-dimensional array\nhouse = [['H', 'B', 'B'], [' ', ' ', 'B']]\n\n# print the house and rotate it 4 times\nfor i in range(4):\n    print(f'Rotation: {i}')\n    for line in house:\n        print(*line, sep='')\n    print()\n\n    # rotate the house 90 degrees to the right\n    house = list(zip(*house))\n    house = [line[::-1] for line in house]\n</code></pre> <p>Keep in mind the brick house does not have equal height and width, and each time the house rotates, the height and width of the house change. You will need to be aware of that when you look to see if the house will fit on the grid.</p> <p>Have you played around with Numpy Arrays? Many puzzles that involve 2-dimensional grids are great places to experiment with Numpy and learn how to use Arrays. This next code block rotates the brick house 4 times just like the code block above, but using Numpy.</p> <pre><code>import numpy as np\n\n# store the brick house as a 2-dimensional numpy array\nhouse = np.array([['H', 'B', 'B'], [' ', ' ', 'B']])\n\n# print the house and rotate it 4 times\nfor i in range(4):\n    print(f'Rotation: {i}')\n    for line in house:\n        print(*line, sep='')\n    print()\n\n    # rotate the house 90 degrees to the left\n    house = np.rot90(house)\n</code></pre> <p></p>"},{"location":"08-your-turn/08-breaking-bifid/","title":"Breaking Bifid","text":"<p>Puzzle: Breaking Bifid</p> <p>Author: @therealbeef</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Imagine Untangling the World's Largest Pile of Holiday Lights</p>"},{"location":"08-your-turn/08-breaking-bifid/#puzzle-overview","title":"Puzzle Overview","text":"<p>In Breaking Bifid, you are given a <code>plainText1</code> string and a <code>cipherText1</code> string. You need to figure out the makeup of the key, the Polybius square, used to encrypt <code>plainText1</code>. Once you have the key (a completed square) you can decode a third string, <code>cipherText2</code>. Before we explore how to look at this problem as an exact cover, let\u2019s first review the process laid out in the goal statement.</p> <p>Bifid uses a Polybius square as a key. This is a 5 by 5 square containing 25 letters of the alphabet (the J is merged with I), in an arbitrary order. For example:</p> <p></p> <p>To encrypt a plaintext, we start by removing spaces and replacing each J by an I. Underneath each letter in the resulting text we write the coordinates (row and column) of that letter in the Polybius square:</p> <p></p> <p>The two lines of numbers are written after each other:</p> <p></p> <p>The numbers are then grouped in pairs, and the pairs are used as coordinates into the Polybius square (the first number being the row, and second being the column), to find the letters of the ciphertext:</p> <p></p>"},{"location":"08-your-turn/08-breaking-bifid/#looking-at-the-puzzle-as-an-exact-cover","title":"Looking at the Puzzle as an Exact Cover","text":"<p>Let\u2019s now consider an example similar in structure to the test cases and try to identify actions and requirements for Algorithm X in hopes that Algorithm X can identify how the Polybius square should be constructed. In the next diagram, I have short 3-letter strings for <code>plainText1</code> and <code>cipherText1</code>, but the entire Polybius square is completely blank.</p> <p></p> <p>The action steps I can take to build a solution are pretty simple. One at a time, a letter of the alphabet (J is excluded) can be placed in one of the 25 squares. As for requirements, the only obvious requirements are that every letter be used and every square be covered. That is not super helpful because a tremendous number of possible combinations satisfy those requirements. Let's work through the process laid out by the author once again, this time taking into account we don't know the letters in the key.</p> <p>To encrypt a plaintext, we start by removing spaces and replacing each J by an I. Underneath each letter in the resulting text we write the coordinates (row and column) of that letter in the Polybius square:</p> <p>Each letter's coordinates are unknown so I will add subscripts to refer to the rows and columns of the letters.</p> <p></p> <p>The two lines of numbers are written after each other:</p> <p></p> <p>The numbers are then grouped in pairs, and the pairs are used as coordinates into the Polybius square (the first number being the row, and second being the column), to find the letters of the ciphertext:</p> <p></p> <p>At the risk of being repetitive, I will quote the author's problem statement one last time:</p> <p>the pairs are used as coordinates into the Polybius square (the first number being the row, and second being the column), to find the letters of the ciphertext:</p> <p>The first pair, (row of A, row of N), tells us where to look in the Polybius square to find the first ciphertext letter, S. From that, we know:</p> <p></p> <p>We finally have some requirements more interesting than a letter needing to be put on the grid. We know that A and S must be in the same row! These two things must be the same, or in other words...they must not be different. Hopefully you did Einstein's Riddle Solver and you remember how to turn items that must be the same into a set of mutually exclusive items. If not, it might be time to go back and finish that puzzle first! </p> <p></p>"},{"location":"08-your-turn/09-futoshiki-solver/","title":"Futoshiki Solver","text":"<p>Puzzle: Futoshiki Solver</p> <p>Author: @Sundiver</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Great Confidence Builder</p>"},{"location":"08-your-turn/09-futoshiki-solver/#a-special-latin-square","title":"A Special Latin Square","text":"<p>Parsing and organizing input for this puzzle is plenty challenging on its own. Fortunately, once the input is understood, the puzzle starts to look very familiar. Both the puzzle goal and Wikipedia confirm a Futoshiki has a lot in common with Sudoku and other Latin Square puzzles.</p> <p>From the puzzle goal:</p> <p>Futoshiki is a Japanese numeric logic puzzle similar to the more popular Sudoku.</p> <p>From Wikipedia:</p> <p>A solved Futoshiki puzzle is a Latin Square.</p> <p>I will skip going over the requirements and actions since they have been covered in detail already, but the inequalities add an important twist.</p>"},{"location":"08-your-turn/09-futoshiki-solver/#inequalities","title":"Inequalities","text":"<p>All inequalities in a Futoshiki can be expressed as <code>a &lt; b</code> where <code>a</code> and <code>b</code> are the values in two cells that share a horizontal or vertical border. Given a 6x6 Futoshiki with no hints, we know that every cell is a number between 1 and 6.</p> <pre><code>Possible values for a = 1, 2, 3, 4, 5, 6\nPossible values for b = 1, 2, 3, 4, 5, 6\n</code></pre> <p>?[What is wrong with the above statements? Select all that apply] -[] Nothing is wrong. In the absence of hints, either cell could take any of those values. -[x] b cannot be 1 since there are no values for a that allow a &lt; b to be true.  -[] a must be 1 and b must be 2 because a &lt; b. -[x] a cannot be 6 since there are no values for b that allow a &lt; b to be true. </p> <p>Very interesting! What if <code>b</code> already had a value in the box? That would make it easy to reduce the possible values for <code>a</code>.</p> <p>Ultimately, an inequality identifies what must be true, and from that, it is easy to determine what cannot happen. If <code>a</code> &lt; <code>b</code>, then making <code>a = 3</code> and <code>b = 2</code> is not allowed. </p> <p>?[How do we tell Algorithm X certain things are not allowed?] -[] Send an email. -[] Post a message in the CodinGame Forum.  -[x] Create requirements to handle mutual exclusivity. -[] Call a special AlgorithmXSolver method. -[] Ask @5DN1L to reach out to CodinGame directly.</p> <p>It looks like you will need some requirements to handle the mutual exclusivity created by each inequality.</p>"},{"location":"08-your-turn/09-futoshiki-solver/#your-goal","title":"Your Goal","text":"<p>All test cases except Test Case 5: 7x7 can be solved with nothing more than requirements, actions and optional requirements. To solve Test Case 5: 7x7, you might need a very small amount of problem-space reduction. I have already discussed one option using the inequalities to limit the realm of possibility for the cells on either side. Later in the playground, I will discuss other techniques for problem-space reduction.</p> <p></p>"},{"location":"08-your-turn/10-suguru-solver/","title":"Suguru Solver","text":"<p>Puzzle: Suguru Solver</p> <p>Author: @Saur2000</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Sudoku Times Two</p>"},{"location":"08-your-turn/10-suguru-solver/#strategy","title":"Strategy","text":"<p>From the puzzle description:</p> <p>Suguru (also known as Tectonics) is a puzzle game similar to Sudoku.</p> <p>I am sure you have heard, \u201cThe devil is in the details.\u201d Suguru is somewhat similar to Sudoku, but the differences are just enough to make it a surprising challenge. There are no rows, columns or boxes. Instead cells are grouped into cages, which are extremely similar to the various groups in Sudoku. There is just one key difference. Every box, column and row in Sudoku has the same number of cells. In Suguru, every cage can be a different size with between 1 and 6 cells.</p> <p>Because cages can contain different numbers of cells, the possible values for any cell is determined by the size of the cage. This is a significant change from Sudoku where every cell had the exact same possible values.</p> <p>Again from the puzzle description:</p> <p>Adjacent cells, even diagonally, may never contain the same digit.</p> <p>The second significant difference in Suguru is the puzzle requirement to make sure neighbor cells, even diagonally, never have the same value. If a <code>1</code> is placed in a certain cell, there are between 3 and 8 neighbor cells that must not be covered with a <code>1</code>. That sounds like a tremendous amount of mutual exclusivity.</p> <p>Parsing the grid and setting up Algorithm X will take more effort than Sudoku required, but all test cases and validators can be passed, well within the time limit, with just what you know from the Mrs. Knuth puzzles and the earlier section on Sudoku. Later in the playground, I will revisit Suguru and discuss a few ideas you might use to make your solver significantly faster.</p> <p></p>"},{"location":"09-multiplicity/01-multiplicity/","title":"Multiplicity","text":"<p>Mrs. Knuth is moving up the ladder at school and she is once again requesting changes. The details are found here:</p> <p>Mrs. Knuth - Part III</p> <p>There seems to be a lot of new information in the puzzle, but only this key paragraph affects our Algorithm X approach:</p> <p>Mrs. Knuth has received some wonderful news! This summer, she will only be working with a handful of honor students. Although she'll have fewer students, each student is now allowed to request multiple hours of instruction per week. This creates a situation where many potential schedules exist. Based on her preferences, Mrs. Knuth needs you to find the best schedule possible.</p> <p>Let's jump right into the example:</p> <pre><code>M 8 Tu 8 W 8 Th 8 F 8 9 10 11 1\n3\nDrew Trombone 1 M Tu W Th F 10 11\nElla Flute 2 M 8 Tu 8 W Th F 11\nLola Drums 1 M Tu W Th F 11 1\n1\nDrew Ella\n</code></pre> <p>Ella wants two lessons! How can such a minor change make such an impact on our existing model? Using what we learned in the previous two Mrs. Knuth puzzles, we would identify the following three requirements:</p> <pre><code>('student scheduled', 'Drew')\n('student scheduled', 'Ella')\n('student scheduled', 'Lola')\n</code></pre> <p>Until now, requirements needed to be covered exactly once, but now the Ella requirement needs to be covered twice and in future test cases, students are requesting even more than 2 hours of instruction. This list of requirements is no longer sufficient. Remember, requirements should fit a \"yes/no\" model when we determine what has been covered and what has not. With the above, we can tell if Ella has been scheduled or not, but we cannot tell if she has been scheduled once or twice. This list of requirements is not enough to capture the full scope of the problem.</p> <p>In The Art of Computer Programming, Donald Knuth discusses Algorithm M for handling problems with requirements/constraints that might need to be covered multiple times and I suggest you add learning about Algorithm M to your to-do list. However, this playground is an Algorithm X tutorial and an overarching goal is to explore how much can be accomplished with a single out-of-the-box <code>AlgorithmXSolver</code>!</p> <p></p>"},{"location":"09-multiplicity/02-multiplicity-with-algorithm-x/","title":"Requirements Need More Precision","text":"<p>Let's take another look at the example problem:</p> <pre><code>M 8 Tu 8 W 8 Th 8 F 8 9 10 11 1\n3\nDrew Trombone 1 M Tu W Th F 10 11\nElla Flute 2 M 8 Tu 8 W Th F 11\nLola Drums 1 M Tu W Th F 11 1\n1\nDrew Ella\n</code></pre> <p>Requirements must be binary in Algorithm X. Either they have been covered or they have not been covered. It is important to make sure there is no middle ground, such as Ella being scheduled is \"half-way covered\" because 1 of her 2 lessons has been scheduled and the other still needs to be scheduled.</p> <p>As problems get more complex, it is often helpful to quickly identify the steps that need to be taken to solve a simple or \u201ctoy\u201d version of the problem and the example test case works perfectly. What needs to happen to build a solution?</p> <ol> <li> <p>Drew\u2019s one lesson must be scheduled.</p> </li> <li> <p>Lola\u2019s one lesson must be scheduled.</p> </li> <li> <p>Ella\u2019s first lesson must be scheduled.</p> </li> <li> <p>Ella\u2019s second lesson must be scheduled.</p> </li> </ol> <p>We now see four requirements are needed to make sure these three students are properly scheduled. More precisely, a requirement specification now needs more than just a name. It also needs to identify which lesson has been scheduled. Is it the student\u2019s first lesson? Second lesson? Third lesson? Let\u2019s add <code>lesson number</code> to each requirement specification.</p> <pre><code>('student scheduled', 'Drew', 1)\n('student scheduled', 'Lola', 1)\n('student scheduled', 'Ella', 1)\n('student scheduled', 'Ella', 2)\n</code></pre> <p>This is a much more complete set of requirements. Four requirements must be covered, resulting in four lessons being scheduled, one for Drew, one for Lola and two for Ella.</p>"},{"location":"09-multiplicity/02-multiplicity-with-algorithm-x/#actions-need-more-precision","title":"Actions Need More Precision","text":"<p>Looking at each student\u2019s availability, we initially come up with this list of possible actions:</p> <pre><code>('place student', 'Drew', 'Trombone', 'F', 10)\n('place student', 'Drew', 'Trombone', 'F', 11)\n('place student', 'Ella', 'Flute', 'M', 8)\n('place student', 'Ella', 'Flute', 'Tu', 8)\n('place student', 'Ella', 'Flute', 'F', 11)\n('place student', 'Lola', 'Drums', 'F', 11)\n('place student', 'Lola', 'Drums', 'F', 1)\n</code></pre> <p>If you think through those actions, you realize the action specification does not have enough information. If we schedule Ella on Friday at 11, are we scheduling her first lesson or her second lesson? It is critical that we schedule both her first and second lesson, but right now, we have no way to distinguish which lesson is being scheduled. We need to add <code>lesson number</code> to the action specification:</p> <pre><code>updated action specification = (\u2018place student\u2019, student name, instrument, day, hour, lesson number)\n</code></pre> <p>Notice below that all actions must adhere to the same specification. Even the students that have only requested a single lesson need to have a <code>1</code> in the action specification for <code>lesson number</code>. You see 3 extra actions have been added for Ella since scheduling her first lesson is distinct from scheduling her second lesson.</p> <pre><code>('place student', 'Drew', 'Trombone', 'F', 10, 1)       # Schedule Drew's FIRST lesson on Friday at 10.\n('place student', 'Drew', 'Trombone', 'F', 11, 1)       # Schedule Drew's FIRST lesson on Friday at 11.\n('place student', 'Ella', 'Flute', 'M', 8, 1)           # Schedule Ella's FIRST lesson on Monday at 8.\n('place student', 'Ella', 'Flute', 'M', 8, 2)           # Schedule Ella's SECOND lesson on Monday at 8.\n('place student', 'Ella', 'Flute', 'Tu', 8, 1)          # Schedule Ella's FIRST lesson on Tuesday at 8.\n('place student', 'Ella', 'Flute', 'Tu', 8, 2)          # Schedule Ella's SECOND lesson on Tuesday at 8.\n('place student', 'Ella', 'Flute', 'F', 11, 1)          # Schedule Ella's FIRST lesson on Friday at 11.\n('place student', 'Ella', 'Flute', 'F', 11, 2)          # Schedule Ella's SECOND lesson on Friday at 11.\n('place student', 'Lola', 'Drums', 'F', 11, 1)          # Schedule Lola's FIRST lesson on Friday at 11.\n('place student', 'Lola', 'Drums', 'F', 1, 1)           # Schedule Lola's FIRST lesson on Friday at 1.\n</code></pre> <p>As we have seen with both the requirements and the actions, multiplicity forces us to be more precise. Next, I'll bring everything together and generate solutions.</p> <p></p>"},{"location":"09-multiplicity/03-generating-solutions/","title":"Generating Solutions for Mrs. Knuth - Part III","text":"<p>Before running Algorithm X, let\u2019s reason our way through the problem statement one more time and determine what we expect to see.</p> <pre><code>M 8 Tu 8 W 8 Th 8 F 8 9 10 11 1\n3\nDrew Trombone 1 M Tu W Th F 10 11\nElla Flute 2 M 8 Tu 8 W Th F 11\nLola Drums 1 M Tu W Th F 11 1\n1\nDrew Ella\n</code></pre> <p>Because Drew and Ella are a troublesome pair and Drew\u2019s only availability is on Friday, there is no way to schedule Ella on Friday. That leaves only Monday at 8 and Tuesday at 8 for Ella. Drew and Lola both play loud instruments, so they cannot be back-to-back. This eliminates the possibility of scheduling Lola on Friday at 11 since Drew\u2019s only remaining availability would be Friday at 10. Lola will have to be scheduled Friday at 1. Finally, Drew could be scheduled on Friday at 10 or 11.</p> <p>In the following code block, I have hard-coded the setup for the example test case. At this point, the schedule options are not scored. I am simply printing all the options returned by Algorithm X. There should be two possible solutions from which we will need to determine the schedule with the best score. Both solutions will have Ella on Monday at 8 and Tuesday at 8, while Lola will be Friday at 1. The only difference between the two options will be Drew\u2019s location, either Friday at 10 or Friday at 11.</p> <p>Copy the code into your coding environment and run it. There is a quiz at the bottom of this page!</p> <pre><code># Unless your coding environment will let you create an AlgorithmX package,\n# you will need to copy all of the AlgorithmXSolver code into your code.\n\nfrom AlgorithmX import AlgorithmXSolver\n\nclass MrsKnuthPartIIISolver(AlgorithmXSolver):\n\n    def __init__(self, teacher_availability, students):\n\n        requirements = [('student scheduled', 'Drew', 1),\n                        ('student scheduled', 'Ella', 1),\n                        ('student scheduled', 'Ella', 2),\n                        ('student scheduled', 'Lola', 1)]\n\n        optional_requirements = [('slot filled', 'M', 8),\n                                 ('slot filled', 'Tu', 8),\n                                 ('slot filled', 'W', 8),\n                                 ('slot filled', 'Th', 8),\n                                 ('slot filled', 'F', 8),\n                                 ('slot filled', 'F', 9),\n                                 ('slot filled', 'F', 10),\n                                 ('slot filled', 'F', 11),\n                                 ('slot filled', 'F', 1),\n                                 ('instrument on day', 'M', 'Trombone'),\n                                 ('instrument on day', 'M', 'Drums'),\n                                 ('instrument on day', 'M', 'Flute'),\n                                 ('instrument on day', 'Tu', 'Trombone'),\n                                 ('instrument on day', 'Tu', 'Drums'),\n                                 ('instrument on day', 'Tu', 'Flute'),\n                                 ('instrument on day', 'W', 'Trombone'),\n                                 ('instrument on day', 'W', 'Drums'),\n                                 ('instrument on day', 'W', 'Flute'),\n                                 ('instrument on day', 'Th', 'Trombone'),\n                                 ('instrument on day', 'Th', 'Drums'),\n                                 ('instrument on day', 'Th', 'Flute'),\n                                 ('instrument on day', 'F', 'Trombone'),\n                                 ('instrument on day', 'F', 'Drums'),\n                                 ('instrument on day', 'F', 'Flute'),\n                                 (('Drew', 'F', 10), ('Ella', 'F', 11)),\n                                 (('loud instrument', 'F', 8), ('loud instrument', 'F', 9)),\n                                 (('loud instrument', 'F', 9), ('loud instrument', 'F', 10)),\n                                 (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        actions = dict()\n\n        action = ('place student', 'Drew', 'Trombone', 'F', 10, 1)\n        actions[action] = [('student scheduled', 'Drew', 1),\n                           ('slot filled', 'F', 10),\n                           ('instrument on day', 'F', 'Trombone'),\n                           (('Drew', 'F', 10), ('Ella', 'F', 11)),\n                           (('loud instrument', 'F', 9), ('loud instrument', 'F', 10)),\n                           (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        action = ('place student', 'Drew', 'Trombone', 'F', 11, 1)\n        actions[action] = [('student scheduled', 'Drew', 1),\n                           ('slot filled', 'F', 11),\n                           ('instrument on day', 'F', 'Trombone'),\n                           (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        action = ('place student', 'Ella', 'Flute', 'M', 8, 1)\n        actions[action] = [('student scheduled', 'Ella', 1),\n                           ('slot filled', 'M', 8),\n                           ('instrument on day', 'M', 'Flute')]\n\n        action = ('place student', 'Ella', 'Flute', 'M', 8, 2)\n        actions[action] = [('student scheduled', 'Ella', 2),\n                           ('slot filled', 'M', 8),\n                           ('instrument on day', 'M', 'Flute')]\n\n        action = ('place student', 'Ella', 'Flute', 'Tu', 8, 1)\n        actions[action] = [('student scheduled', 'Ella', 1),\n                           ('slot filled', 'Tu', 8),\n                           ('instrument on day', 'Tu', 'Flute')]\n\n        action = ('place student', 'Ella', 'Flute', 'Tu', 8, 2)\n        actions[action] = [('student scheduled', 'Ella', 2),\n                           ('slot filled', 'Tu', 8),\n                           ('instrument on day', 'Tu', 'Flute')]\n\n        action = ('place student', 'Ella', 'Flute', 'F', 11, 1)\n        actions[action] = [('student scheduled', 'Ella', 1),\n                           ('slot filled', 'F', 11),\n                           ('instrument on day', 'F', 'Flute'),\n                           (('Drew', 'F', 10), ('Ella', 'F', 11))]\n\n        action = ('place student', 'Ella', 'Flute', 'F', 11, 2)\n        actions[action] = [('student scheduled', 'Ella', 2),\n                           ('slot filled', 'F', 11),\n                           ('instrument on day', 'F', 'Flute'),\n                           (('Drew', 'F', 10), ('Ella', 'F', 11))]\n\n        action = ('place student', 'Lola', 'Drums', 'F', 11, 1)\n        actions[action] = [('student scheduled', 'Lola', 1),\n                           ('slot filled', 'F', 11),\n                           ('instrument on day', 'F', 'Drums'),\n                           (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        action = ('place student', 'Lola', 'Drums', 'F', 1, 1)\n        actions[action] = [('student scheduled', 'Lola', 1),\n                           ('slot filled', 'F', 1),\n                           ('instrument on day', 'F', 'Drums')]\n\n        super().__init__(requirements, actions, optional_requirements)\n\n\ndef main_program():\n\n    teacher_availability = None\n    students = None\n\n    solver = MrsKnuthPartIIISolver(teacher_availability, students)\n\n    count = 0\n    for solution in solver.solve():\n        count += 1\n        print(f'Solution {count}')\n        for _, name, instrument, day, hour, lesson_num in solution:\n            print(f'   Add {name}/{instrument} to Mrs. Knuth\\'s schedule on {day} at {hour}.')\n</code></pre>"},{"location":"09-multiplicity/03-generating-solutions/#a-bit-about-the-code","title":"A Bit About the Code","text":"<p>I want you to know it is way harder to hard-code all those requirements and actions than it is to build them algorithmically with loops. I had to fix 20 or more typos before it worked properly; proof that algorithms are much more precise than us humans!</p> <p>Does it make sense where all the requirements come from? <code>'instrument on day'</code> requirements had to be added for every day of the week because Mrs. Knuth has availability on all 5 days. There are also a bunch more <code>'slot filled'</code> requirements.</p> <p>Understanding the multiplicity can be challenging. Keep in mind that scheduling a student's first lesson is a different action than scheduling a student's second lesson. That is why Ella now has 6 entries in the actions dictionary even though she only has 3 hours of availability.</p>"},{"location":"09-multiplicity/03-generating-solutions/#quiz-time","title":"Quiz Time!","text":"<p>How many solutions did Algorithm X find?</p> Show answer <p>The correct answer is 4. In the next two sections, I will dig deeper into what is happening and discuss how to teach Algorithm X to do better.</p> <p></p>"},{"location":"09-multiplicity/04-the-challenge/","title":"Duplicate Solutions","text":"<p>Here is the output from the previous code block:</p> <pre><code>Solution 1\n   Add Drew/Trombone to Mrs. Knuth's schedule on F at 10.\n   Add Lola/Drums to Mrs. Knuth's schedule on F at 1.\n   Add Ella/Flute to Mrs. Knuth's schedule on M at 8.\n   Add Ella/Flute to Mrs. Knuth's schedule on Tu at 8.\nSolution 2\n   Add Drew/Trombone to Mrs. Knuth's schedule on F at 10.\n   Add Lola/Drums to Mrs. Knuth's schedule on F at 1.\n   Add Ella/Flute to Mrs. Knuth's schedule on Tu at 8.\n   Add Ella/Flute to Mrs. Knuth's schedule on M at 8.\nSolution 3\n   Add Drew/Trombone to Mrs. Knuth's schedule on F at 11.\n   Add Lola/Drums to Mrs. Knuth's schedule on F at 1.\n   Add Ella/Flute to Mrs. Knuth's schedule on M at 8.\n   Add Ella/Flute to Mrs. Knuth's schedule on Tu at 8.\nSolution 4\n   Add Drew/Trombone to Mrs. Knuth's schedule on F at 11.\n   Add Lola/Drums to Mrs. Knuth's schedule on F at 1.\n   Add Ella/Flute to Mrs. Knuth's schedule on Tu at 8.\n   Add Ella/Flute to Mrs. Knuth's schedule on M at 8.\n</code></pre> <p>What is going on? Solution 1 and solution 2 are perfect duplicates. The same is true for solution 3 and solution 4. To get to the bottom of things, I will regenerate the output, but this time, I will include the <code>lesson_number</code> included in each action tuple.</p> <pre><code>Solution 1\n   Add Drew/Trombone to Mrs. Knuth's schedule on F at 10. This is Drew's first lesson.\n   Add Lola/Drums to Mrs. Knuth's schedule on F at 1. This is Lola's first lesson.\n   Add Ella/Flute to Mrs. Knuth's schedule on M at 8. This is Ella's first lesson.\n   Add Ella/Flute to Mrs. Knuth's schedule on Tu at 8. This is Ella's second lesson.\nSolution 2\n   Add Drew/Trombone to Mrs. Knuth's schedule on F at 10. This is Drew's first lesson.\n   Add Lola/Drums to Mrs. Knuth's schedule on F at 1. This is Lola's first lesson.\n   Add Ella/Flute to Mrs. Knuth's schedule on Tu at 8. This is Ella's first lesson.\n   Add Ella/Flute to Mrs. Knuth's schedule on M at 8. This is Ella's second lesson.\nSolution 3\n   Add Drew/Trombone to Mrs. Knuth's schedule on F at 11. This is Drew's first lesson.\n   Add Lola/Drums to Mrs. Knuth's schedule on F at 1. This is Lola's first lesson.\n   Add Ella/Flute to Mrs. Knuth's schedule on M at 8. This is Ella's first lesson.\n   Add Ella/Flute to Mrs. Knuth's schedule on Tu at 8. This is Ella's second lesson.\nSolution 4\n   Add Drew/Trombone to Mrs. Knuth's schedule on F at 11. This is Drew's first lesson.\n   Add Lola/Drums to Mrs. Knuth's schedule on F at 1. This is Lola's first lesson.\n   Add Ella/Flute to Mrs. Knuth's schedule on Tu at 8. This is Ella's first lesson.\n   Add Ella/Flute to Mrs. Knuth's schedule on M at 8. This is Ella's second lesson.\n</code></pre> <p>Do you see the problem? Algorithm X considers solution 1 and solution 2 to be different because for solution 1, Ella is doing her first lesson on Monday while in solution 2, Ella is doing her second lesson on Monday. We created this problem when we told Algorithm X that scheduling Ella\u2019s first lesson is distinct from scheduling her second lesson.</p> <p>Fortunately, there is an easy fix!</p> <p></p>"},{"location":"09-multiplicity/05-memory/","title":"Making Algorithm X Smarter About Duplicates","text":"<p>Algorithm X doesn't know that trying Ella's first lesson on Monday at 8 is exactly the same as trying Ella's second lesson on Monday at 8. Remember, Algorithm X is a backtracking algorithm and backtracking involves trying all possibilities, one-by-one. Whenever a dead-end is found (or a solution is found), the algorithm backtracks and tries the next option. In our example, trying Ella\u2019s first lesson on Monday at 8 and trying Ella\u2019s second lesson on Monday at 8 are both options.</p> <p>The solution is to use <code>AlgorithmXSolver</code>\u2019s built-in memory. We need Algorithm X to remember that it already tried Ella on Monday at 8. In our case, it worked, but even if it didn\u2019t work, we want Algorithm X to make sure it never again tries Ella on Monday at 8.</p> <p>I used the word \u201cnever\u201d and that is a tiny bit misleading. The Algorithm X memory mirrors the process of recursive backtracking. Each level deeper in the recursion adds a new compartment to the memory. Each time Algorithm X backtracks, the most recent compartment is discarded. The closer you get to the root of the recursion, the smaller the size of memory. The deeper Algorithm X goes into the recursion looking for solutions, the more built-up memory it needs to check.</p>"},{"location":"09-multiplicity/05-memory/#enough-already-just-show-me-how-to-fix-it","title":"Enough Already, Just Show Me How to Fix It!","text":"<p><code>AlgorithmXSolver</code> has a method called <code>_process_row_selection(self, row)</code>. Your <code>AlgorithmXSolver</code> subclass needs to override this method and direct Algorithm X to \u201cremember\u201d the important details it needs to avoid creating duplicates. In our example problem, each time Algorithm X tries adding a row of the matrix to the solution, we want Algorithm X to remember the <code>(name, day, hour)</code> so that it knows not to try this same combination again at this level of the recursion. It is as simple as this:</p> <pre><code>    def _process_row_selection(self, row):\n        _, name, instrument, day, hour, lesson_num = row\n        self._remember((name, day, hour))\n</code></pre> <p>That really is all there is to it. If Algorithm X encounters a <code>(name, day, hour)</code> combination that it already has in memory, it will move along to the next option. Of course, because <code>instrument</code> and <code>lesson_num</code> are not used, it is more common to see the unpacking done like this:</p> <pre><code>    def _process_row_selection(self, row):\n        _, name, _, day, hour, _ = row\n        self._remember((name, day, hour))\n</code></pre>"},{"location":"09-multiplicity/05-memory/#how-important-is-this","title":"How Important is This?","text":"<p>What if Ella wanted 3 lessons? What if each of the students wanted 2 lessons? The more multiplicity in the problem, the more crazy things can get. In Mrs. Knuth - Part III, all valid solutions need to be found and scored to determine the best schedule for Mrs. Knuth. The following table shows you how many distinct solutions need to be scored for each test case and how many solutions are generated by Algorithm X if multiplicity is not properly handled. I have only included the test cases where multiplicity creates a problem.</p> Test Case Distinct Solutions Solutions Found if Duplicates Not Avoided 1 - 2 Lessons Per Week for Ella 2 4 2 - 3 Lessons Per Week for Ella 2 12 3 - 4 Lessons Per Week for Ella 2 48 4 - Morning is Better 8 192 10 - Meh 66 792 11 - Almost Perfect Schedule 863 3,452 12 - Emma, We Need to Chat 413 9,912 13 - 4-Day Weekends! 3,425 41,100 14 - 3-Day Weekends! 2,755 88,160 15 - Let's Rethink This Ivy 2,601 124,848 16 - 5 Days of Drums\u2026Ugh! 1,546 148,416 17 - Monday at 8am\u2026Really? 1,862 178,752 18 - So Many Options 12,561 200,976 19 - Here Comes the Weekend 2,517 241,632 20 - Hump Day! 8,297 265,504 <p>As you can see, the numbers can get pretty significant. To finish Mrs. Knuth - Part III, you will need to properly account for multiplicity in your requirements and your actions. For the latter test cases, you will need to account for duplicate solutions if you hope to finish before timing out. In the next section, I will add memory to the solver and make sure only the 2 expected solutions are generated.</p> <p></p>"},{"location":"09-multiplicity/06-solution-with-memory/","title":"Using Memory to Make Algorithm X Smarter","text":"<p>The following code block is identical to the last code block except for 3 lines added to override the <code>_process_row_selection(self, row)</code> method and give Algorithm X the necessary memory to avoid duplicates. Copy this code into your coding environment and run it to see Algorithm X eliminate the duplicates!</p> <pre><code># Unless your coding environment will let you create an AlgorithmX package,\n# you will need to copy all of the AlgorithmXSolver code into your code.\n\nfrom AlgorithmX import AlgorithmXSolver\n\nclass MrsKnuthPartIIISolver(AlgorithmXSolver):\n\n    def __init__(self, teacher_availability, students):\n\n        requirements = [('student scheduled', 'Drew', 1),\n                        ('student scheduled', 'Ella', 1),\n                        ('student scheduled', 'Ella', 2),\n                        ('student scheduled', 'Lola', 1)]\n\n        optional_requirements = [('slot filled', 'M', 8),\n                                 ('slot filled', 'Tu', 8),\n                                 ('slot filled', 'W', 8),\n                                 ('slot filled', 'Th', 8),\n                                 ('slot filled', 'F', 8),\n                                 ('slot filled', 'F', 9),\n                                 ('slot filled', 'F', 10),\n                                 ('slot filled', 'F', 11),\n                                 ('slot filled', 'F', 1),\n                                 ('instrument on day', 'M', 'Trombone'),\n                                 ('instrument on day', 'M', 'Drums'),\n                                 ('instrument on day', 'M', 'Flute'),\n                                 ('instrument on day', 'Tu', 'Trombone'),\n                                 ('instrument on day', 'Tu', 'Drums'),\n                                 ('instrument on day', 'Tu', 'Flute'),\n                                 ('instrument on day', 'W', 'Trombone'),\n                                 ('instrument on day', 'W', 'Drums'),\n                                 ('instrument on day', 'W', 'Flute'),\n                                 ('instrument on day', 'Th', 'Trombone'),\n                                 ('instrument on day', 'Th', 'Drums'),\n                                 ('instrument on day', 'Th', 'Flute'),\n                                 ('instrument on day', 'F', 'Trombone'),\n                                 ('instrument on day', 'F', 'Drums'),\n                                 ('instrument on day', 'F', 'Flute'),\n                                 (('Drew', 'F', 10), ('Ella', 'F', 11)),\n                                 (('loud instrument', 'F', 8), ('loud instrument', 'F', 9)),\n                                 (('loud instrument', 'F', 9), ('loud instrument', 'F', 10)),\n                                 (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        actions = dict()\n\n        action = ('place student', 'Drew', 'Trombone', 'F', 10, 1)\n        actions[action] = [('student scheduled', 'Drew', 1),\n                           ('slot filled', 'F', 10),\n                           ('instrument on day', 'F', 'Trombone'),\n                           (('Drew', 'F', 10), ('Ella', 'F', 11)),\n                           (('loud instrument', 'F', 9), ('loud instrument', 'F', 10)),\n                           (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        action = ('place student', 'Drew', 'Trombone', 'F', 11, 1)\n        actions[action] = [('student scheduled', 'Drew', 1),\n                           ('slot filled', 'F', 11),\n                           ('instrument on day', 'F', 'Trombone'),\n                           (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        action = ('place student', 'Ella', 'Flute', 'M', 8, 1)\n        actions[action] = [('student scheduled', 'Ella', 1),\n                           ('slot filled', 'M', 8),\n                           ('instrument on day', 'M', 'Flute')]\n\n        action = ('place student', 'Ella', 'Flute', 'M', 8, 2)\n        actions[action] = [('student scheduled', 'Ella', 2),\n                           ('slot filled', 'M', 8),\n                           ('instrument on day', 'M', 'Flute')]\n\n        action = ('place student', 'Ella', 'Flute', 'Tu', 8, 1)\n        actions[action] = [('student scheduled', 'Ella', 1),\n                           ('slot filled', 'Tu', 8),\n                           ('instrument on day', 'Tu', 'Flute')]\n\n        action = ('place student', 'Ella', 'Flute', 'Tu', 8, 2)\n        actions[action] = [('student scheduled', 'Ella', 2),\n                           ('slot filled', 'Tu', 8),\n                           ('instrument on day', 'Tu', 'Flute')]\n\n        action = ('place student', 'Ella', 'Flute', 'F', 11, 1)\n        actions[action] = [('student scheduled', 'Ella', 1),\n                           ('slot filled', 'F', 11),\n                           ('instrument on day', 'F', 'Flute'),\n                           (('Drew', 'F', 10), ('Ella', 'F', 11))]\n\n        action = ('place student', 'Ella', 'Flute', 'F', 11, 2)\n        actions[action] = [('student scheduled', 'Ella', 2),\n                           ('slot filled', 'F', 11),\n                           ('instrument on day', 'F', 'Flute'),\n                           (('Drew', 'F', 10), ('Ella', 'F', 11))]\n\n        action = ('place student', 'Lola', 'Drums', 'F', 11, 1)\n        actions[action] = [('student scheduled', 'Lola', 1),\n                           ('slot filled', 'F', 11),\n                           ('instrument on day', 'F', 'Drums'),\n                           (('loud instrument', 'F', 10), ('loud instrument', 'F', 11))]\n\n        action = ('place student', 'Lola', 'Drums', 'F', 1, 1)\n        actions[action] = [('student scheduled', 'Lola', 1),\n                           ('slot filled', 'F', 1),\n                           ('instrument on day', 'F', 'Drums')]\n\n        super().__init__(requirements, actions, optional_requirements)\n\n\n    def _process_row_selection(self, row):\n        _, name, _, day, hour, _ = row\n        self._remember((name, day, hour))\n\n\nteacher_availability = None\nstudents = None\n\nsolver = MrsKnuthPartIIISolver(teacher_availability, students)\n\ncount = 0\nfor solution in solver.solve():\n    count += 1\n    print(f'Solution {count}')\n    for _, name, instrument, day, hour, lesson_num in solution:\n        print(f'   Add {name}/{instrument} to Mrs. Knuth\\'s schedule on {day} at {hour}.')\n</code></pre> <p>On to the puzzles!</p> <p></p>"},{"location":"10-your-turn/01-mrs-knuth-part-III/","title":"Solving Mrs. Knuth Part III","text":"<p>Puzzle: Mrs. Knuth - Part III</p> <p>You already have everything you need to instruct Algorithm X to find scheduling options for Mrs. Knuth. The last thing to cover is the process of evaluating the options and determining which one is best. I\u2019m going to leave all the score calculations to you, but I do want to show you how to make your <code>AlgorithmXSolver</code> subclass handle some of the details for you.</p> <p>Your code will need to evaluate a bunch of scheduling options and score each option. In order to keep track of the current best score and the current best option, let\u2019s create a couple of new attributes in your subclass constructor.</p> <pre><code>class MrsKnuthPartIIISolver(AlgorithmXSolver):\n\n    def __init__(self, teacher_availability, students, troublesome_pairs):\n\n        self.best_score = 0             # score of the best solution found so far\n        self.best_solution = []         # a copy of the best solution found so far\n\n        # You might need to keep track of more than just those\n        # two things above since you need to \"show your work\".\n\n        requirements = []\n        optional_requirements = []\n        actions = dict()\n\n        # Code to set up the rows and columns for Algorithm X goes here.\n\n        super().__init__(requirements, actions, optional_requirements)\n\n\n    def _process_solution(self):\n        # need to override this AlgorithmXSolver method\n</code></pre> <p>What is that second method definition? Each time Algorithm X finds a potential solution, the method <code>_process_solution(self)</code> is called before the <code>yield</code> statement sends that solution to the code looping through solutions. You can look through the <code>AlgorithmXSolver</code> code if you want to see where solutions are yielded. If you would like to use this built-in functionality, you simply override this method and add your specific scoring logic. Your code should look something like this:</p> <pre><code>    def _process_solution(self):\n\n        score = 0\n\n        # Your code to score the current solution goes here. The actions that make up the\n        # current solution are stored in the AlgorithmXSolver attribute self.solution.\n        # You can loop through this list of actions, just like we have already done in\n        # Mrs. Knuth - Parts I and II. Just remember to include \"self.\" because this\n        # functionality is taking place inside the class.\n\n        # If the current score is better than the best score, update the best score\n        # and save a copy of the solution as the new best_solution.\n\n        if score &gt; self.best_score:\n            self.best_score = score\n            self.best_solution = self.solution.copy()\n</code></pre> <p>That is enough to get you going in the right direction. There is still plenty of work to be done on your scoring algorithm, generating a visual of the best schedule and printing the scoring intermediate steps. You've got this!</p> <p></p>"},{"location":"10-your-turn/02-dumbbells-solver/","title":"Dumbbells Solver","text":"<p>Puzzle: Dumbbells Solver</p> <p>Author: @VilBoub</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: A Perfect Introduction to Multiplicity</p>"},{"location":"10-your-turn/02-dumbbells-solver/#strategy","title":"Strategy","text":"<p>Dumbbells Solver is the perfect puzzle for practicing what you just learned about multiplicity and it works wonderfully with the tiles on a gameboard analogy. You are given a gameboard with some markings indicating some of the weight locations. The tiles you will place on the gameboard are the dumbbells.</p> <p>Where is the multiplicity in this puzzle? Consider the dumbbells. In the Example Test Case, three dumbbells need to be placed on the floor. In real life, these dumbbells might be different colors, or they might be different weights, but in this puzzle there is nothing to tell one dumbbell from another. Is there any difference between placing 3 dumbbells on the floor and scheduling 3 lessons for Ella with Mrs. Knuth? No, there really is not.</p> <p>The requirements are straightforward. Some locations on the floor are marked and one end of a dumbbell must cover each marked location. Every other location on the floor may or may not be covered. Any location that gets covered can only be covered one time since the puzzle states:</p> <p>The dumbbells can touch but not cross each other.</p> <p>How about the actions you can take to build a solution? This puzzle looks very similar to Dominoes Solver in that regard. Combine what you learned on Dominoes Solver with the skills you solidified on Shikaku Solver and you should have a clear path forward. Of course, you will need to make sure you properly add precision to the requirements and actions, as was discussed in the approach to Mrs. Knuth \u2013 Part III.</p>"},{"location":"10-your-turn/02-dumbbells-solver/#memory-to-avoid-duplicates","title":"Memory to Avoid Duplicates","text":"<p>Because there is a unique solution to every test case, you may use a <code>break</code> statement as soon as Algorithm X returns the first solution. Dumbbells Solver is a great fit for Algorithm X and your solver should find the first solution very fast on every test case.</p> <p>I was surprised I did not see an increase in speed when I added memory to my <code>DumbbellsSolver</code>. When a call is made to <code>self._remember(self, item_to_remember: tuple)</code>, <code>AlgorithmXSolver</code> looks for the item in its memory and if that item is already in memory, the attribute <code>self.solution_is_valid</code> is set to <code>False</code>. I added the following lines of code to my <code>DumbbellsSolver</code> to take a look at how often memory was causing backtracking.</p> <pre><code>    def _process_row_selection(self, row):\n        unpacked action elements = row\n        self._remember((some combination of unpacked action elements))\n\n        if not self.solution_is_valid:\n            print('Memory is forcing backtracking...', file=sys.stderr, flush=True)\n</code></pre> <p>What did I find? Although memory did force backtracking, it was extremely rare. Since it did not happen often, there was not much impact on overall speed.</p>"},{"location":"10-your-turn/02-dumbbells-solver/#how-important-is-the-break-statement","title":"How Important is the <code>Break</code> Statement?","text":"<p>If the <code>break</code> statement is removed, Algorithm X will search for all solutions. Let's give it a try! Using the code above, you see memory forces a fair amount of backtracking. After searching for all solutions, add the following line to see how many solutions Algorithm X found.</p> <pre><code>print(f'{solver.solution_count=}', file=sys.stderr, flush=True)\n</code></pre> <p>What do you see? As long as memory is properly used, Algorithm X only finds a single solution for each test case. What if you delete the memory code? Algorithm X finds 6 solutions for Test Case 1 and 24 solutions for Test Case 2. For the last 3 test cases, the CodinGame time limit is hit before Algorithm X finishes searching for solutions.</p>"},{"location":"10-your-turn/02-dumbbells-solver/#takeaways","title":"Takeaways","text":"<p>Hopefully you are flying through some of these puzzles for which Algorithm X is such a great fit. If you run into issues, you might check these small details:</p> <ol> <li> <p>Are you using a <code>break</code> statement as soon as Algorithm X finds a solution?</p> </li> <li> <p>Are you correctly using <code>AlgorithmXSolver</code>'s memory?</p> </li> </ol> <p></p>"},{"location":"10-your-turn/03-equation-search/","title":"Equation Search","text":"<p>Puzzle: Equation Search</p> <p>Author: @Timinator</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Specifically Designed to Test What You Have Learned So Far</p>"},{"location":"10-your-turn/03-equation-search/#strategy","title":"Strategy","text":"<p>An important part to creating an Algorithm X solution for Equation Search is coming up with a gameboard/tiles analogy. What does the gameboard look like? It is tempting to make every operand and every operator a tile. The gameboard would be made up of several equations, each equation having 3 spots for 2 operands and 1 operator. Given right sides of 5, 7 and 10, the gameboard might look like:</p> <p></p> <p>As tiles are put on the gameboard, some sort of validation is needed to see if there is a way to put the operands and the operator together to come up with the right-side value. This feels a bit like making tiles in Winamax correspond to every cell in the grid. With Winamax, it ultimately was better to build routes and consider each possible route a tile that could be placed on the gameboard as a whole. A similar approach will work better here.</p> <p>Let\u2019s make the gameboard nothing more than a list of right-side values.</p> <p></p> <p>Using the strategy we know worked for Winamax, we can make each tile here a full equation, including the right-side value. The goal becomes to place the appropriate equation tiles on the matching right-side values found on the gameboard.</p> <p>Quiz: How many requirements are satisfied every time you put an equation on the gameboard?</p> Show explanation <p>The correct answer is 3. Putting a single equation tile on the gameboard covers one of the right-side numbers and it covers one of the necessary occurrences for each operand. Of course, if the operands are the same, it covers two of the necessary occurrences for that operand. Let\u2019s look at an example. </p> <p>Quiz: Given operand counts of one 2 and three 5s, how many different ways are there to create an equation that equals 10?</p> Show explanation <p>The correct answer is 6! Remember, because of the multiplicity, you can use the first 5, the second 5 or the third 5. The possible equations, depicted as tiles to put on the gameboard, look like this:</p> <p></p> <p>There is a fair amount of multiplicity in this puzzle and to solve the bigger test cases, you will need to properly use <code>AlgorithmXSolver</code>\u2019s memory. Without proper use of memory, you will generate a lot more solutions than necessary.</p> Test Case Distinct Solutions Solutions Found if Duplicates Not Avoided 4 - 6 Equations, 1 Solution 1 72 5 - 6 Equations, Multiple Solutions 3 96 6 - 10 Equations, 1 Solution 1 69,120 7 - 10 Equations, Multiple Solutions 31 445,824 8 - 13 Equations 227 I stopped counting at 250,000,000. 9 - 14 Equations 674 ? 10 - 15 Equations, 1 Solution 1 ? 11 - 15 Equations, Multiple Solutions 2898 ? 12 - So Many Solutions 4059 ?"},{"location":"10-your-turn/03-equation-search/#setting-up-algorithm-x","title":"Setting Up Algorithm X","text":"<p>The requirements for this puzzle are straightforward multiplicity. Each operand needs to occur a certain number of times. Successfully solving this problem will require good answers to these questions:</p> <ul> <li> <p>What are the individual action steps you can use to build a solution?</p> </li> <li> <p>When setting up the memory, what is it you want Algorithm X to remember?</p> </li> </ul> <p></p>"},{"location":"10-your-turn/04-hitori-solver/","title":"Hitori Solver","text":"<p>Puzzle: Hitori Solver</p> <p>Author: @VilBoub</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: A Crossroads of Multiplicity Might Have Your Eyes Crossing</p>"},{"location":"10-your-turn/04-hitori-solver/#strategy","title":"Strategy","text":"<p>My solution for Hitori Solver is surprisingly similar to Mrs. Knuth \u2013 Part III. The goal statement is extremely short:</p> <ul> <li>Each puzzle consists of a square grid with numbers appearing in all squares. The object is to shade squares so:</li> <li>No number appears in a row or column more than once.</li> <li>Shaded squares do not touch each other vertically or horizontally.</li> <li>When completed, all un-shaded squares create a single continuous area.</li> </ul> <p>What are the action steps that can be taken to build a solution?</p> <p>The object is to shade squares.</p> <p>What are the requirements?</p> <p>No number can appear in a row or column more than once.</p> <p>Is there any mutual exclusivity?</p> <p>Shaded squares must not touch vertically or horizontally.</p> <p>Will solutions need to be processed to determine if they are valid?</p> <p>When completed, all unshaded squares must create a single continuous area.</p> <p>Thank you @VilBoub for making the goal statement line up with the questions I had in my head already!</p> <p>Let\u2019s dig into the requirements a bit more. Consider the Example Test Case:</p> <pre><code>    111\n    234\n    224\n</code></pre> <p>We see three <code>1</code>s in the first row. Two of those <code>1</code>s will need to be shaded. Of course, requirements need to be specific and with Algorithm X, multiplicity is handled with multiple requirements. It is more proper to say that the requirements include removing a <code>1</code> from the first row for the first time and removing a <code>1</code> from the first row for the second time. Two separate requirements need to be satisfied.</p> <p>The only action that can be taken to build a solution is to shade a cell. Will you then create an action for every cell on the gameboard? Probably not. There is no reason to ever shade a cell unless the number in the cell appears more than once in its row or its column.</p> <p>This puzzle has a unique multiplicity twist not seen in other puzzles and you will run into it when you are identifying the requirements satisfied by each action. Consider the grid for Test Case 4: Even Bigger:</p> <pre><code>    22153\n    23145\n    11135\n    13542\n    54321\n</code></pre> <p>Would you ever shade the top-left corner? It is definitely possible. There are multiple <code>2</code>s in the row and multiple <code>2</code>s in the column. Shading the top-left corner covers requirements associated with the row and requirements associated with the column.</p> <p>What about the second <code>2</code> in the top row? Absolutely possible. However, shading the top row, second from the left removes a <code>2</code> from the top row, but what does it do for the column? The answer is nothing! There is only a single <code>2</code> in the column. Shading that square does not cover any column requirements because there are no column requirements involving removing a <code>2</code> from the second column from left.</p> <p>The tricky part of this puzzle is that every square you might want to shade could do any of the following:</p> <ul> <li> <p>Remove a problem number from both the row and the column.</p> </li> <li> <p>Remove a problem number from just the row.</p> </li> <li> <p>Remove a problem number from just the column.</p> </li> </ul> <p>This creates a potential crossroads of multiplicity at each grid location, which is unique to this puzzle and you will need to take all these scenarios into consideration when identifying the requirements satisfied by each action.</p> <p>I hope it is obvious you will need some optional requirements to make sure no two squares that touch are both shaded.</p>"},{"location":"10-your-turn/04-hitori-solver/#memory","title":"Memory","text":"<p>Even without memory, Algorithm X is able to find solutions extremely fast, especially since you can <code>break</code> as soon as your solver returns a solution, assuming you have validated that solution by overriding the <code>_process_solution(self)</code> method. Adding memory reduced my solver\u2019s time to find a solution by roughly 30% to 40%, but this is a little challenging to measure due to how fast Algorithm X finds the solutions even without memory.</p> <p></p>"},{"location":"10-your-turn/05-no-spoon-2/","title":"There Is No Spoon - Episode 2","text":"<p>Puzzle: There Is No Spoon - Episode 2</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Strap In and Hold On Tight</p>"},{"location":"10-your-turn/05-no-spoon-2/#a-past-contest","title":"A Past Contest","text":"<p>There is No Spoon was a contest in April 2015 and the winner passed all test cases and validators in less than 90 minutes! The puzzle is based on the logic puzzle, Hashiwokakero, which translates to \u201cbuild a bridge\u201d. You will find websites that refer to the game as \u201cbridge building\u201d, \u201cbridges\u201d or some other variation. Today, it is easy to find websites that will let you work Hashiwokakero puzzles if you\u2019d like to get a better feel for how the game is played.</p> <p>Bridges from Simon Tatham\u2019s Portable Puzzle Collection</p> <p>Play Hashiwokakero on SilverGames.com</p> <p>CodinGame uses the terms NODE and LINK instead of the terms island and bridge to identify a connection between two islands/nodes. From here forward, I am going to use the CodinGame puzzle terms NODE and LINK.</p>"},{"location":"10-your-turn/05-no-spoon-2/#visualizing-the-problem","title":"Visualizing the Problem","text":"<p>I believe using the analogy of tiles on a gameboard is the key to a successful Algorithm X approach to this puzzle. What does the gameboard look like? At first glance, the gameboard appears to be a blank slate with nothing except a bunch of nodes, each with a number indicating how many links need to be connected to the node.</p> <p></p> <p>I contend there is much more to the gameboard that is subtly hidden. I will come back to that, but first we need to investigate the action steps that can be taken to create a solution. It seems straightforward the only action we can take to work toward a solution is to put a link between two Nodes, similar to this:</p> <p></p> <p>Where do I put the link? Yes, I know the link goes between the two Nodes, but where exactly do I place my \u201clink tile\u201d on the gameboard? How does the gameboard indicate to me that I can put one or two links between Nodes, but I cannot put three? There is something between the Nodes that is not explicit in the description, but it is definitely there. I\u2019m going to call this space between Nodes, where a link can be placed, a Channel.</p> <p></p> <p>I can put 0, 1 or 2 links in any Channel. Let\u2019s add dotted lines to each Channel to represent a slot or a placeholder for a future link. My gameboard is much clearer now. To create a solution, I can put links on the gameboard anywhere I see an open slot (dashed line) inside a Channel between Nodes.</p> <p></p> <p>What about the places where Channels cross? These seem to be very important locations since links are not allowed to cross each other. Any two Channels that cross each other could create future problems. Channels can only cross each other at grid locations that are not Nodes. Let\u2019s call every non-Node grid location an Intersection and build our full gameboard from scratch, starting with just Nodes and Intersections:</p> <p></p> <p>Once I fully understand the layout of my gameboard, the only important Intersections will be the intersections that have crossing Channels. Even then, nothing is terribly important about an Intersection until a link is placed in one of the slots of a Channel. At that point, the other Channel in the Intersection is no longer in play. It needs to be removed from the realm of possibility. No links can ever be placed in the second Channel.</p> <p>This next diagram displays the entire gameboard before any links are placed. For just a minute, consider how much more detailed this gameboard is compared to the original gameboard. No actions have been taken. No links have been placed. We have only taken the time to build a more detailed, and possibly more meaningful, understanding of the gameboard.</p> <p></p> <p>Summarizing the gameboard now, we see the following components:</p> <p>Node \u2013 a location on the gameboard that needs a certain number of links.</p> <p>Channel \u2013 a trench between two Nodes, inside of which can be placed some number of links. A Channel\u2019s link capacity is determined by several factors discussed below, but it can never be more than 2. A Channel may or may not pass through Intersections as it travels between the two Nodes it connects</p> <p>Intersection \u2013 a non-Node location on the gameboard that knows about any Channel that passes through that location</p> <p>Every Channel has capacity for a certain number of links. For now, this is the only attribute that requires a bit of discussion:</p> <p>Channel Capacity \u2013 in general, a Channel\u2019s initial link capacity is determined by the following formula: <code>minimum(2, node1 links needed, node 2 links needed)</code>. There are two important exceptions to this rule.</p> <p></p> <p>Exception #1: In the above diagram, each Node connected by the Channel needs 1 link. If these are the only two Nodes in the puzzle, the Channel capacity is 1. If there are more than two Nodes in the puzzle, the Channel capacity is zero since putting a link between the two nodes would create a connected group that could not be connected to the rest of the puzzle.</p> <p></p> <p>Exception #2: In the above diagram, each Node connected by the Channel needs 2 links. If these are the only two Nodes in the puzzle, the Channel capacity is 2. If there are more than two Nodes in the puzzle, the Channel capacity is 1 since putting two links between the two Nodes would create a connected group that could not be connected to the rest of the puzzle.</p>"},{"location":"10-your-turn/05-no-spoon-2/#object-oriented-analysis","title":"Object-Oriented Analysis","text":"<p>Object-Oriented Programming is a popular topic in the world of Computer Science, but how did that come about? Thought leaders believe the world we live in is object-oriented and matching our code structure to the world we observe might have benefits. I contend we have just finished building an object-oriented understanding, or Analysis, of our problem space. Next, I'll show you how to turn that Object-Oriented Analysis into an Object-Oriented Design that makes the job of identifying actions and requirements for Algorithm X significantly easier than it might have seemed at first.</p> <p></p>"},{"location":"10-your-turn/06-no-spoon-2-cont/","title":"There Is No Spoon - Episode 2 (cont.)","text":"<p>We just finished building the following detailed gameboard and a link can be placed on any dashed line.</p> <p></p>"},{"location":"10-your-turn/06-no-spoon-2-cont/#an-object-oriented-model-of-the-problem-space","title":"An Object-Oriented Model of the Problem Space","text":"<p>Before we identify requirements and actions for Algorithm X, let\u2019s take an inventory of what we see on our gameboard. We see a bunch of Nodes, a bunch of Intersections and a bunch of channels. Let\u2019s create a class for each of these.</p> <p></p> <p>How will the relationships among instances of these three classes be managed? What information is needed to recreate the gameboard from scratch? Consider the following:</p> <ul> <li> <p>Node</p> <ul> <li>has a (row, col) location on the gameboard</li> <li>is connected to between 1 and 4 Channels</li> <li>needs a certain number of links connected to it</li> </ul> </li> <li> <p>Channel</p> <ul> <li>connects exactly 2 Nodes</li> <li>has a capacity, some number of unused slots where links can be placed</li> <li>passes through 0 to many Intersections</li> </ul> </li> <li> <p>Intersection</p> <ul> <li>has a (row, col) location on the gameboard</li> <li>has 0, 1 or 2 Channels passing through it</li> </ul> </li> </ul> <p>These observations lead us to create the following object-oriented model of our problem space. </p> <p></p> <p>I am streamlining the process a bit, but if we add a few attributes to the classes, we can make our model a bit more concrete. Some might call these features the difference between the object-oriented analysis model of the problem space and an object-oriented design model that guides us to an implementation.</p> <p></p> <p>Looking at the problem space this way is probably not the first thought most people have. It is likely more common to think each Node will need to know about its neighbor Nodes. In the model created here, Nodes do not know anything about other Nodes on the gameboard. Much of the information a Node needs access to is found in its Channels. A Node is interested in how many Channels it is connected to and how much link capacity those Channels provide. A Channel becomes the manager of the relationship between 2 Nodes. Without the Channel, those 2 Nodes really don't have any relationship at all. It is important to remember where this perspective originated. It came from thinking of the problem as a gameboard and a number of tiles that need to be placed on the gameboard.</p>"},{"location":"10-your-turn/06-no-spoon-2-cont/#giving-life-to-the-gameboard","title":"Giving Life to the Gameboard","text":"<p>At this point, classes exist for each key abstraction on the gameboard. It is time to create instances of each class and build the relationships among the objects.</p> <p>Step 1: For every Node location on the initial gameboard, create an instance of the <code>Node</code> class. The only information available for a <code>Node</code> is the <code>(row, col)</code> location on the gameboard and the number of needed links.</p> <p>Step 2: For every non-Node location on the initial gameboard, create an instance of an <code>Intersection</code> with nothing more than a <code>(row, col)</code> location.</p> <p>Did you complete There is No Spoon \u2013 Episode 1? Now is the time to use what you learned on that puzzle. For every <code>Node</code>, determine if it has a horizontal neighbor to the right and determine if it has a vertical neighbor below. It is only necessary to check in 2 directions. As long as every <code>Node</code> is explored in those two directions, all <code>Channel</code>s will be found. </p> <p>Step 3: For every <code>Node</code>, if there is a neighbor to the right, create a <code>Channel</code> and if there is a neighbor below, create a second <code>Channel</code>. It should be straightforward to build a list of <code>Intersection</code>s as you search for neighbors. When a <code>Channel</code> is created, it needs to know about the 2 <code>Node</code>s it connects and it needs a list of <code>Intersection</code>s it passes through.</p> <p>That is all for now. Not a single link has been placed, but the gameboard has been explored in tremendous detail and the perspective, with which the gameboard has been understood, is the key to the next step where the preliminary Object-Oriented Design guides the process of creating the matrix for Algorithm X.</p> <p></p>"},{"location":"10-your-turn/07-no-spoon-2-matrix/","title":"There Is No Spoon - Episode 2 - Setting Up Algorithm X","text":"<p>Let's take another look at the Object-Oriented Design model. Everything Algorithm X needs is right here:</p> <p></p> <p>This is one of the toughest Algorithm X puzzles on CodinGame due to the amount of multiplicity. The requirements are straightforward. Just like Ella needed some number of lessons for Mrs. Knuth \u2013 Part III, each Node needs some number of links.</p> <p>Step 1: Loop through all <code>Node</code>s and create the appropriate requirements.</p> <p>Let\u2019s dig a bit deeper into the actions. As mentioned earlier, all actions involve putting some link between two <code>Node</code>s, but what does that actually look like? Looking at the gameboard, the link must be placed in a specific slot and it needs to be tied to one of the link requirements for each <code>Node</code>. That looks like triple multiplicity, doesn\u2019t it!</p> <p>Step 2: Loop through all <code>Channel</code>s and create the appropriate actions, including the lists of requirements covered by each action. Make sure you properly handle all the multiplicity.</p> <p>What about those pesky <code>Intersection</code>s? Putting a link in a <code>Channel</code> might eliminate any possibility of putting links in a crossing <code>Channel</code>. Sounds like textbook mutual exclusivity, right? You\u2019ll need to create optional requirements to handle all the mutual exclusivity.</p> <p>Step 3: Loop through all <code>Intersection</code>s and create the appropriate optional requirements to handle all mutual exclusivity created by <code>Channel</code>s that pass through the same <code>Intersection</code>.</p> <p>Step 4: Make sure all the proper <code>me_requirements</code> are added to the lists of requirements covered by the actions that cover them. If you use the code structure recommended in Mrs. Knuth \u2013 Part III, make sure you append the <code>me_requirements</code> to the rest of the <code>optional_requirements</code> before invoking the inherited <code>AlgorithmXSolver</code> constructor.</p>"},{"location":"10-your-turn/07-no-spoon-2-matrix/#your-goal","title":"Your Goal","text":"<p>Using the techniques covered so far, you can solve most of the test cases for this puzzle, but you cannot solve them all. Test Case 8: Advanced and Test Case 13: Expert are just too big to solve purely with backtracking. In the next section, I will cover problem-space reduction, and I\u2019ll revisit this puzzle with a few more ideas that might help you find the finish line. Before moving on, let\u2019s discuss a few things about the test cases you should be able to solve.</p> <p>Test Cases 1 through 7, 9 and 10: These can all be solved with Algorithm X by following the processes covered in the Mrs. Knuth puzzles and the guidelines given here.</p> <p>Test Cases 11 and 12: Algorithm X will generate multiple solutions and you will need to determine which solution has a single connected group of nodes. Just like in Mrs. Knuth \u2013 Part III, this is a perfect opportunity to override the <code>AlgorithmXSolver</code> method <code>_process_solution(self)</code>. If the solution is valid, you do not need to do anything. The solver will <code>yield</code> the solution just as expected. If the solution is not valid, add the following line before exiting the method to tell Algorithm X this solution is not valid and should not be included in the solution generator.</p> <pre><code>self.solution_is_valid = False\n</code></pre> <p>You never need to specifically set this attribute back to <code>True</code>. Invalid solutions immediately cause backtracking and <code>AlgorithmXSolver</code> automatically resets this attribute to <code>True</code> every time backtracking occurs.</p> <p>In the next section, I will discuss how to solve part of a problem with logic so the task given to Algorithm X is more manageable. Much of There is No Spoon \u2013 Episode 2 can be solved with only logic, no backtracking. However, only a combination of logical problem-space reduction and backtracking can solve all test cases and validators.</p> <p></p>"},{"location":"11-problem-space-reduction/01-problem-space-reduction/","title":"Problem-Space Reduction","text":"<p>At some point in your Algorithm X journey, you will encounter problems that are too big for backtracking alone. The problem space that must be explored to find all solutions requires an unacceptable amount of time. In these cases, the key is often to use logic to reduce the problem space before starting the backtracking. As has already been demonstrated, backtracking via Algorithm X can solve many problems without any problem-space reduction. We will soon see that logical, problem-space reduction can also solve some problems with no need for any backtracking. In the end, most medium and hard puzzles eventually present test cases that require a combination of both.</p> <p>If simply solving the puzzle is your goal, a small amount of problem-space reduction before the backtracking will probably get you there. However, if you want to harvest as much education as possible from these puzzles, I suggest you consider doing the following:</p> <ol> <li> <p>Solve as many test cases as possible with backtracking alone.</p> </li> <li> <p>Solve as many test cases as possible with problem-space reduction alone.</p> </li> <li> <p>Only after you have exhausted all options for 1 and 2, use a combination of both.</p> </li> </ol> <p>There are many ways to approach problem-space reduction. You will need to choose various data structures and build an algorithm to mimic what you would do if you were trying to solve the puzzle with a pencil on paper. In the rest of this section, I will lay out a structure and a process I have used repeatedly that has worked well for me.</p>"},{"location":"11-problem-space-reduction/01-problem-space-reduction/#one-more-round-of-sudoku","title":"One More Round of Sudoku","text":"<p>Consider Test Case 1: Very Easy from Sudoku Solver on CodinGame. In the test cases, a <code>0</code> represents an unknown cell. The following diagram leaves the unknown cells empty.</p> <p></p> <p>From the problem statement:</p> <p>A sudoku is a Latin Square which has the numbers 1-9 in each row, column, and 3x3 square.</p> <p>In the following diagram, I have assigned numbers to each row, column and box (sub-grid square). Because Python is 0-indexed, I have started numbering at zero.</p> <p></p> <p>It is time to use logic to find more numbers in the Sudoku before starting any backtracking.</p> <p></p>"},{"location":"11-problem-space-reduction/02-sudoku-problem-space-reduction/","title":"Sudoku Problem-Space Reduction","text":"<p>To reduce the problem space, it is helpful to consider how you might go about solving the problem by hand. With a Sudoku, you might start by looking at each row, column and box separately. You could consider what you know about each group of cells and how that knowledge allows you to reduce the possible values of other cells.</p> <p>Using the Sudoku identified on the previous page, first create a list of all possible numbers, or candidate values, for each cell. If the cell is already known, that list contains a single number. If the cell is unknown, the initial list of candidates contains all the numbers from <code>1</code> to <code>9</code>. The more known numbers in a group, the easier it might be to identify numbers that belong in other cells. Row 1 already has 6 known numbers, making it a good place to start.</p> <p></p> <p>The next diagram shows the candidates for each cell in row 1.</p> <p></p> <p>Because numbers cannot be duplicated in a row, the numbers in the known cells can be removed from each unknown cells' candidates.</p> <p></p> <p>Each of the unknown cells is also in a column where, again, numbers cannot repeat. Column 1 already has a <code>1</code>, column 6 already has a <code>4</code> and column 8 already has a <code>1</code>.</p> <p></p> <p>Based on the known numbers found in the other cells of each of the three columns, the candidates can be reduced even further. The three unknown cells in row 1 now have only 2 possibilities each.</p> <p></p> <p>Lastly, each of the unknown cells in row 1 is also part of a box and that box must not have duplicates. </p> <p></p> <p>Box 0 does not help at this time, but box 2 already has a <code>6</code> and that <code>6</code> can be removed from the candidates for each cell in box 2.</p> <p></p> <p>We have come full circle, and it is again time to look at row 1 where we now see 8 of the 9 cells with a single possibility, making it very easy to reduce the last cell to a single possibility. The Sudoku grid now has 3 more known numbers:</p> <p></p>"},{"location":"11-problem-space-reduction/02-sudoku-problem-space-reduction/#putting-it-all-together","title":"Putting It All Together","text":"<p>A traditional Sudoku has 9 rows, 9 columns and 9 boxes. All rows, columns and boxes behave exactly the same. Rather than using the terms rows, columns and boxes, I will call them all Sudoku cell groups. The problem can be generalized to 27 Sudoku cell groups. Each group has 9 cells, and each group must contain all the numbers from <code>1</code> to <code>9</code>.</p> <p>To reduce a Sudoku problem space, by hand or by algorithm, you must repeatedly loop through all 27 groups, logically reducing the candidates of any unknown cell where you can. If you loop through all 27 groups and not a single update is made, your logic is either missing something or maybe the puzzle just cannot be solved completely with logic. Either way, it is time to start guessing and backtracking where necessary.</p> <p>Next, I will propose a structure for your code and a basic algorithm to facilitate problem-space reduction on any of the puzzles for which the problem space is too big for Algorithm X alone. But first, a very short look at variables in Python.</p> <p></p>"},{"location":"11-problem-space-reduction/03-variables-are-pointers/","title":"Python Variables","text":"<p>Understanding how variables work in Python is a learning experience every Python programmer goes through. With a bare minimal understanding of C and C++ pointers, I was thoroughly confused the first time I created a function in Python with a <code>list</code> as an argument. I thought a copy of the <code>list</code> would be made and my original <code>list</code> would stay intact. Not the case!</p> <p>Once you understand that all variables in Python are pointers to objects, your Python life becomes much more clear. If this is a new concept to you, do not fear that we might be travelling down a path of C pointers and pointers to pointers, etc. As most things are in Python, it is much easier than you probably expect.</p> <p>On the website Python Morsels, Trey Hunner does a great job explaining how variables work in Python.</p> <p>For even more detail, check out this write-up on LaunchSchool.com.</p>"},{"location":"11-problem-space-reduction/03-variables-are-pointers/#why-is-this-important","title":"Why Is This Important?","text":"<p>In the next section, I will suggest making every cell in your Sudoku grid an object. Each grouping of cells (rows, columns and boxes) then becomes a list of 9 pointers to the cell objects that make up that group. Let's take a closer look.</p> <p></p>"},{"location":"11-problem-space-reduction/04-setting-up-sudoku/","title":"A Sudoku Data Structure","text":"<p>A few pages ago, I intentionally drew the original Sudoku grid as 81 disconnected cells to create the perception of each cell being a standalone entity, or object. Since each cell is a standalone object, I can put a pointer to that cell into each group to which it belongs. I will demonstrate how to do this with Sudoku, and later I will give an overview of how this same general structure can be used on several other puzzles.</p> <p>Conceptually, I create two classes, one for a <code>SudokuCell</code> and another for a <code>SudokuGroup</code>. The <code>SudokuGroup</code> will have an attribute that is a list of pointers to the 9 <code>SudokuCell</code>s that are part of that group.</p> <p></p> <p>In the interest of code reuse across all Sudoku puzzles, my SudokuSolver will require the following:</p> <ol> <li> <p>Unknown cells must use a <code>.</code> to indicate an unknown cell. Some puzzles use a <code>0</code> which is easy to fix with a call to <code>str.replace('0', '.')</code>.</p> </li> <li> <p>All cell values will be treated as characters.</p> </li> <li> <p><code>all_possible_values</code> will be a string of all characters found in the Sudoku.</p> </li> </ol> <p>Let's make the conceptual classes a bit more concrete. First, a class for an individual cell:</p> <pre><code>UNKNOWN = '.'\n\nclass SudokuCell():\n\n    def __init__(self, value: str, all_possible_values: str):\n        self.value = value\n        self.candidates = set(all_possible_values) if value == UNKNOWN else {value}\n\n    def reduce_(self, unavailable_values: set):\n        # your code goes here \u2013 make sure all unavailable_values are removed from the candidates\n</code></pre> <p>Second, a class for a Sudoku group:</p> <pre><code>class SudokuGroup():\n\n    def __init__(self):\n        self.cells = []\n\n    def reduce_(self):\n        # your reducing code goes here\n</code></pre> <p>Next, in the constructor of my <code>SudokuSolver</code> class, I use a dictionary comprehension to create an instance of a <code>SudokuCell</code> for each location in the grid. Using the <code>(row, col)</code> tuple as the dictionary key makes it easy to get a pointer to a cell as the groups are built.</p> <pre><code>class SudokuSolver(AlgorithmXSolver):\n\n    def __init__(self, grid: List[List[str]], all_possible_values: str):\n\n        # Calculate size and box size so that one class works for different size Sudokus.\n        size = len(grid)\n        box_size = int(size ** 0.5)\n\n        self.grid = {(r, c): SudokuCell(grid[r][c], all_possible_values) for r in range(size) for c in range(size)}\n</code></pre> <p>It would have been just as easy to create a two-dimensional array of <code>SudokuCell</code> instances. I chose to use a dictionary to hold the cells to intentionally blur the visual of a Sudoku grid. I find it beneficial to think in terms of rows, columns and boxes as compared to maintaining the visual of a two-dimensional grid.</p> <p>Continuing in the constructor, I create a list of <code>SudokuGroup</code>s for the rows, another for the columns and a third for the boxes.</p> <pre><code>        rows = [SudokuGroup() for _ in range(size)]\n        cols = [SudokuGroup() for _ in range(size)]\n        boxes = [SudokuGroup() for _ in range(size)]\n</code></pre> <p>The last setup step is to put all the cells into the groups to which they belong. The values of <code>self.grid</code> are all pointers to instances of <code>SudokuCell</code>s. After the following code executes, we are left with 3 lists of 9 groups, each group having a list of pointers to the cells that make up that group. Because of the pointers, a change to one cell is seen by all groups to which that cell belongs.</p> <pre><code>        for row in range(size):\n            for col in range(size):\n                box = row // box_size * box_size + col // box_size\n                cell = self.grid[(row, col)]\n\n                rows[row].cells.append(cell)\n                cols[col].cells.append(cell)\n                boxes[box].cells.append(cell)\n</code></pre> <p>I cannot emphasize enough how powerful this pointer-based structure can be. In an object-oriented approach, objects have relationships with other objects. Despite any bad memories the word \"pointer\" might stir up, Python makes pointers very straightforward and pointers are a very common way for one object to \"have a relationship\" with another object.</p>"},{"location":"11-problem-space-reduction/04-setting-up-sudoku/#a-short-algorithm-to-facilitate-problem-space-reduction","title":"A Short Algorithm to Facilitate Problem-Space Reduction","text":"<p>Before exiting the constructor, the last task is to loop over all 27 groups, one at a time, reducing the problem space where possible.</p> <pre><code>        need_to_reduce = True\n        while need_to_reduce:\n            need_to_reduce = False\n            for group in rows + cols + boxes:\n                if group.reduce_():\n                    need_to_reduce = True\n</code></pre> <p>The <code>while</code> loop will continue as long as at least one group is able to reduce the problem space in some way. Only after all 27 groups indicate no reduction is possible does the code exit the <code>while</code> loop and if any cells remain unknown, I\u2019m sure you know what comes next - building the requirements and actions for Algorithm X.</p>"},{"location":"11-problem-space-reduction/04-setting-up-sudoku/#how-much-reducing-is-necessary","title":"How Much Reducing is Necessary?","text":"<p>This framework will get you going in a good direction, but there is still a lot of code to write. You may have already completed all the Sudoku puzzles using Algorithm X, but there is a lot to be learned if you take on the challenge of solving those puzzles again, using only logic this time. Fortunately, Sudoku has been well studied and a simple Google search results in many strategies for solving a Sudoku by hand.</p> <p>On the next page, I'll give you a few hints as to what is possible on all the Sudoku puzzles using only logical, problem-space reduction. Later in the playground, I will explore several puzzles that require a bit of problem-space reduction before backtracking begins if you hope to find solutions within the given time.</p> <p></p>"},{"location":"11-problem-space-reduction/05-sudoku-challenge/","title":"This Will Be Important Later","text":"<p>You may have already finished all the Sudoku puzzles without any problem-space reduction. I strongly suggest you consider following through with what I'm about to propose and the reason is because of Killer Sudoku Solver and Killer Sudoku Extreme Challenge. 100% of any effort you put forward on this exercise will benefit you when you solve the Killer Sudoku puzzles, which begin with all the same rules as Sudoku and then add a few details you can tackle later.</p>"},{"location":"11-problem-space-reduction/05-sudoku-challenge/#initial-challenge-lone-singles","title":"Initial Challenge - Lone Singles","text":"<p>My initial challenge is for you to implement the reduction technique covered in the previous pages. On the website Learn-Sudoku.com, this technique is referred to as Lone Singles. For any cell that has been reduced to a single candidate, that value may be removed from the candidate lists of all other cells in the same groups. With just this one reduction technique, you can achieve the following results on each of the CodinGame Sudoku puzzles...without any backtracking.</p> Puzzle Results Sudoku Solver \u2705 Test Case 1: Very Easy\u274c Test Case 2: Easy - Oh, so close!\u274c Test Case 3: Intermediate/Hard - Minimal reduction.\u274c Test Case 4: World's Hardest Sudoku - No reduction at all. 16x16 Sudoku \u2705 Test Case 1: Test 1\u2705 Test Case 2: Test 2\u274c Test Case 3: Test 3 - Minimal reduction.\u274c Test Case 4: Test 4 - Minimal reduction.\u274c Test Case 5: Test 5 - Minimal reduction.\u274c Test Case 6: Test 6 - Minimal reduction. 25x25 Sudoku \u274c Test Case 1: Test 1 - 77 more cells found.\u274c Test Case 2: Test 2 - Minimal reduction.\u274c Test Case 3: Test 3 - Minimal reduction.\u274c Test Case 4: Test 4 - Minimal reduction.\u274c Test Case 5: Test 5 - Minimal reduction. Mini Sudoku Solver \u2705 Test Case 1: Test 1\u2705 Test Case 2: Test 2\u2705 Test Case 3: Test 3\u2705 Test Case 4: Test 4"},{"location":"11-problem-space-reduction/05-sudoku-challenge/#level-2-challenge-hidden-singles","title":"Level 2 Challenge - Hidden Singles","text":"<p>Going back to Learn-Sudoku.com, let's add another fairly easy technique, Hidden Singles. A hidden single is a cell in a group that has one candidate that does not appear in the candidate list of any other cell in the group. Because this candidate only appears in a single cell in the group, it is known where the candidate belongs. Adding this one additional basic technique will improve your results.</p> Puzzle Results Sudoku Solver \u2705 Test Case 1: Very Easy\u2705 Test Case 2: Easy\u274c Test Case 3: Intermediate/Hard - 12 more cells found.\u274c Test Case 4: World's Hardest Sudoku - No reduction at all. 16x16 Sudoku \u2705 Test Case 1: Test 1\u2705 Test Case 2: Test 2\u274c Test Case 3: Test 3 - 49 more cells found.\u274c Test Case 4: Test 4 - 14 more cells found.\u274c Test Case 5: Test 5 - 41 more cells found.\u274c Test Case 6: Test 6 - 56 more cells found. 25x25 Sudoku \u2705 Test Case 1: Test 1\u274c Test Case 2: Test 2 - 56 more cells found.\u274c Test Case 3: Test 3 - 68 more cells found.\u274c Test Case 4: Test 4 - 58 more cells found.\u274c Test Case 5: Test 5 - 66 more cells found. Mini Sudoku Solver \u2705 Test Case 1: Test 1\u2705 Test Case 2: Test 2\u2705 Test Case 3: Test 3\u2705 Test Case 4: Test 4"},{"location":"11-problem-space-reduction/05-sudoku-challenge/#ultimate-sudoku-logic-challenge","title":"Ultimate Sudoku Logic Challenge","text":"<p>Learn-Sudoku.com has several more reduction strategies. Can you implement enough to solve every traditional Sudoku puzzle with logic alone? I will keep my own progress updated in a table at the end of this playground. If you take on this challenge, I do have one suggestion for your data structure. I have found it helpful if each cell has pointers to the groups to which it belongs. Conceptually, the object model has one small addition shown below.</p> <p></p> <p>As the <code>SudokuGroup</code>s are being filled with <code>SudokuCell</code>s, it is easy enough to give each cell 3 pointers, one to each of the groups where it is a member. I have used a named tuple to hold these three pointers. In the constructor, the new <code>groups</code> attribute is initialized to <code>None</code>.</p> <pre><code>CellGroups = namedtuple('CellGroups', 'row col box')\n\nclass SudokuCell():\n\n    def __init__(self, value: str, all_possible_values: str):\n        self.value = value\n        self.candidates = set(all_possible_values) if value == UNKNOWN else {value}\n        self.groups = CellGroups(None, None, None)\n</code></pre> <p>As the groups are being built in the <code>SudokuSolver</code> constructor, give each cell a tuple of pointers to the groups to which it belongs.</p> <pre><code>        for row in range(size):\n            for col in range(size):\n                box = row // box_size * box_size + col // box_size\n                cell = self.grid[(row, col)]\n\n                rows[row].cells.append(cell)\n                cols[col].cells.append(cell)\n                boxes[box].cells.append(cell)\n\n                cell.groups = CellGroups(rows[row], cols[col], boxes[box])\n</code></pre>"},{"location":"11-problem-space-reduction/05-sudoku-challenge/#solving-logic-puzzles-logically","title":"Solving Logic Puzzles Logically","text":"<p>Many Sudoku puzzles can be solved without making any guesses. Click here to see my progress toward solving as many logic puzzles as possible, strictly with logic, no guessing and no backtracking.</p> <p></p>"},{"location":"12-your-turn/01-literary-alfabet-soupe/","title":"Literary Alfabet Soupe (Revisited)","text":"<p>Puzzle: Literary Alfabet Soupe</p> <p>Author: @David Augusto Villa</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Is Algorithm X Really Needed?</p>"},{"location":"12-your-turn/01-literary-alfabet-soupe/#strategy","title":"Strategy","text":"<p>In the original discussion for this puzzle, I wrote:</p> <p>Let\u2019s assume you are at a point where you have some number of \u201ccandidate\u201d languages for each excerpt. Some excerpts might have just one candidate language while others might have 2, 3, 4 or more candidate languages.</p> <p>Can you do any problem-space reduction before running Algorithm X? Of course you can! Assume you have identified the following candidate languages for the first 3 excerpts:</p> Excerpt Candidate Languages 1 Finnish, French, German, Irish 2 German 3 French, German, Spanish <p>Do you see the opportunity for problem-space reduction? The only option for excerpt 2 is German. Since each language can only be used one time, German can be removed from the candidate lists for excerpts 1 and 3.</p> <p>Once you have a list of candidate languages for each excerpt, your problem-space reduction can be similar to what was covered a few pages back using Sudoku. This puzzle is not meant to be a complex exact cover problem, so keep your reduction algorithm simple. If you create a loop to reduce the candidate lists wherever possible, you might find that full solutions appear for each test case before you even begin setting up Algorithm X. </p> <p></p>"},{"location":"12-your-turn/02-25x25-sudoku/","title":"25x25 Sudoku (Revisited)","text":"<p>Puzzle: 25x25 Sudoku</p> <p>Author: @yoch</p> <p>Published Difficulty: Very Hard</p> <p>Algorithm X Complexity: Straightforward</p>"},{"location":"12-your-turn/02-25x25-sudoku/#stragegy","title":"Stragegy","text":"<p>The last time 25x25 Sudoku was discussed, your solution might have been a little slow. The order of the rows in your Algorithm X matrix made a difference in run time. If you want a more robust solution that always works independent of matrix construction, a little problem-space reduction before building the matrix is your answer!</p> <p>Here is the best news of all. Any problem space reduction you did for traditional 9x9 Sudoku also works on 25x25 Sudoku. A few easy Sudoku reduction strategies can reduce the number of rows in your matrix quite a bit and improve all your run times. I won\u2019t specifically state which strategies I implemented, but with just three basic strategies, I reduced the matrix row counts as follows:</p> Original Row Count New Row Count Test Case 1: Test 1 7249 625 Test Case 2: Test 2 8569 1609 Test Case 3: Test 3 8401 1474 Test Case 4: Test 4 8329 1595 Test Case 5: Test 5 8449 2053 <p></p>"},{"location":"12-your-turn/03-futoshiki-solver/","title":"Futoshiki Solver (Revisited)","text":"<p>Puzzle: Futoshiki Solver</p> <p>Author: @Sundiver</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Great Confidence Builder</p>"},{"location":"12-your-turn/03-futoshiki-solver/#strategy","title":"Strategy","text":"<p>The first time Futoshiki was discussed in this playground, a few key distinctions were made.</p> <ul> <li> <p>Just like Sudoku, Futoshiki is a special kind of Latin Square.</p> </li> <li> <p>Inequalities allow for important problem-space reduction.</p> </li> </ul> <p>I think we all like to reuse code wherever possible. Here are a couple of conceptual ideas we know to be true:</p> <p></p> <p>In the final Sudoku Challenge, I suggested each cell having pointers to the groups to which it belongs. In Futoshki, each cell only belongs to a row and a column. There are no boxes. Rather than addressing this difference between a <code>SudokuCell</code> and <code>FutoshikiCell</code>, I suggest going back to the basic version of a <code>SudokuCell</code> that did not know about its groups. The basic version is plenty to completely solve all Futoshiki test cases.</p> <p>The Futoshiki input is somewhat tougher to parse, but you can use your exact same Sudoku code to create  <code>n * n</code> instances of the <code>SudokuCell</code> class. You can even use your previous code to create <code>SudokuGroup</code>s for each row and each column of the Futoshiki grid. Keep in mind, Futoshiki does not have boxes (sub-grids) like Sudoku. These groups will be important if you hope to solve all the Futoshiki test cases completely with logic, but they are not necessary if you plan to do backtracking with Algorithm X.</p> <p>What I am about to say should not be a surprise and I hope I have not made a mistake by not issuing a spoiler alert, but\u2026 the inequalities are really important. They are so important; I suggest you add another class to your object model.</p> <p></p> <p>Every <code>Inequality</code> needs two pointers. The first points to the <code>SudokuCell</code> that must be less than the other side. The second pointer points to the <code>SudokuCell</code> that must be greater than the other side. The only critical <code>Inequality</code> method is <code>reduce_()</code>.</p> <p>You will need to fill in the details of what it means to reduce an inequality. As you know, reduction in this type of puzzle is all about eliminating candidates from cells. What candidates can be eliminated from the cells on either side of the inequality based on the rules that govern how inequalities work?</p> <p>Finally, I will copy the exact reduction code structure from the earlier Sudoku discussion into the FutoshikiSolver class constructor.</p> <pre><code>        finished_reducing = False\n        while not finished_reducing:\n            finished_reducing = True\n            for inequality in self.inequalities:\n                if inequality.reduce_():\n                    finished_reducing = False\n</code></pre> <p>Test Case 2: Comparisons only horizontal and Test Case 3: Comparisons only vertical are the only two interesting test cases you can completely solve simply by reducing the problem space based on inequalities. However, this one small reduction effort puts Algorithm X in position to find solutions to all remaining test cases very fast.</p> <p>As I alluded to earlier, a bit more than just basic <code>SudokuGroup</code> reduction logic is necessary to solve all test cases strictly with logic, no guessing, but it is very doable. If you would like to take on that challenge, I will get you started with the reduction loop, which probably does not come as a surprise by now.</p> <pre><code>        finished_reducing = False\n        while not finished_reducing:\n            finished_reducing = True\n            for inequality in self.inequalities:\n                if inequality.reduce_():\n                    finished_reducing = False\n\n            for group in rows + cols:\n                if group.reduce_():\n                    finished_reducing = False\n</code></pre>"},{"location":"12-your-turn/03-futoshiki-solver/#solving-logic-puzzles-logically","title":"Solving Logic Puzzles Logically \ud83d\udcaf","text":"<p>Many Futoshiki puzzles can be solved without making any guesses. Click here to see my progress toward solving as many logic puzzles as possible, strictly with logic, no guessing.</p> <p></p>"},{"location":"12-your-turn/04-no-spoon-2/","title":"There Is No Spoon - Episode 2 (Revisited)","text":"<p>Puzzle: There Is No Spoon - Episode 2</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Strap in and hold on tight!</p>"},{"location":"12-your-turn/04-no-spoon-2/#reducing-the-problem-space","title":"Reducing the Problem Space","text":"<p>When we last discussed There is No Spoon \u2013 Episode 2, I left you with the following class diagram:</p> <p></p> <p>To do some problem-space reduction, it seems reasonable we will add a <code>reduce_()</code> method to one or more of the classes, but which ones? Distributing behavior to classes can be difficult and sometimes easy to argue one way or another. Let\u2019s look at each class individually.</p> <p><code>Intersection</code> - this seems like the least likely location for a <code>reduce_()</code> method. <code>Intersection</code>s have very little intelligence. They must be able to react to a single event sent by a <code>Channel</code> letting the <code>Intersection</code> know that a link has been placed and if there is another <code>Channel</code> in the intersection, it should be disabled.</p> <p><code>Channel</code> - this again seems like an unlikely location for a <code>reduce_()</code> method. What would it even mean to reduce a <code>Channel</code>? Sure, the <code>Channel</code> knows about the <code>Nodes</code> on either side, but that is not enough to know whether or not a link must be placed in the <code>Channel</code>. I see a <code>Channel</code> needing to be able to react to two events:</p> <ol> <li> <p>A <code>Node</code> might tell a <code>Channel</code> to place 1 or 2 links in its slots.</p> </li> <li> <p>A <code>Node</code> or an <code>Intersection</code> could send an event to disable a <code>Channel</code>. We already saw how this could happen with an <code>Intersection</code>. With a <code>Node</code>, links in other <code>Channel</code>s could bring the <code>Node</code>\u2019s needed links down to zero. At that point, all <code>Channel</code>s attached to that <code>Node</code> need to be disabled so they cannot accept more links.</p> </li> </ol> <p><code>Node</code> - this seems like a very appropriate place for a <code>reduce_()</code> method. A <code>Node</code> knows how many links it needs and it can easily calculate the total capacity of its <code>Channel</code>s. It seems very reasonable that reducing a <code>Node</code> could result in the <code>Node</code> asking one or more of its <code>Channels</code> to place 1 or 2 links in its slots.</p>"},{"location":"12-your-turn/04-no-spoon-2/#one-potential-sequence-of-events","title":"One Potential Sequence of Events","text":"<p>Based on everything said above, the following methods might be useful in each of the classes:</p> <p></p> <p>The next diagram captures one sequence of events that could result after a call to <code>reduce_()</code> on a particular <code>Node</code>. </p> <p></p> <p>A <code>Node</code> determines that a link can be placed in a <code>Channel</code>. The <code>Node</code> asks the <code>Channel</code> to place a link. The <code>Channel</code> sends an event to every <code>Intersection</code> it passes through telling each <code>Intersection</code> to make the path one-way. Any <code>Intersection</code> that has a second <code>Channel</code> sends a message to the second <code>Channel</code> to have that <code>Channel</code> disabled. Finally, the original <code>Channel</code> needs to tell the <code>Node</code>s on either end to lower their needed link counts appropriately. Any <code>Node</code> that has all its links fully satisfied makes sure its connected <code>Channel</code>s are all disabled.</p> <p>It might be tempting to think I made this harder than it needs to be. I invite you to play around with it. If you choose to create an object-oriented structure for this puzzle, you can easily run into issues caused by less than optimum allocation of behavior to your classes.</p>"},{"location":"12-your-turn/04-no-spoon-2/#building-a-partial-solution","title":"Building a Partial Solution","text":"<p>The same code structure can be used for the reduction loop:</p> <pre><code>need_to_reduce = True\nwhile need_to_reduce:\n    need_to_reduce = False\n    for node in self.nodes:\n        if node.reduce_():\n            need_to_reduce = True\n</code></pre> <p>Once this loop finishes, you are left with a partial solution. Some number of links have been placed between <code>Node</code>s and all those <code>Node</code>s have lowered their needed link totals. The remaining problem is a smaller, standalone version of the problem that can be solved with no knowledge of what has been accomplished with the logic above. This puzzle is a great candidate for the 3rd option I discussed many pages ago for handling preselected actions. I suggest the following:</p> <ol> <li> <p>Build a list of links placed with the logic above.</p> </li> <li> <p>Feed the remaining, smaller problem to Algorithm X with no knowledge of what was accomplished logically.</p> </li> <li> <p>Combine the original list of links with the solution Algorithm X finds to create an overall solution that can be validated to determine if you have a single group of linked <code>Node</code>s.</p> </li> </ol>"},{"location":"12-your-turn/04-no-spoon-2/#your-goal","title":"Your Goal","text":"<p>Using only problem-space reduction logic, no backtracking at all, you can solve test cases 1 \u2013 8 and 10. To solve all the test cases with Algorithm X, you will need to use some pre-backtracking logic to shrink the size of the problem you give to Algorithm X.</p>"},{"location":"12-your-turn/04-no-spoon-2/#solving-logic-puzzles-logically","title":"Solving Logic Puzzles Logically","text":"<p>Many Hashiwokakero (There is No Spoon - Episode 2) puzzles can be solved without making any guesses. Click here to see my progress toward solving as many logic puzzles as possible, strictly with logic, no guessing.</p> <p></p>"},{"location":"12-your-turn/05-takuzu-solver/","title":"Takuzu Solver","text":"<p>Puzzle: Takuzu Solver</p> <p>Author: @vinc-r</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Enjoyably Complex: A Bit of Everything Covered So Far</p>"},{"location":"12-your-turn/05-takuzu-solver/#limited-options","title":"Limited Options","text":"<p>Unlike many logic puzzles, Takuzu has very limited options. Each cell can be a <code>0</code> or a <code>1</code>. Solving a Takuzu is still challenging, but the limited cell options make it a bit easier to focus on problem-space reduction and setting up Algorithm X.</p>"},{"location":"12-your-turn/05-takuzu-solver/#algorithm-x-setup","title":"Algorithm X Setup","text":"<p>Let's start with an excerpt from the goal statement for the puzzle:</p> <p>The objective is to fill the grid with 1s and 0s, constraints are : - an equal number of 1s and 0s in each row and column - no more than two of either number adjacent to each other - no identical rows and no identical columns</p> <p>The basic Algorithm X requirements and actions seem straightforward. Every cell must be covered with a <code>0</code> or a <code>1</code>, while the actions are all putting a <code>0</code> or a <code>1</code> into some cell. Is everything truly as straightforward as it appears? Were you able to see the multiplicity in this puzzle?</p> <ul> <li>an equal number of 1s and 0s in each row and column</li> </ul> <p>If a row is 8 characters long and it already has two <code>0</code>s and one <code>1</code>, you know you must place an additional two <code>0</code>s and three <code>1</code>s in that row. This is textbook multiplicity.</p> <p>Mutual exclusivity is where Takuzu Solver gets very interesting. Any time you see something cannot happen, you should look for mutual exclusivity.</p> <ul> <li>no more than two of either number adjacent to each other</li> </ul> <p>The puzzle allows <code>00</code> or <code>11</code> to occur in a row or a column, but a series of 3 or more like numbers is not allowed. All discussions of mutual exclusivity so far have involved 2 items being mutually exclusive, but here we have 3 unknown items and our solver needs to make sure not to fill those cells with <code>000</code> or <code>111</code>. Maybe there is a way to address this, but if there is, I am not aware of it and this is a dead-end tangent.</p> <p>Although a pattern of <code>...</code> appears to be a dead end, what about a series of 3 cells where only one cell is known, for instance <code>..0</code>? You could put a zero in either unknown spot, but you cannot put a zero in both spots. This sounds much more in line with the Algorithm X mutual exclusivity discussed in this playground. Actually, it sounds just like Mrs. Knuth putting a loud instrument in one slot or the other, but not being allowed to put a loud instrument in both slots.</p>"},{"location":"12-your-turn/05-takuzu-solver/#algorithm-x-alone-no-problem-space-reduction","title":"Algorithm X Alone, No Problem-Space Reduction","text":"<p>You can solve the first 3 test cases with no problem-space reduction, only Algorithm X. You will need to override <code>AlgorithmXSolver</code>'s <code>_process_solution()</code> method to check your final grid for the following.</p> <ul> <li>no more than two of either number adjacent to each other</li> <li>no identical rows and no identical columns</li> </ul> <p>If you want to set Algorithm X up in steps, consider this. Even if you completely ignore mutual exclusivity, your solver will easily find solutions for Test Case 1: Test 4x4 and Test Case 2: Test 6x6. Without adding optional requirements to handle mutual exclusivity, I expect you will timeout on the 3rd test case.</p> <p>This puzzle is a great example of the power of mutual exclusivity. With decent problem-space reduction, you can pass all validators even if you completely ignore mutual exclusivity. However, if you want super fast solutions for every test case and every validator, mutual exclusivity is critical.</p>"},{"location":"12-your-turn/05-takuzu-solver/#problem-space-setup","title":"Problem-Space Setup","text":"<p>To solve all test cases and validators, you will need to do some problem-space reduction. Takuzu has a very similar structure to Sudoku. There are cells and those cells are grouped into rows and columns, but because the cells can only contain zeros and ones, I found little code I could reuse, other than the overall structure.</p> <p></p> <p>If you use this structure, setting up the grid, the rows and the columns is extremely similar to setting up a Sudoku.</p> <pre><code>class TakuzuSolver(AlgorithmXSolver):\n\n    def __init__(self, grid: List[List[str]]):\n\n        self.size = len(grid)\n        self.grid = {(r, c):TakuzuCell(r, c, val) for r, row in enumerate(grid) for c, val in enumerate(row)}\n        self.rows = [TakuzuGroup([self.grid[(r, c)] for c in range(self.size)]) for r in range(self.size)]\n        self.cols = [TakuzuGroup([self.grid[(r, c)] for r in range(self.size)]) for c in range(self.size)]\n</code></pre>"},{"location":"12-your-turn/05-takuzu-solver/#reducing-the-problem-space","title":"Reducing the Problem Space","text":"<p>The loop for problem-space reduction should look very familiar.</p> <pre><code>        need_to_reduce = True\n        while need_to_reduce:\n            need_to_reduce = False\n            for group in self.rows + self.cols:\n                if group.reduce_():\n                    need_to_reduce = True\n</code></pre> <p>I share this code again to demonstrate the power of a reusable approach to similar problems. You might come up with a completely different approach and that is perfectly okay. Keep in mind, there are many logic puzzles and a significant number of those puzzles are a grid of cells grouped into rows, cols, boxes, cages, etc. More generally,  a significant number of those puzzles are a grid of cells organized into groups. Whatever structure works for you, I invite you to look for opportunities to reuse the work you have already done.</p> <p>Unfortunately, this is where the similarities to Sudoku end! There is a lot of great problem-space reduction possible in Takuzu and the best place to start is again with the puzzle description.</p> <p>The objective is to fill the grid with 1s and 0s, constraints are: - an equal number of 1s and 0s in each row and column - no more than two of either number adjacent to each other - no identical rows and no identical columns</p> <p>The third bullet point does not help. Logical problem-space reduction is only concerned with finding pieces of the solution that must be part of a proper solution. Identical rows or columns are an indicator of an improper solution.</p> <p>The first two bullet points are the guidance you need to logically fill in more cells of the grid before Algorithm X begins searching for a full solution. There are plenty of techniques you can find to fill in unknown cells. You do not have to find them all to pass every test case and validator. However, if you are overcome by the sweet, sweet logic pulling at you like the Death Star's tractor beam, it might be best not to fight it.</p> <p>Wookieepedia- Tractor Beam</p>"},{"location":"12-your-turn/05-takuzu-solver/#solving-logic-puzzles-logically","title":"Solving Logic Puzzles Logically \ud83d\udcaf","text":"<p>Many Takuzu puzzles can be solved without making any guesses. Click here to see my progress toward solving as many logic puzzles as possible, strictly with logic, no guessing.</p> <p></p>"},{"location":"12-your-turn/06-suguru-solver/","title":"Suguru Solver (Revisited)","text":"<p>Puzzle: Suguru Solver</p> <p>Author: @Saur2000</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Sudoku Times Two</p>"},{"location":"12-your-turn/06-suguru-solver/#strategy","title":"Strategy","text":"<p>Suguru is full of wonderful opportunities for problem-space reduction. Just a couple of strategies will be enough to make your <code>SuguruSolver</code> very fast. If you are so inclined, you can solve many of the test cases and validators completely with logic.</p> <p>The cages make Suguru a bit tougher to get organized at first, but a <code>SuguruCell</code> is very similar to a <code>SudokuCell</code> and a <code>SuguruGroup</code> is very similar to a <code>SudokuGroup</code>. The key differences are the number of groups to which a cell belongs and the range of candidates for each cell. </p> <p></p> <p>Unless you are trying to build a generic logic puzzle structure, I see no need to inherit from a common class at this time, but you should be able to reuse some code. Ultimately, you will want to parse the input and end up with the following two attributes in your <code>SuguruSolver</code> class:</p> <pre><code>self.grid = dictionary of SuguruCell instances with each key being a (row, col) tuple\n\nself.cages = list of SuguruGroup instances, each with a list of pointers to the cells in the group\n</code></pre> <p>Once that is complete, you are ready for a standard reduction loop. Hopefully this sounds repetitive. Seeing the similarities in various problems and applying reusable problem solving techniques and design architectures can be a very powerful approach to your software engineering projects.</p>"},{"location":"12-your-turn/06-suguru-solver/#solving-logic-puzzles-logically","title":"Solving Logic Puzzles Logically","text":"<p>Many Suguru puzzles can be solved without making any guesses. Click here to see my progress toward solving as many logic puzzles as possible, strictly with logic, no guessing.</p> <p></p>"},{"location":"13-steering-algorithm-x/01-backseat-driving/","title":"This Road is a Dead End","text":"<p>You and a friend are driving from one side of Switzerland to the other. Your friend is driving while you study the map. Your friend turns down a road that your map clearly indicates is a dead end. Do you say anything?</p> <p>Of course, the answer is, \u201cIt depends.\u201d Your friend might be the kind of person that cannot tolerate a backseat driver. Your friend may be convinced the map is wrong. (I\u2019m ashamed to admit I have been that friend.) However, if you share the goal of getting to your destination quickly, you let your friend know the current path is a dead end and you change course.</p> <p>It is sometimes not possible to give Algorithm X every bit of knowledge necessary to find solutions with maximum speed. We only have requirements, optional requirements and actions with which to work. Some knowledge just doesn\u2019t fit into those parameters.</p> <p>Many pages ago, we discussed the matrix Algorithm X uses to find solutions. The columns are the requirements while the rows are the actions. Algorithm X uses backtracking to find a set of rows that exactly covers the primary columns. In Mrs. Knuth - Part III, a few lines of code were added to override the <code>AlgorithmXSolver</code> method <code>_process_row_selection()</code> and ask Algorithm X to \u201cremember\u201d certain combinations it had already tried. Here, I will override this method again, but this time I will add logic to determine if Algorithm X is headed for a dead end and needs to be redirected to a better path.</p> <p>Each time Algorithm X selects a row to be part of a potential solution, a call is made to <code>_process_row_selection()</code>. In the following code, the <code>AlgorithmXSolver</code> subclass overrides the <code>_process_row_selection()</code> method and adds a very small amount of logic to update the state of the problem space and redirect Algorithm X if necessary. The pseudocode looks like this:</p> <pre><code>    def _process_row_selection(self, row):\n        action variables = unpack the row\n        update the state of the problem space to include the selected action\n        if the problem space is no longer valid:\n            self.solution_is_valid = False\n</code></pre> <p>If you implement this approach, your solver subclass must also override the method <code>_process_row_deselection()</code> to \u201cundo\u201d what was done when the row was selected. The pseudocode looks like this:</p> <pre><code>    def _process_row_deselection(self, row):\n        action variables = unpack the row\n        update the state of the problem space to \"undo\" the selected action\n</code></pre> <p>This is a very minimal amount of code that can provide tremendous horsepower to Algorithm X. To see how it works, let\u2019s take a closer look at the puzzle, High-Rise Buildings.</p> <p></p>"},{"location":"13-steering-algorithm-x/02-high-rise-buildings/","title":"High-Rise Buildings","text":"<p>Puzzle: High-Rise Buildings</p> <p>Author: @dwarfie</p> <p>Published Difficulty: Very Hard</p> <p>Algorithm X Complexity: Setting Up Algorithm X is the Easy Part</p>"},{"location":"13-steering-algorithm-x/02-high-rise-buildings/#strategy","title":"Strategy","text":"<p>As you get more and more experienced with Algorithm X, puzzles like High-Rise Buildings should be screaming to you, \u201cSolve me with Algorithm X!\u201d Let\u2019s consider the toy example and the puzzle rules from the goal section.</p> <p></p> <p>Given a grid of dimension NxN, you must build towers on each square in such a way that: - The heights of the towers range from 1 to N; - Each row contains every possible height of tower exactly once; - Each column contains every possible height of tower exactly once; - Each numeric clue describes the number of towers that can be seen if you look into the square from that position.</p> <p>Did I read that correctly? The puzzle goal couldn\u2019t be any clearer about the requirements for Algorithm X.</p> <p>build towers on each square</p> <p>Each row contains every possible height of tower exactly once;</p> <p>Each column contains every possible height of tower exactly once;</p>"},{"location":"13-steering-algorithm-x/02-high-rise-buildings/#every-story-needs-a-hero","title":"Every Story Needs a Hero","text":"<p>If anything, the last rule is the most challenging. For an <code>N</code> x <code>N</code> square, there are <code>4 * N</code> \u201cpositions\u201d from which you can look into the square. A clue is given for each viewing position indicating how many buildings can been seen. Each building blocks the view of any shorter buildings behind it. In the diagram below, the superhero has a view into the city from the top left-side position.</p> <p></p> <p>In the next diagram, two different superheroes have views into the city from two different positions.</p> <p></p> <p>These superheroes are not important, but they illustrate a point. From the perspective of a superhero, there is no difference between one viewing position and another viewing position. Each view into the city has:</p> <ol> <li> <p>A number of buildings that can be seen from that position.</p> </li> <li> <p>A list of buildings ordered from closest to furthest away.</p> </li> </ol> <p>I will call each of the <code>4 * N</code> viewing positions a <code>CityView</code>. If you think about it, the layout of this puzzle is incredibly similar to every grid-based logic puzzle we have already looked at. There is some number of cells and some number of groupings of those cells. Once again, I suggest you use the exact same code structure to create a dictionary of all cells and then create a list of all the cell groups. To honor the puzzle's storyline, I will use the class names <code>Building</code> and <code>CityView</code> instead of a variation of <code>Cell</code> and <code>Group</code> like what was done multiple times before.</p> <p></p> <p>Finally, you could override your solver's <code>_process_solution()</code> method and make sure every <code>CityView</code> is valid. Using this approach, I am able to solve Test Case 2: Test 2 well within the time limit, but I time out on the other test cases. Can you guess what we might do to increase speed?</p> <p></p>"},{"location":"13-steering-algorithm-x/03-high-rise-buildings-cont/","title":"High-Rise Buildings (cont.)","text":"<p>For some problems, it is beneficial to keep track of an updated problem space so Algorithm X can be guided away from dead ends. High-Rise Buildings is a perfect candidate puzzle for this strategy.</p> <p>Each time Algorithm X chooses a row from the matrix to make part of the solution, we will update the grid of the city to reflect the height assigned to one of the buildings. If any part of the grid indicates one of the <code>CityView</code>s is invalid, Algorithm X can be redirected.</p> <p>I am making a bit of an assumption that you came up with the same actions for Algorithm X that I believe are necessary. What are the tiles that can be placed on the gameboard? The only option for those tiles I see is that each tile is a height that is assigned to a building by putting that tile on one of the gameboard's <code>(row, col)</code> coordinates. Building on that assumption, the next step is to override the following two <code>AlgorithmXSolver</code> methods.</p> <pre><code>    def _process_row_selection(self, row):\n        action variables (most importantly height, row and col) = unpack the row\n        building at (row, col) height = height\n        if any affected CityView is no longer valid:\n            self.solution_is_valid = False\n\n\n    def _process_row_deselection(self, row):\n        action variables (most importantly row and col) = unpack the row\n        building at (row, col) height = 0\n</code></pre> <p>Remember, there is never a need to reset <code>self.solution_is_valid</code> to <code>True</code>. <code>AlgorithmXSolver</code> will backtrack as soon as it sees a <code>False</code> value that indicates the current path is a dead end. Backtracking always returns to a valid state and <code>AlgorithmXSolver</code> automatically returns <code>self.solution_is_valid</code> to <code>True</code>.</p>"},{"location":"13-steering-algorithm-x/03-high-rise-buildings-cont/#maximizing-speed","title":"Maximizing Speed","text":"<p>To maximize your speed, consider adding a bit of problem-space reduction. It can be challenging to logically determine the heights of many buildings, but you should be able to limit the candidate heights enough to make your solution very fast for all test cases.</p> <p></p>"},{"location":"14-your-turn/01-killer-sudoku/","title":"Killer Sudoku Solver","text":"<p>Puzzle: Killer Sudoku Solver</p> <p>Author: @odaxav</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Would You Like a Bit of Everything???</p>"},{"location":"14-your-turn/01-killer-sudoku/#strategy","title":"Strategy","text":"<p>Killer Sudoku seems easy enough. It is just Sudoku with one twist. The cells of the Sudoku grid are grouped into cages that must sum to a given amount. No problem, right?</p> <p>This puzzle is extremely interesting, especially when you look at Test Case 4: Expert where the entire grid is initially empty. We know Algorithm X can easily solve a Sudoku, so how about having Algorithm X generate every possible Sudoku grid until one is generated that does not violate any of the given cage sums? There is a tiny problem with that approach. According to Brittanica.com:</p> <p>There are 6,670,903,752,021,072,936,960 possible solvable Sudoku grids that yield a unique result (that\u2019s 6 sextillion, 670 quintillion, 903 quadrillion, 752 trillion, 21 billion, 72 million, 936 thousand, 960 in case you were wondering). That's way more than the number of stars in the universe.</p> <p>Unless you have a tremendous amount of computing power and a good amount of time on your hands, some problem-space reduction will be critical.</p> <p>More than any puzzle covered so far, this puzzle can be attacked in many ways. First, you need a good set of requirements and actions. Since Killer Sudoku extends the traditional Sudoku, you should be able to reuse much of your previous work. After that, you have a lot of options, but ultimately, you will need some combination of the following:</p> <ol> <li> <p>You could add some optional requirements.</p> </li> <li> <p>There is an opportunity to add optional requirements to handle mutual exclusivity.</p> </li> <li> <p>You could reuse your Sudoku problem-space reduction.</p> </li> <li> <p>You could add problem-space reduction based on cages.</p> </li> <li> <p>You could validate cage sums when solutions are generated.</p> </li> <li> <p>You could validate cage sums along the way so you can redirect Algorithm X when necessary.</p> </li> </ol> <p>No idea above is significantly more important than the rest. I suggest you experiment with them all until you find a solution fast enough to solve all the test cases.</p>"},{"location":"14-your-turn/01-killer-sudoku/#suggested-path-forward","title":"Suggested Path Forward","text":"<p>To get started, I recommend you work on setting up Algorithm X with no problem-space reduction at all. A basic Sudoku Algorithm X setup will quickly solve Test Case 1: Easy and Test Case 2: Medium. Of course, you will need to make sure all the cage sums are properly honored. From there it gets more challenging.</p> <p>A hardcore Algorithm X setup will quickly solve Test Case 3: Hard, and you might eke out a solution for Test Case 4: Expert before timing out. To solve the 4th test case in a more reasonable amount of time requires some problem-space reduction.</p> <p>Everything you learn on this puzzle will help you finish the next two puzzles, Kakuro Solver and Killer Sudoku Extreme Challenge. If you want to get a head start on the next two puzzles, I suggest spending some time here on reducing cages. Your ability to reduce cages will be critical on both of the next two puzzles.</p>"},{"location":"14-your-turn/01-killer-sudoku/#solving-logic-puzzles-logically","title":"Solving Logic Puzzles Logically \ud83d\udcaf","text":"<p>All Killer Sudoku puzzles can be solved without making any guesses. Click here to see my progress toward solving as many logic puzzles as possible, strictly with logic, no guessing.</p> <p></p>"},{"location":"14-your-turn/02-kakuro-solver/","title":"Kakuro Solver","text":"<p>Puzzle: Kakuro Solver</p> <p>Author: @Q12</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Algorithm X Setup Is a Subset of Killer Sudoku</p>"},{"location":"14-your-turn/02-kakuro-solver/#strategy","title":"Strategy","text":"<p>To solve Kakuro Solver, you need to do more problem space reduction than you have done for any puzzle so far. The cell groups must add up to certain numbers, but other than that, you have very little with which to work.</p> <p>Consider Example 1 from the puzzle goal. The Kakuro grid is a 3x3 grid, but only 4 of the 9 cells need to be determined. The other 5 cells are either unused or informational. The important part of a Kakuro is how the cells are grouped together and what the sum of each group needs to be.</p> <p></p> <p>The next graphic summarizes all important information on the Kakuro grid in a way that resembles the cell and group approach we have used many times before.</p> <p></p> <p>It might be helpful to keep a copy of the original Kakuro 3x3 grid considering the output needs all elements of the 3x3 grid, including proper values for the 4 empty cells.</p>"},{"location":"14-your-turn/02-kakuro-solver/#tougher-input-to-parse","title":"Tougher Input to Parse","text":"<p>The input for Kakuro Solver is a bit challenging, but I encourage you to make your goal to copy what has been done on every logic puzzle so far. A dictionary is used to store pointers to all the cells of the grid and a list is used to hold pointers to all the groups.</p> <p>This puzzle validates the choice of a dictionary for the grid over any type of 2-dimensional array. Why? The only important cells to put in the dictionary are cells in the Kakuro grid that are either empty or already contain a number. A number of cells in the Kakuro grid are used to tell us how to group cells and what the sum of the cells in the group must be. The information obtained from those cells is used to build the groups, but that information never changes. There is no need to store these cells in the dictionary.</p> <ol> <li> <p>Parse the input, creating instances of a <code>KakuroCell</code> in the <code>self.grid</code> dictionary. </p> </li> <li> <p>Parse the input again, this time looking for locations in the Kakuro input that indicate how to group the cells and the sum of each group. Create a new group with a list of pointers to the cells in the group.</p> </li> </ol>"},{"location":"14-your-turn/02-kakuro-solver/#sum-of-a-group-of-cells","title":"Sum of a Group of Cells?","text":"<p>Unlike many of the puzzles covered so far, the goal statement does not give a name to the groups of cells. The puzzle statement tells us:</p> <p>Rules: - All empty cells need to be filled in with digits, in such a way that all the given sums are respected. - You are not allowed to use the same digit more than once to obtain a given sum.</p> <ul> <li>Cell with backslash : the required sum of the corresponding cells.</li> <li>X\\ : the vertical sum X of the cells downwards,</li> <li>\\X : the horizontal sum X of the cells to the right,</li> <li>X\\Y : the vertical sum X of the cells downwards, and the horizontal sum Y of the cells to the right.</li> </ul> <p>Do you see the similarities between these groups and the cages you just explored in Killer Sudoku Solver? What are the differences?</p> <p>One difference is that in Kakuro, the groups are either a horizontal line of cells or a vertical line of cells. Although this is true, it is not meaningful. In Killer Sudoku, all cells of a cage could also be in a line vertically or horizontally.</p> <p>Another difference is that in Kakuro, a single cell could be part of two different groups. Again, this is not a meaningful difference. In both puzzles, all that matters is that the cells add up to a certain value and the numbers in the group do not repeat.</p> <p>Groups in Kakuro are 100% identical to cages in Killer Sudoku. Hopefully you got a good start on reducing these cages. Regardless of how much cage reduction you have already implemented, my guess is you now will need more.</p>"},{"location":"14-your-turn/02-kakuro-solver/#suggested-path-forward","title":"Suggested Path Forward","text":"<p>The big-picture structure of your code can be exactly the same as what you wrote for High-Rise Buildings and Killer Sudoku Solver.</p> <ul> <li> <p>Create a dictionary of cells.</p> </li> <li> <p>Create a list of cages.</p> </li> <li> <p>Reduce the cell candidates using what you know must be true about the cages.</p> </li> <li> <p>Run Algorithm X.</p> <ul> <li> <p>Update cells when Algorithm X selects/deselects rows.</p> </li> <li> <p>Validate cages and redirect Algorithm X as necessary.</p> </li> </ul> </li> </ul> <p>Start by setting up Algorithm X with no problem-space reduction. A basic Algorithm X setup with requirements and actions will quickly solve the first 6 test cases assuming you properly validate all the cages. A slightly more dialed-in Algorithm X setup might solve all the first 9 test cases, but you could see a few timeout issues. A hardcore Algorithm X setup will solve the first 9 test cases without ever getting close to the time limit. To solve Test Case 10: Test 10 (7 * 7), you will need to do some problem space reduction.</p> Spoiler Alert: What is meant by a \"slightly more dialed-in\" Algorithm X setup? <p>Cages cannot have duplicate numbers. Are you using optional requirements to make sure numbers are not duplicated in a cage? If you need to refresh your memory, go back and revisit the way Mrs. Knuth made sure instruments did not repeat on any day.</p> Spoiler Alert: What is meant by a \"hardcore\" Algorithm X setup? <p>Cages present significant opportunity for optional requirements to handle mutual exclusivity. Adding these me_requirements will add significant speed to Algorithm X. Is there a way to determine that placing a number in a cell makes it impossible to place another number in another cell? Remember, you are looking for knowledge that is not already captured by existing requirements, such as no duplicate numbers allowed in a cage.</p>"},{"location":"14-your-turn/02-kakuro-solver/#solving-logic-puzzles-logically","title":"Solving Logic Puzzles Logically","text":"<p>Many Kakuro puzzles can be solved without making any guesses. Click here to see my progress toward solving as many logic puzzles as possible, strictly with logic, no guessing.</p> <p></p>"},{"location":"14-your-turn/03-killer-sudoku-extreme/","title":"Killer Sudoku Extreme Challenge","text":"<p>Puzzle: Killer Sudoku Extreme Challenge</p> <p>Author: @Timinator</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: It Depends</p>"},{"location":"14-your-turn/03-killer-sudoku-extreme/#strategy","title":"Strategy","text":"<p>In Killer Sudoku Extreme Challenge, your algorithm needs to solve up to 40 Expert Killer Sudoku grids. You will need to do everything you did to solve the original Killer Sudoku Solver puzzle and more. You must find some amount of problem-space reduction that makes each grid fairly easy for Algorithm X. When solving 40 puzzles, there is not enough time for Algorithm X to do too much backtracking.</p>"},{"location":"14-your-turn/03-killer-sudoku-extreme/#solving-every-grid-logically","title":"Solving Every Grid Logically \ud83d\udcaf","text":"<p>Backtracking involves making a guess and then backing up if that guess leads to a dead end or the path has been fully explored. It is possible to solve every Killer Sudoku grid in the puzzle without making a single guess. In the original puzzle, did you use a class structure similar to this?</p> <p></p> <p>A <code>SudokuGroup</code> could be a row, a column or a box. All <code>SudokuGroup</code>s behave identically. <code>Cage</code>s are another way to group cells and these groups have significantly different behavior which calls for a separate class. If you study how cells behave on a Killer Sudoku grid, you will find even more interesting behavior that can help you find the values of more unknown cells. For an example, click below.</p> Spoiler Alert: Creating Even More Groups for Killer Sudoku <p>A Cage is a group of cells that must add up to a certain amount. There are other groups of cells that also must add to a certain amount. For instance, all rows, all columns and all boxes add up to 45 since they each must contain the numbers 1 to 9. That is not all that interesting, nor helpful. However, there are more interesting groups of cells that must add up to certain amounts. Can you find those groups?</p> <p>All Killer Sudoku grid in each test case can be solved without making any guesses. Click here to see my progress toward solving as many logic puzzles as possible, strictly with logic, no guessing.</p> <p></p>"},{"location":"14-your-turn/04-tetris-floor/","title":"Tetris Floor","text":"<p>Puzzle: Tetris Floor</p> <p>Author: @cedricdd</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Algorithm X Can Be a Very Reasonable Part of a Very Complex Puzzle</p>"},{"location":"14-your-turn/04-tetris-floor/#strategy","title":"Strategy","text":"<p>In Tetris Floor, the goal is to cover the floor using only tiles of 7 distinct shapes. Each tile can be rotated before it is put on the floor. The first step toward setting up Algorithm X will be identifying an exhaustive list of possible actions. For each of the 7 block types, you need to identify every location on the floor where a block of that type could be placed and you need to take rotation into consideration. If you are unsure how to make this happen, I suggest reviewing what you implemented on Three Little Piggies.</p> <p>Once you have Algorithm X finding solutions, you need to determine the cheapest solution. You could begin by overriding <code>_process_solution()</code> to calculate the cost of each solution just like you did in Mrs. Knuth \u2013 Part III. One look at the test cases and you will realize you probably need to do some course correction with Algorithm X. Fortunately, you built the skills necessary to keep track of partial solutions and provide corrective feedback when you completed High-Rise Buildings.</p> <p>If you use Algorithm X, it will be just part of a fairly complex solution. You will need to implement several clever problem-space reduction techniques. The test cases are well designed, and they will lead you down a path that might seem to always end in a timeout. Use the early test cases to make sure you have a strong Algorithm X setup. The later test cases will then come down to finding ways to make the problem easier before asking Algorithm X to find solutions.</p> <p>I am not 100% convinced Algorithm X is the best way to approach this puzzle, but it is doable. I will avoid any spoilers and leave it at that.</p> <p></p>"},{"location":"15-coloring-your-requirements/01-coloring-your-requirements/","title":"Coloring Your Requirements","text":"<p>In his book, Donald Knuth identifies a category of problems where it is not only important to know which requirements have been covered, but also to know \u201chow\u201d those requirements have been covered. He proposes that sometimes requirements can be covered with a \u201ccolor\u201d, and if the color remains the same, certain requirements can be covered any number of times.</p> <p>Going back to the analogy of tiles on a gameboard, the concept of coloring allows tiles to overlap. However, it is critical that the tiles be identical at the point of overlap. In his book, Knuth uses an example of building a word search puzzle. Given a list of words and a grid, put all the words on the grid with a certain amount of overlap.</p>"},{"location":"15-coloring-your-requirements/01-coloring-your-requirements/#example-constructing-a-word-search","title":"Example: Constructing a Word Search","text":"<p>Constructing a word search is a great fit for Algorithm X, until we get to the overlapping locations. What are the requirements of the exercise? Each word must be placed somewhere on the grid. Are there any optional requirements? Each square of the grid may be covered by a letter, or it may be left empty, later to be filled with a letter that is not part of the solution. What about actions? Each action is simply putting a word on the grid at a specified location and in a specified direction.</p> <p>What about the requirements satisfied by each action? A word has been placed on the grid and a certain number of cells have been covered. But what about multiple words that overlap? Two words that overlap are each placed on the grid by a separate action and each of those actions covers the cell where the overlap occurs.</p> <p>You might be tempted to see this as an instance of multiplicity as discussed earlier, but there is a slight difference. In this example, each cell could be left uncovered or it could be covered multiple times, as long as it is covered, or colored, by the same letter each time. For all multiplicity examples discussed previously, certain requirements needed to be covered an exact number of times.</p>"},{"location":"15-coloring-your-requirements/01-coloring-your-requirements/#algorithm-c","title":"Algorithm C","text":"<p>Knuth proposes Algorithm C to solve exact cover problems that include the coloring of requirements. I am not going to cover Algorithm C here, but on the next page, I will show you how to easily customize <code>AlgorithmXSolver</code> to handle the coloring of requirements.</p> <p></p>"},{"location":"15-coloring-your-requirements/02-constructing-a-word-search/","title":"The Algorithm X Matrix is Binary","text":"<p>Let's revisit the challenge of constructing a word search. Given a list of words and a grid of a certain size, what are the requirements?</p> <ol> <li> <p>Each word must be placed on the grid.</p> </li> <li> <p>Each location may be used zero to many times, and if it is used more than once, it must always be covered, or colored, with the same letter.</p> </li> </ol> <p>The first set of requirements is easy. These requirements fit perfectly into the paradigms discussed earlier in this playground. The second set of requirements is troublesome. There is no way to know how many words will intersect at a single location on the grid and some sort of checking must be done to ensure grid locations are only colored a single way. From the perspective of words being placed on the grid, the following can be observed:</p> <ul> <li> <p>Each grid location may be covered by 0 or more words.</p> </li> <li> <p>Any location covered by 2 or more words must be colored with the same letter by each word.</p> </li> </ul> <p>These non-binary stipulations do not fit into an Algorithm X matrix where everything is binary. The solution is to customize <code>AlgorithmXSolver</code> to monitor these non-binary requirements outside the Algorithm X matrix.</p>"},{"location":"15-coloring-your-requirements/02-constructing-a-word-search/#requirements","title":"Requirements","text":"<p>The binary requirements can first be put into the Algorithm X matrix. For the word search construction exercise:</p> <pre><code>requirements = [('word placed', word) for word in word_list]\n</code></pre> <p>For the non-binary requirements that can be colored, add an attribute to your solver subclass to keep track of the color assignments. There are many ways you could do this. For this example, I will use a <code>dictionary</code> where the grid locations are the <code>key</code>s and each <code>value</code> is a <code>list</code>. Every time a location is covered by a word, the letter that colors the location is added to the <code>list</code>. A cell that has an empty <code>list</code> may be covered by any color (letter). A cell that has a non-empty <code>list</code> can only be covered again properly if the new color matches what is already in the <code>list</code>.</p> <pre><code>self.location_colors = {(r, c):[] for r in range(height) for c in range(width)}\n</code></pre> <p>Finally, logic must be added to ensure coloring requirements are obeyed.</p>"},{"location":"15-coloring-your-requirements/02-constructing-a-word-search/#adding-coloring-logic-to-your-solver","title":"Adding Coloring Logic To Your Solver","text":"<p>Each time a row is selected, logic must be added to check the coloring of each grid cell covered by the word being placed on the grid. This is accomplished by overriding the <code>AlgorithmXSolver</code> <code>_process_row_selection()</code> method to do the following:</p> <ol> <li> <p>Update the coloring of any covered grid location.</p> </li> <li> <p>Redirect Algorithm X if any color violations have occurred.</p> </li> </ol> <p>The pseudocode looks like this:</p> <pre><code>    def _process_row_selection(self, row):\n        word and location = unpack the row\n        for each letter in the word:\n            if self.location_colors[location] not empty and letter is inappropriate:\n                self.solution_is_valid = False\n\n            self.location_colors[location].append(letter)\n</code></pre> <p>The last line above might be a little confusing. Why is the letter being added to the <code>list</code> even if the coloring was inappropriate and <code>self.solution_is_valid</code> was set to <code>False</code>? Backtracking can happen naturally or it can be forced because the current path is not valid. Either way, backtracking will \"undo\" the most recent row processing which means popping the most recent addition out of the <code>location_colors</code> <code>list</code>. This cleanup is accomplished by overriding the <code>AlgorithmXSolver</code> <code>_process_row_deselection()</code> method as follows:</p> <pre><code>    def _process_row_deselection(self, row):\n        word and location = unpack the row\n        for each location covered by the word:\n            remove the most recent addition to self.location_colors[location]\n</code></pre>"},{"location":"15-coloring-your-requirements/02-constructing-a-word-search/#putting-it-all-together","title":"Putting It All Together","text":"<p>If you have completed even a handful of puzzles so far using <code>AlgorithmXSolver</code> and the code structures detailed in this playground, you have noticed the code looks very similar every time. Hopefully, creating an <code>AlgorithmXSolver</code> subclass that incorporates these minor customizations to facilitate coloring is easy and straightforward. Of course, you\u2019ll need to implement all the pseudocode. </p> If you run into difficulty\u2026 <p>The next section on all-or-none sets of events contains a detailed implementation with coloring that might help with general structure.</p>"},{"location":"15-coloring-your-requirements/02-constructing-a-word-search/#tremendous-power-from-minimal-effort","title":"Tremendous Power From Minimal Effort","text":"<p>It is much more difficult to find research done on Algorithm C or the coloring of requirements than it is to find material on Algorithm X. One way or another, modifications must be made to Algorithm X if you wish to handle requirements that can be colored. The technique laid out above requires a minimal amount of customization to your solver subclass and provides tremendous power. In the next section, I will identify puzzles with which you can employ this newfound power!</p> <p></p>"},{"location":"16-your-turn/01-yet-another-word-search/","title":"Ye_ An_th_r W_rd Se_rch","text":"<p>Puzzle: Ye_ An_th_r W_rd Se_rch</p> <p>Author: @Timinator</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Donald Knuth Would Be Proud</p>"},{"location":"16-your-turn/01-yet-another-word-search/#strategy","title":"Strategy","text":"<p>The information covered on the previous two pages should make this puzzle fairly straightforward. You need to find hidden words in a word search puzzle. The only catch is that some, or maybe many\ud83d\ude00, of the letters are illegible. Considering what has already been covered, there isn't too much more I can say without completely giving the solution away.</p> Spoiler Alert: Only click here if you really need help. <p>I'm not kidding. This puzzle will get significantly easier if you click below. Are you sure this is what you want?</p> I'm positive. Give me the deets! <p>I feel bad about this. I don't like the idea of just giving the solution away.</p> But, if you're sure... <p>This is your last chance to change your mind...</p> I refuse to change my mind. Show me the money! <p>Thinking of this puzzle as a word search is a painful road to travel. Instead, think of this puzzle as a word search construction puzzle. Given a list of words and a partially filled-in grid, you must construct a word search that fits within the parameters defined by the prefilled cells. In this puzzle, you must create a solution for the word search construction example Knuth uses in his book to discuss the topic of \u201ccoloring\u201d. The coloring discussion in the previous section should be enough to guide you to a solution!</p> <p></p>"},{"location":"16-your-turn/02-agent-x-mission-2/","title":"Agent X, Mission 2 \u2014 Mysterious Cryptogram","text":"<p>Puzzle: Agent X, Mission 2 \u2014 Mysterious Cryptogram</p> <p>Author: @Jnath</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Very Hard or Not Too Bad, Your Choice</p>"},{"location":"16-your-turn/02-agent-x-mission-2/#strategy","title":"Strategy","text":"<p>Let\u2019s begin with an excerpt from the puzzle statement:</p> <p>Your objective is to use a register of N words and a message (ciphertext), encrypted with a substitution table that you don't know, to find the decrypted message (plaintext) and part of the substitution table. Not every word in the register is in the message, but all words in the message are in the register.</p> <p>For clarity, let\u2019s assume the ciphertext has been parsed into a set of unique cipher words, leaving us with a list of cipher words and list of register words. Secondly, let\u2019s assume sets of occurring letters have been compiled giving us a set of all cipher letters and a set of all register letters. I am using the term \u201cletters\u201d instead of \u201ccharacters\u201d because the problem states \u201csubstituted characters are only letters\u201d.</p> <p>The following are easily pulled from the above statements:</p> <ul> <li> <p>Requirements: Every cipher word must be mapped to exactly one register word.</p> </li> <li> <p>Optional Requirements: Each register word might remain unused or it may be mapped to exactly one cipher word.</p> </li> </ul> <p>Ultimately, mapping the register words to the cipher words results in a substitution matrix that maps cipher letters to register letters. It is tempting to say:</p> <ul> <li> <p>Requirements: Every cipher letter must be mapped to exactly one register letter.</p> </li> <li> <p>Optional Requirements: Each register letter might remain unused or it might be mapped to exactly one cipher letter.</p> </li> </ul>"},{"location":"16-your-turn/02-agent-x-mission-2/#avoid-the-temptation","title":"Avoid The Temptation!","text":"<p>Although both statements above are accurate, taking a step back and looking at the tiles and the gameboard is helpful here. The gameboard is nothing more than a list of cipher words. The tiles are the register words. One-by-one, tiles are placed on the gameboard, but each tile covers several of the \u201cletter requirements\u201d depending on  the number of letters in the word. When you consider how many tiles a single letter might appear on, it becomes clear that the letter requirements above might be candidates for coloring.</p> <p>After all mappings are complete, both letter-mapping requirements above are true, but during the process of placing tiles on the gameboard, each letter requirement could be covered many times. To find a proper solution, all the colorings across every covering must be consistent.</p> <p>Remember, the Algorithm X matrix is binary data. Requirements that can be covered many times do not fit into the binary mold. In the multiplicity section of this playground, we discussed a strategy for requirements that must be covered a certain number of times. Now, we have a new category of requirements that can be covered an arbitrary number of times and the way they are covered (the color applied to the requirement) must be consistent.</p>"},{"location":"16-your-turn/02-agent-x-mission-2/#tiles-on-a-gameboard","title":"Tiles on a Gameboard","text":"<p>Consider the following gameboard visual for the Example Test Case, which shows a group of cipher words and a group of register words. Each action takes a register word and tries matching it to a cipher word of equal length.</p> <p></p> <p>It appears everything needed is on the gameboard, but with these types of problems, it is often necessary to look at the gameboard from a different perspective. The next diagram contains a second view of the gameboard. A set of letters found across the cipher words and a set of letters found across the register words has been added.</p> <p></p> <p>The next diagram shows the full effect of matching one register word to one cipher word. Each time a word pair is created, the letters of each word need to be dropped on their counterparts in the bottom right. The next cipher-word-register-word pair can drop letters on letters that have not been colored with a counterpart letter, but if the counterpart already has a tile present, the new letter tile must match.</p> <p></p>"},{"location":"16-your-turn/02-agent-x-mission-2/#consistency-is-key","title":"Consistency Is Key","text":"<p>It can be challenging to visualize an Exact Cover problem that requires coloring. In the previous diagrams, think of the two sets of letters in the bottom right as the Color Police. When the gameboard is first considered, these groups are often not obvious, but at some point in the gameboard exploration, a need for consistency arises. This need is a telltale sign, it is time to consider adding the Color Police to your gameboard.</p>"},{"location":"16-your-turn/02-agent-x-mission-2/#setting-up-your-solver","title":"Setting Up Your Solver","text":"<p>If you love repeatability, take a break from your work right now. Get up, open a window and yell for all the world to hear, </p> \ud83d\udd25\ud83d\udd25\ud83d\udd25  I LOVE REPEATABILITY!  \ud83d\udd25\ud83d\udd25\ud83d\udd25 <p>To set up your solver, follow the exact instructions presented just a few short pages ago. Of course, you will need to handle two distinct sets of letters. You might choose to keep it simple and add two attributes to your solver or you might wish to be clever and implement the color police with a single <code>dictionary</code>.</p>"},{"location":"16-your-turn/02-agent-x-mission-2/#minor-spoiler","title":"Minor Spoiler","text":"I was able to speed up my solution by doing this... <p>Because significant attention is paid to the cipher letters and the register letters, the optional requirements end up being excess baggage for Algorithm X. They are completely legitimate and there is nothing wrong with leaving them where they are, but you may want to compare run times with and without them. In many puzzles, removing legitimate requirements is not a good idea, but in a situation like this, the word requirements and the letter requirements have some overlap that allows for the optional requirements to be omitted.</p> <p></p>"},{"location":"16-your-turn/03-agent-x-mission-2-cont/","title":"I Thought There Was a Choice To Be Made","text":"<p>On the previous page, I indicated the Algorithm X setup could be \u201cVery Hard or Not Too Bad, Your Choice\u201d. In this section, I will cover the harder option.</p> <p>Coloring is a great fit for Agent X, Mission 2. This playground has explored a significant number of puzzles well before coloring was even introduced, but sometimes, coloring is a far superior option. To really get a feel for coloring vs non-coloring, it can be powerful to solve a problem both ways.</p> <p>The first puzzle covered in this section was building a word search. I have a few ideas in regard to how that puzzle could be approached purely with Algorithm X, but each of those ideas feels like climbing an enormous mountain. This Agent X, Mission 2 puzzle is a different story. Although the climb is strenuous, there is much to be learned by solving this puzzle with and without coloring.</p>"},{"location":"16-your-turn/03-agent-x-mission-2-cont/#solving-agent-x-mission-2-without-coloring","title":"Solving Agent X, Mission 2 Without Coloring","text":"<p>Coloring allows us to easily model and implement things that must be the same or situations where consistency is crucial. How else can we model things that must be the same? Based on what must be the same, we can identify everything that must be different. This technique was detailed in the discussion for Einstein's Riddle Solver.</p> <p>Let\u2019s consider how this puzzle can be solved without coloring. Since we will strictly use the requirements, optional requirements and actions of Algorithm X, actions cannot involve placing one register word on one cipher word. Instead, we must be more granular and make all actions assign one register letter to one cipher letter. Cipher letters are either covered, or they are not. Register letters are either used, or they are not. All cipher letters must be covered. All register letters may be used. Everything is binary and suitable for Algorithm X.</p> <p>Mutual Exclusivity allows Algorithm X to easily ensure certain situations do not happen. In order to determine what must not happen in this puzzle, it is necessary to first identify what could happen. Once again, consider the Example Test Case. Go through each combination of words and build a catalog of what is possible. On the previous page, the gameboard shows the register word <code>PART</code> being mapped to the cipher word <code>TIFS</code>. This is a legitimate possibility. Because it is possible to map these two words to each other, what do we know is possible about the cipher letters and the register letters?</p> <ul> <li> <p>If register letter <code>P</code> is mapped to cipher letter <code>T</code>, the following are also possible:</p> <ul> <li>Register letter <code>A</code> could be mapped to cipher letter <code>I</code>.</li> <li>Register letter <code>R</code> could be mapped to cipher letter <code>F</code>.</li> <li>Register letter <code>T</code> could be mapped to cipher letter <code>S</code>.</li> </ul> </li> <li> <p>If register letter <code>A</code> is mapped to cipher letter <code>I</code>, the following are also possible:</p> <ul> <li>Register letter <code>P</code> could be mapped to cipher letter <code>T</code>.</li> <li>Register letter <code>R</code> could be mapped to cipher letter <code>F</code>.</li> <li>Register letter <code>T</code> could be mapped to cipher letter <code>S</code>.</li> </ul> </li> <li> <p>If register letter <code>R</code> is mapped to cipher letter <code>F</code>, the following are also possible:</p> <ul> <li>Register letter <code>P</code> could be mapped to cipher letter <code>T</code>.</li> <li>Register letter <code>A</code> could be mapped to cipher letter <code>I</code>.</li> <li>Register letter <code>T</code> could be mapped to cipher letter <code>S</code>.</li> </ul> </li> <li> <p>If register letter <code>T</code> is mapped to cipher letter <code>S</code>, the following are also possible:</p> <ul> <li>Register letter <code>P</code> could be mapped to cipher letter <code>T</code>.</li> <li>Register letter <code>A</code> could be mapped to cipher letter <code>I</code>.</li> <li>Register letter <code>R</code> could be mapped to cipher letter <code>F</code>.</li> </ul> </li> </ul> <p>All that for just one possible mapping of a register word to a cipher word??? After considering all legitimate combinations of register words and cipher words, what is left is a comprehensive catalog of what is possible. Because the sets of letters are finite, a comprehensive catalog of what is NOT possible can be determined, and how do we tell Algorithm X what is not possible? We build a list of optional requirements (<code>me_requirements</code>) to handle mutual exclusivity.</p> <p>To make this process just a bit more concrete, each <code>me_requirement</code> takes the form:</p> <pre><code>((register_letter_1, cipher_letter_1), (register_letter_2, cipher_letter_2))\n</code></pre> <p>In other words, <code>register_letter_1</code> can be assigned to <code>cipher_letter_1</code> OR <code>register_letter_2</code> can be assigned to <code>cipher_letter_2</code>, but both MUST NOT happen in the same solution.</p>"},{"location":"16-your-turn/03-agent-x-mission-2-cont/#are-you-kidding-me","title":"Are You Kidding Me?","text":"<p>I optimized my code by only considering register words that truly could be mapped to certain cipher words. Of course, the words must be the same length, but some pattern matching can also limit legitimate pairs. The next table displays how many <code>me_requirements</code> I constructed to handle mutual exclusivity for each test case.</p> Test Case Number of <code>me_requirements</code> 1 - First Contact 1,412 2 - Longer Message with More Words 28,236 3 - A Lot More Words 47,211 4 - Final Test 35,491 <p>There is good news and bad news about the size of these numbers. The good news is Algorithm X and DLX chewed through the matrix data like a hot knife through butter; no significant issues at all. The bad news is setting up the actions to feed to Algorithm X required a bit of optimization. After all, the more often you filter a list of 10s of thousands of <code>me_requirements</code>, the better chance that filtering takes an unreasonable amount of time.</p>"},{"location":"16-your-turn/03-agent-x-mission-2-cont/#observations","title":"Observations","text":"<p>I cannot say enough about the value you might find by solving Agent X, Mission 2 both with and without coloring. In his book, Knuth goes through the math behind how to convert any problem with coloring to a standard Algorithm X problem without coloring. I contend a deep dive into the trenches of a puzzle like this is the way to really solidify that knowledge and understanding.</p> <p>Having done this puzzle both ways, I can say coloring makes the path to success quite a bit more palatable. My solution with coloring was much easier to put together and significantly faster on all test cases. Hence, my original Algorithm X Complexity: Very Hard or Not Too Bad, Your Choice.</p> <p></p>"},{"location":"17-enforcing-sameness/01-all-or-none/","title":"All-or-None Sets of Events","text":"<p>Many puzzles have been discussed where it is important to make sure 2 items are not part of the same solution. Optional Requirements were used to enforce mutual exclusivity. Specifically, if either <code>a</code> or <code>b</code> can be part of a solution, but they cannot both be part of the same solution, an additional requirement was added to the optional requirements list to enforce the needed mutual exclusivity.</p> <p>What if <code>a</code> and <code>b</code> can only be part of a solution if they are both part of the solution? In this case, <code>a</code> and <code>b</code> form an all-or-none set of events. The set only contains two items, <code>a</code> and <code>b</code>, and only two options exist. All items in the set may be part of the solution or none of the items in the set may be part of the solution. Mutual exclusivity allows the enforcement of items that must be different. All-or-none sets of events allow the enforcement of items that must be the same. </p>"},{"location":"17-enforcing-sameness/01-all-or-none/#quiz-time","title":"Quiz Time","text":"<p>Consider a slightly more interesting scenario with the following all-or-none sets of events:</p> <ol> <li><code>a</code> and <code>b</code></li> <li><code>c</code> and <code>d</code></li> <li><code>g</code> and <code>h</code></li> <li><code>x</code> and <code>y</code></li> <li><code>a</code> and <code>h</code></li> </ol> <p>How many all-or-none sets of events are present in this scenario?</p> Show answer <p>The correct answer is 3, but why? Any sets that intersect in any way must be joined together. Let\u2019s rewrite the sets from 1, 3 and 5 above:</p> <p><code>b</code> and <code>a</code> . . . . . . <code>a</code> and <code>h</code> . . . . . . <code>h</code> and <code>g</code></p> <p>Any solution that has <code>b</code> must also have <code>a</code> and then must also have <code>h</code> and then must also have <code>g</code>. The same logic applies starting with <code>a</code>, <code>h</code> or <code>g</code>. Since these sets must be combined, the final 3 all-or-none sets of events are:</p> <ol> <li><code>a</code> and <code>b</code> and <code>g</code> and <code>h</code></li> <li><code>c</code> and <code>d</code></li> <li><code>x</code> and <code>y</code></li> </ol> <p>For each of the three sets above, either all members of the set must be part of a solution or none of the members must be part of a solution. For some problems, building these all-or-none sets of events can be challenging, but before we progress down that path, let\u2019s take a look at implementation.</p>"},{"location":"17-enforcing-sameness/01-all-or-none/#the-school-scavenger-hunt","title":"The School Scavenger Hunt","text":"<p>To explore implementation options for all-or-none sets of events, consider the following scenario. You must divide a group of 18 children into 3 teams of 6 for the elementary school scavenger hunt. To make things fair for the younger kids, each team will have one child from each grade. Fortunately, you have a very accommodating distribution of ages:</p> Grade Names 1 Wednesday AddamsMaggie SimpsonMichelle Tanner 2 Brenda WalshArnold JacksonArthur Fonzarelli 3 Stephanie TannerDarlene ConnerCarlton Banks 4 Willis JacksonPugsley AddamsMarcia Brady 5 Greg BradyLisa SimpsonJoanie Cunningham 6 Richie CunninghamBart SimpsonD. J. Tanner <p>Each child will be assigned to either the red, the green or the blue team. To help the parents during drop-off and pickup, it is important that siblings be assigned to the same team. All siblings share identical last names.</p> <p>This year, the 2nd grade students will be team captains. Brenda Walsh is the red team captain, Arnold Jackson is the green team captain and Arthur Fonzarelli is the blue team captain.</p>"},{"location":"17-enforcing-sameness/01-all-or-none/#all-or-none-sets-of-children","title":"All-or-None Sets of Children","text":"<p>That sounds like a Jeopardy question, doesn't it? </p> <ul> <li>Contestant: \"Common Words for $300, Alex.\"</li> <li>Alex: \"This word is commonly used to refer to an all-or-none set of children.\"</li> <li>Contestant: \"What is a family?\"</li> </ul> <p>Grouping the children by last name results in the following all-or-none sets of names:</p> <ul> <li>Bart Simpson, Maggie Simpson, Lisa Simpson</li> <li>D. J. Tanner, Michelle Tanner, Stephanie Tanner</li> <li>Wednesday Addams, Pugsley Addams</li> <li>Richie Cunningham, Joanie Cunningham</li> <li>Willis Jackson, Arnold Jackson</li> <li>Marcia Brady, Greg Brady</li> <li>Brenda Walsh</li> <li>Arthur Fonzarelli</li> <li>Darlene Conner</li> <li>Carlton Banks</li> </ul> <p>Let's first explore using colors to enforce sameness.</p> <p></p>"},{"location":"17-enforcing-sameness/02-all-or-none-with-colors/","title":"Algorithm X Setup","text":"<p>This toy example is a straightforward Algorithm X setup. What are the requirements? Each student must be assigned to a team color and each grade (age) must be represented on each team. What are the actions? Each action assigns a team color to one of the students. But, how do we make sure the siblings are always placed on the same team? Using colors to enforce sameness, of course! Let\u2019s build a solution one step at a time. At the bottom is a fully functional solution if you wish to experiment further. </p>"},{"location":"17-enforcing-sameness/02-all-or-none-with-colors/#building-the-all-or-none-sets","title":"Building the All-or-None Sets","text":"<p>Because all siblings share identical last names, the all-or-none sets are easily built using a <code>dictionary</code> to organize the <code>Student</code>s into families. Each key is a last name and each value is a list of all the <code>Student</code>s that are part of that family.</p> <pre><code>        self.families = defaultdict(list)\n        for student in students:\n            last_name = student.name.split()[-1]\n            self.families[last_name].append(student)\n</code></pre>"},{"location":"17-enforcing-sameness/02-all-or-none-with-colors/#requirements-and-actions","title":"Requirements and Actions","text":"<p>Two list comprehensions capture all the requirements. 1 to 3 actions is created for each child. If the child is a captain, only one team color assignment is possible. If the child is not a captain, the child could be put on any of the 3 teams.</p> <pre><code>        requirements = [('student assigned', student.name) for student in students]\n        requirements += [('grade covered', grade, team_color) for grade in range(1, 7) for team_color in 'rgb']\n\n        actions = dict()\n        for student in students:\n            possible_teams = captains[student.name] if student.name in captains else 'rgb'\n            for team_color in possible_teams:\n                action = ('assign student', student.name, team_color)\n                actions[action] = [('student assigned', student.name), ('grade covered', student.grade, team_color)]\n</code></pre>"},{"location":"17-enforcing-sameness/02-all-or-none-with-colors/#enforcing-sameness-using-colors","title":"Enforcing Sameness Using Colors","text":"<p>Per the steps outlined a few pages earlier, an attribute is added to track color assignments and the <code>AlgorithmXSolver</code> <code>_process_row_selection()</code> and <code>_process_row_deselection()</code> methods are overridden:</p> <pre><code>        self.student_colors = {student.name:[] for student in students}\n</code></pre> <pre><code>    def _process_row_selection(self, row):\n        _, name, team_color = row\n        for sibling in self.families[name.split()[-1]]:\n            if self.student_colors[sibling.name] and team_color != self.student_colors[sibling.name][-1]:\n                self.solution_is_valid = False\n\n            self.student_colors[sibling.name].append(team_color)\n\n\n    def _process_row_deselection(self, row):\n        _, name, team_color = row\n        for sibling in self.families[name.split()[-1]]:\n            self.student_colors[sibling.name].pop()\n</code></pre>"},{"location":"17-enforcing-sameness/02-all-or-none-with-colors/#building-teams-from-a-solution","title":"Building Teams from a Solution","text":"<p>As I loop through the actions of each solution, I append the name of each student to the appropriate team color in a <code>dictionary</code>.</p> <pre><code>    for solution in solver.solve():\n        teams = {'r':[], 'g':[], 'b':[]}\n        for _, name, team_color in solution:\n            teams[team_color].append(name)\n</code></pre>"},{"location":"17-enforcing-sameness/02-all-or-none-with-colors/#the-full-solution","title":"The Full Solution","text":"<p>Putting it all together results in the following. Copy the following code into your coding environment, make changes and experiment. Most importantly, this solution is provided as a comparison to the second approach to enforcing sameness covered next: complex actions.</p> <pre><code># Unless your coding environment will let you create an AlgorithmX package,\n# you will need to copy all of the AlgorithmXSolver code into your code.\n\nfrom AlgorithmX import AlgorithmXSolver\n\nfrom collections import namedtuple, defaultdict\nfrom typing import List, Dict\n\nStudent = namedtuple('Student', 'name grade')\n\nclass ScavengerHuntSolverUsingColors(AlgorithmXSolver):\n\n    def __init__(self, students: List[Student], captains: Dict[str, str]):\n\n        self.student_colors = {student.name:[] for student in students}\n\n        self.families = defaultdict(list)\n        for student in students:\n            last_name = student.name.split()[-1]\n            self.families[last_name].append(student)\n\n        requirements = [('student assigned', student.name) for student in students]\n        requirements += [('grade covered', grade, team_color) for grade in range(1, 7) for team_color in 'rgb']\n\n        actions = dict()\n        for student in students:\n            possible_teams = captains[student.name] if student.name in captains else 'rgb'\n            for team_color in possible_teams:\n                action = ('assign student', student.name, team_color)\n                actions[action] = [('student assigned', student.name), ('grade covered', student.grade, team_color)]\n\n        super().__init__(requirements, actions)\n\n\n    def _process_row_selection(self, row):\n        _, name, team_color = row\n        for sibling in self.families[name.split()[-1]]:\n            if self.student_colors[sibling.name] and team_color != self.student_colors[sibling.name][-1]:\n                self.solution_is_valid = False\n\n            self.student_colors[sibling.name].append(team_color)\n\n\n    def _process_row_deselection(self, row):\n        _, name, team_color = row\n        for sibling in self.families[name.split()[-1]]:\n            self.student_colors[sibling.name].pop()\n\n\nstudents = [Student('Wednesday Addams', 1), Student('Maggie Simpson', 1), Student('Michelle Tanner', 1),\n            Student('Brenda Walsh', 2), Student('Arnold Jackson', 2), Student('Arthur Fonzarelli', 2),\n            Student('Stephanie Tanner', 3), Student('Darlene Conner', 3), Student('Carlton Banks', 3),\n            Student('Willis Jackson', 4), Student('Pugsley Addams', 4), Student('Marcia Brady', 4),\n            Student('Greg Brady', 5), Student('Lisa Simpson', 5), Student('Joanie Cunningham', 5),\n            Student('Richie Cunningham', 6), Student('Bart Simpson', 6), Student('D. J. Tanner', 6) ]\n\ncaptains = {'Brenda Walsh': 'r', 'Arnold Jackson': 'g', 'Arthur Fonzarelli': 'b'}\n\nsolver = ScavengerHuntSolverUsingColors(students, captains)\n\ncount = 0\nfor solution in solver.solve():\n    count += 1\n    teams = {'r':[], 'g':[], 'b':[]}\n    for _, name, team_color in solution:\n        teams[team_color].append(name)\n\n    print(f'\\nOption {count}')\n    for color in teams:\n        print(f'{color}:', ', '.join(sorted(teams[color], key=lambda s:s.split()[-1])))\n</code></pre> <p></p>"},{"location":"17-enforcing-sameness/03-all-or-none-with-complex-actions/","title":"Simple vs Complex Actions","text":"<p>The problem has not changed, so it makes sense the requirements remain exactly the same. However, in this approach, we will look at actions a bit differently. Previously, each action assigned a team color to one student, creating a simple action that accomplished a single task. Here, each action will assign a team color to 1 or more students.</p> <p>Complex Action: Multiple simple actions combined into a single action.</p> <p>Using simple actions, it takes 3 separate <code>tuple</code>s to assign Bart, Lisa and Maggie Simpson to the red team:</p> <pre><code>('assign student', 'Bart Simpson', 'r')\n('assign student', 'Lisa Simpson', 'r')\n('assign student', 'Maggie Simpson', 'r')\n</code></pre> <p>Keep in mind, each action must be a <code>tuple</code> as it will be used as a <code>key</code> in the <code>actions</code> <code>dictionary</code>. These three simple actions could be combined into the following complex action <code>tuple</code>:</p> <pre><code>(('assign student', 'Bart Simpson', 'r'), ('assign student', 'Lisa Simpson', 'r'), ('assign student', 'Maggie Simpson', 'r'))\n</code></pre> <p>Packing simple actions into a complex action can be done many ways. Ultimately, what matters is that you properly unpack the complex action <code>tuple</code> when building a solution. In the code below, I have chosen to pack simple actions into a complex action as follows:</p> <pre><code>('assign students', ('Bart Simpson', 'Lisa Simpson', 'Maggie Simpson'), 'r')\n</code></pre> <p>Let\u2019s step through a full solution using complex actions one step at a time.</p>"},{"location":"17-enforcing-sameness/03-all-or-none-with-complex-actions/#what-remains-the-same","title":"What Remains the Same?","text":"<p>The following code blocks are identical to the code used previously:</p> <pre><code>        self.families = defaultdict(list)\n        for student in students:\n            last_name = student.name.split()[-1]\n            self.families[last_name].append(student)\n</code></pre> <pre><code>        requirements = [('student assigned', student.name) for student in students]\n        requirements += [('grade covered', grade, team_color) for grade in range(1, 7) for team_color in 'rgb']\n</code></pre>"},{"location":"17-enforcing-sameness/03-all-or-none-with-complex-actions/#method-overrides-no-longer-necessary","title":"Method Overrides No Longer Necessary","text":"<p>The <code>AlgorithmXSolver</code> <code>_process_row_selection()</code> and <code>_process_row_deselection()</code> methods no longer need to be customized. In the full solution below, you will see this shortens the code a fair amount.</p>"},{"location":"17-enforcing-sameness/03-all-or-none-with-complex-actions/#building-the-actions-dictionary","title":"Building the Actions Dictionary","text":"<p>In the following code snippet, notice how the list of names for each family is put into a single action. List comprehensions are used to identify all requirements satisfied by the complex action.  Each student that is part of the family adds two satisfied requirements to the list.</p> <p>It is important that a family with only one child is still treated as a group of children. Every action, whether the family has 1, 2, 3 or more children, assigns a team color to all members of the family group.</p> <pre><code>        actions = dict()\n        for family in self.families.values():\n            possible_teams = 'rgb'\n            for student in family:\n                if student.name in captains:\n                    possible_teams = captains[student.name]\n\n            for team_color in possible_teams:\n                action = ('assign students', tuple(student.name for student in family), team_color)\n                actions[action] = [('student assigned', student.name) for student in family]\n                actions[action] += [('grade covered', student.grade, team_color) for student in family]\n</code></pre>"},{"location":"17-enforcing-sameness/03-all-or-none-with-complex-actions/#building-teams-from-a-solution","title":"Building Teams from a Solution","text":"<p>A very minor change must be made as the actions that make up a solution are unpacked. Each action now contains a group of names. That entire group of names must be added to the proper team.</p> <pre><code>    for solution in solver.solve():\n        teams = {'r':[], 'g':[], 'b':[]}\n        for _, names, team_color in solution:\n            teams[team_color].extend(names)\n</code></pre>"},{"location":"17-enforcing-sameness/03-all-or-none-with-complex-actions/#the-full-solution","title":"The Full Solution","text":"<p>Putting it all together results in the following. Copy this code into your coding environment, make changes and experiment. Most importantly, this solution is provided as a comparison to the first approach to enforcing sameness covered previously: using colors.</p> <pre><code># Unless your coding environment will let you create an AlgorithmX package,\n# you will need to copy all of the AlgorithmXSolver code into your code.\n\nfrom AlgorithmX import AlgorithmXSolver\n\nfrom collections import namedtuple, defaultdict\nfrom typing import List, Dict\n\nStudent = namedtuple('Student', 'name grade')\n\nclass ScavengerHuntSolverUsingComplexActions(AlgorithmXSolver):\n\n    def __init__(self, students: List[Student], captains: Dict[str, str]):\n\n        self.families = defaultdict(list)\n        for student in students:\n            last_name = student.name.split()[-1]\n            self.families[last_name].append(student)\n\n        requirements = [('student assigned', student.name) for student in students]\n        requirements += [('grade covered', grade, team_color) for grade in range(1, 7) for team_color in 'rgb']\n\n        actions = dict()\n        for family in self.families.values():\n            possible_teams = 'rgb'\n            for student in family:\n                if student.name in captains:\n                    possible_teams = captains[student.name]\n\n            for team_color in possible_teams:\n                action = ('assign students', tuple(student.name for student in family), team_color)\n                actions[action] = [('student assigned', student.name) for student in family]\n                actions[action] += [('grade covered', student.grade, team_color) for student in family]\n\n        super().__init__(requirements, actions)\n\n\nstudents = [Student('Wednesday Addams', 1), Student('Maggie Simpson', 1), Student('Michelle Tanner', 1),\n            Student('Brenda Walsh', 2), Student('Arnold Jackson', 2), Student('Arthur Fonzarelli', 2),\n            Student('Stephanie Tanner', 3), Student('Darlene Conner', 3), Student('Carlton Banks', 3),\n            Student('Willis Jackson', 4), Student('Pugsley Addams', 4), Student('Marcia Brady', 4),\n            Student('Greg Brady', 5), Student('Lisa Simpson', 5), Student('Joanie Cunningham', 5),\n            Student('Richie Cunningham', 6), Student('Bart Simpson', 6), Student('D. J. Tanner', 6) ]\n\ncaptains = {'Brenda Walsh': 'r', 'Arnold Jackson': 'g', 'Arthur Fonzarelli': 'b'}\n\nsolver = ScavengerHuntSolverUsingComplexActions(students, captains)\n\ncount = 0\nfor solution in solver.solve():\n    count += 1\n    teams = {'r':[], 'g':[], 'b':[]}\n    for _, names, team_color in solution:\n        teams[team_color].extend(names)\n\n    print(f'\\nOption {count}')\n    for color in teams:\n        print(f'{color}:', ', '.join(sorted(teams[color], key=lambda s:s.split()[-1])))\n</code></pre> <p></p>"},{"location":"17-enforcing-sameness/04-test-your-skills/","title":"Reducing Sets of Events","text":"<p>The Scavenger Hunt made it easy to identify the all-or-none sets of events as the children were simply grouped by last name. It is more common to have many sets of events that contain only 2 elements and it is up to you to combine the sets where possible and build a minimum number of completely independent sets. Let\u2019s explore a short algorithm for doing that.</p> <p>In the realm of sameness, there are two fundamental building blocks. The first is a single standalone item. The second is two items that need to be the same. For instance, <code>A</code> must be the same as <code>B</code>. Given a list of sets, where each set contains a single element or 2 elements that must be the same, the following pseudocode reduces that list to a minimum number of sets, where no 2 sets have any overlap.</p> <p></p>"},{"location":"17-enforcing-sameness/04-test-your-skills/#test-your-skills","title":"Test Your Skills","text":"<p>The following exercise gives you a chance to practice reducing a list of sets that might have overlap to a list of sets where no two sets overlap with each other. The number of distinct elements does not change, but any two sets that have overlap must be combined, resulting in a shorter list of all-or-none sets. Each set in the final list contains a group of elements that all must be the same in some way.</p> <p>Exercise</p> <p>Write a Python function to minimize a list of sets. Below is some starter code and a few test cases to help you verify your solution:</p> <pre><code>def minimize_all_or_none_sets(all_or_none_sets: list[set[str]]):\n\n    # Reduce the number of sets in the list by\n    # combining any sets that overlap.\n\n    return all_or_none_sets\n\nTESTS = [\n            [{'A', 'B'}, {'C', 'D'}, {'E', 'F'}],  \n            [{'A', 'B'}, {'B', 'C'}],  \n            [{'A', 'B'}, {'B', 'C'}, {'C', 'D'}, {'E', 'F'}],\n            [{'A', 'B'}, {'B', 'C'}, {'C', 'D'}, {'E', 'F'}, {'A'}, {'Z'}],\n            [{'A', 'B'}, {'A', 'C'}, {'A', 'D'}, {'A', 'F'}, {'X', 'Y'}, {'Z', 'Y'}, {'E', 'F'}, {'J', 'K'}, {'Z', 'P'}],\n            [{'A'}, {'Z'}, {'Q'}, {'A', 'B'}, {'A', 'C'}, {'A', 'D'}, {'A', 'F'}, {'X', 'Y'}, {'Z', 'Y'}, {'E', 'F'}, {'J', 'K'}, {'Z', 'P'}]\n        ]\n\nfor test in TESTS:\n    print(minimize_all_or_none_sets(test))\n</code></pre> Expected answers for each test case... <pre><code>[{'A', 'B'}, {'C', 'D'}, {'E', 'F'}]\n\n[{'A', 'B', 'C'}]  \n\n[{'A', 'B', 'C', 'D'}, {'E', 'F'}]\n\n[{'A', 'B', 'C', 'D'}, {'E', 'F'}, {'Z'}]\n\n[{'A', 'B', 'C', 'D', 'E', 'F'}, {'P', 'X', 'Y', 'Z'}, {'J', 'K'}]\n\n[{'A', 'B', 'C', 'D', 'E', 'F'}, {'P', 'X', 'Y', 'Z'}, {'Q'}, {'J', 'K'}]\n</code></pre> <ul> <li>The results above show all set elements sorted. Because sets are unordered, your results might not be in the same order. The elements of each set are what matters.</li> </ul> <p>Thoroughly test your algorithm as it will be very helpful in the upcoming exercises!</p>"},{"location":"17-enforcing-sameness/04-test-your-skills/#a-few-xp-for-your-efforts","title":"A Few XP for Your Efforts","text":"<p>Before tackling your next exact cover problem, apply your new skills to the following puzzle and capture a few XP along the way!</p> <p>Puzzle: Networking</p> <p>Author: @Gladwell</p> <p>Published Difficulty: Medium</p> <p></p>"},{"location":"18-your-turn/01-einstein-revisited/","title":"Einstein's Riddle Solver (Revisited)","text":"<p>Puzzle: Einstein's Riddle Solver</p> <p>Author: @OroshiX</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: No More Perspective Shift Needed</p>"},{"location":"18-your-turn/01-einstein-revisited/#memory-refresh","title":"Memory Refresh","text":"<p>Einstein\u2019s Riddle Solver is unique because some characteristics must be assigned to the same column and other characteristics must not be assigned to the same column. In the original discussion, I suggested converting all characteristics that must be the same into a group of characteristics that must be different. In that way, all characteristic relationships could be handled with option requirements used to implement mutual exclusivity. Let\u2019s now consider solutions for Einstein\u2019s Riddle Solver that use coloring or complex actions to enforce sameness.</p> <p>Einstein\u2019s Riddle Solver is extremely similar to the scavenger hunt presented in the previous section, with one key difference. The scavenger hunt did not have any mutual exclusivity. The scavenger hunt can be thought of as a grid, just like the gameboard and tiles analogy proposed in the original Einstein discussion. In the scavenger hunt, each child already has a grade level, but must be assigned a team color. In the Einstein puzzle, each characteristic already has a row and must be assigned a column.</p>"},{"location":"18-your-turn/01-einstein-revisited/#all-or-none-sets-of-characteristics","title":"All-Or-None Sets of Characteristics","text":"<p>Because every characteristic must be accounted for, start with a list of sets where each set contains exactly one characteristic. Then, add another set to the list for each group of 2 characteristics that must be the same. The last step is to use the skills practiced on the previous page to combine the all-or-none sets that overlap. In the end, you will have some sets with multiple characteristics that must be the same and several sets that still only contain a single characteristic, meaning that characteristic is not required to be in the same column as any other characteristic.</p>"},{"location":"18-your-turn/01-einstein-revisited/#enforcing-sameness-with-colors","title":"Enforcing Sameness with Colors","text":"<p>To build a solution using colors, you will follow the same steps used to build a solution for the scavenger hunt to add the coloring mechanisms. Other than that, handling the mutually exclusive characteristics does not change from the original discussion.</p>"},{"location":"18-your-turn/01-einstein-revisited/#enforcing-sameness-with-complex-actions","title":"Enforcing Sameness with Complex Actions","text":"<p>Again, building Einstein\u2019s complex actions is almost the exact same process as described in the scavenger hunt. With complex actions, tremendous care must be taken when identifying the requirements covered by each complex action. Do not overlook the <code>me_requirements</code> for each simple action that is part of the complex action.</p>"},{"location":"18-your-turn/01-einstein-revisited/#comparison","title":"Comparison","text":"<p>The following table compares my solvers using each of the three techniques discussed here. In each case, the solver was instructed to do an exhaustive search, even after finding the first solution.</p> Sameness Enforced With: Actions me_requirements Execution Time (ms) Test Case 2: 4 * 5 Medium Mutual Exclusivity 80 152 3 Colors 80 44 6 Complex Actions 45 44 1 Test Case 3: 7 * 6 Hard Mutual Exclusivity 222 564 35 Colors 222 99 3600 Complex Actions 114 99 6 Test Case 4: 5 * 5 Medium Mutual Exclusivity 105 183 4 Colors 105 43 8 Complex Actions 55 43 1"},{"location":"18-your-turn/01-einstein-revisited/#observations","title":"Observations","text":"<p>The numbers seen above tell an expected story. Enforcing sameness with mutual exclusivity requires many extra <code>me_requirements</code>, but Algorithm X is still able to chew through the matrix with relative speed. Enforcing sameness using colors requires a significant amount of color checking outside the matrix. As you can see, that adds a sizeable amount of time for the most difficult test case.</p> <p>Enforcing sameness with complex actions combines the best of both worlds. The <code>me_requirements</code> are kept to the minimum necessary to enforce mutually exclusive characteristics while the actions are minimized by combining actions that must occur together. Properly constructing complex actions might take a bit of practice, but those efforts will be rewarded with very fast execution times.</p>"},{"location":"18-your-turn/01-einstein-revisited/#a-word-about-coloring-and-algorithm-c","title":"A Word About Coloring and Algorithm C","text":"<p>I performed the same tests above using a DLX-based Algorithm C solver and the results were even slower than my Algorithm X solver, adapted for coloring. This is not an indictment of coloring or Algorithm C. It is simply an indication that coloring is not the best option for enforcing the type of sameness discussed here. A few pages back, it was crystal clear that coloring was a far-superior choice for puzzles such as Ye_ An_th_r W_rd Se_rch and Agent X, Mission 2 \u2013 Mysterious Cryptogram.</p> <p></p>"},{"location":"18-your-turn/02-breaking-bifid-revisited/","title":"Breaking Bifid (Revisited)","text":"<p>Puzzle: Breaking Bifid</p> <p>Author: @therealbeef</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Imagine Untangling the World's Largest Pile of Holiday Lights</p>"},{"location":"18-your-turn/02-breaking-bifid-revisited/#all-or-none-sets-of-events","title":"All-or-None Sets of Events","text":"<p>Breaking Bifid is a complex puzzle and I encourage you to revisit the original discussion that ended with the following graphic:</p> <p></p> <p>Drawing two more purple boxes around the <code>M</code> and the <code>E</code> produces the following:</p> <pre><code>('row', 'A') must be the same as ('row', 'S')\n('row', 'N') must be the same as ('col', 'S')\n('row', 'D') must be the same as ('row', 'M')\n('col', 'A') must be the same as ('col', 'M')\n('col', 'N') must be the same as ('row', 'E')\n('col', 'D') must be the same as ('col', 'E')\n</code></pre> <p>Each row above is an all-or-none set of events. The two elements in each row must be the same. There is no overlap in this toy example, but if there was, you would want to review the exercise a few pages back and combine any sets that overlap.</p>"},{"location":"18-your-turn/02-breaking-bifid-revisited/#enforcing-sameness-with-colors","title":"Enforcing Sameness with Colors","text":"<p>Each time a letter is placed on the grid, that letter is assigned to a particular row and column. Based on the all-or-none sets of events, several other letters might need to have their row or column colored with the same number. The first step in a coloring solution is to add an attribute to your solver to keep track of color assignments. In this case, two attributes could be used, one for row assignments and one for column assignments.</p> <pre><code>        row_color_assignments = {letter:[] for letter in all_letters_in_plaintext_or_ciphertext}\n        col_color_assignments = {letter:[] for letter in all_letters_in_plaintext_or_ciphertext}\n</code></pre> <p>We might also consider the following to keep track of colors with a single attribute:</p> <pre><code>        color_assignments = {letter:{'row':[], 'col':[]} for letter in all_letters_in_plaintext_or_ciphertext}\n</code></pre> <p>KEY POINT: Using colors in this way eliminates the need for any <code>me_requirements</code> as outlined in the original discussion. The colors enforce sameness. In the original discussion, each all-or-none set of 2 events was converted to a group of optional requirements used by Algorithm X to enforce mutual exclusivity.</p>"},{"location":"18-your-turn/02-breaking-bifid-revisited/#enforcing-sameness-with-complex-actions","title":"Enforcing Sameness with Complex Actions","text":"<p>I highly recommend you go down this route on your own. Once you remove all overlap from the all-or-none sets of events, things become possible I did not envision. I will explain further, but I urge you to explore this on your own before opening the spoiler below.</p> Spoiler Alert: I am serious. I did not see this coming. <p>After reducing the all-or-none sets of events, how many distinct sets remain? For Test Case 1: Long test, only 5 sets remain. More importantly, each set has 5 <code>('row', letter)</code> elements and 5 <code>('col', letter)</code> elements. That means the row assignment of 5 letters and the col assignments of 5 letters all need to be the same. And, this is exactly what is expected.</p> <p>For a message of reasonable length, all 25 letters are probably part of the key. If that is the case, for each number from 1 to 5, there are exactly 9 letters where either the letter\u2019s row or column or both is equal to that number. In the graphic below, every location where row = 3 or column = 3 has been highlighted.</p> <p></p> <p>When this puzzle was originally discussed, I wrote the following:</p> <p>The action steps I can take to build a solution are pretty simple. One at a time, a letter of the alphabet (J is excluded) can be placed in one of the 25 squares. As for requirements, the only obvious requirements are that every letter be used and every square be covered.</p> <p>Let\u2019s now consider a completely different gameboard and tiles. The gameboard simply has the numbers 1 through 5. The tiles are the all-or-none sets of events. Each set needs to be assigned to one number on the gameboard. There are 5 sets and there are 5 numbers. I honestly did not see this coming. Is a gameboard analogy really needed? Is Algorithm X even needed?</p> <p>The first 4 test cases all reduce to exactly 5 all-or-none sets of events. In each of those cases, 5 sets need to be assigned to 5 different numbers. Too easy, right? What about Test Case 5: Minimal text? Because the text is so short, the all-or-none sets do not reduce down to 5, leaving the following options.</p> <ol> <li>Algorithm X could be used to determine how more than 5 sets can be assigned to only 5 numbers. To be honest, Algorithm X still seems like a bit too much compared to a simple algorithm to combine independent sets until the total number of sets gets to 5.</li> </ol> Spoiler Alert: Click here for Option 2. <p>Assuming you have <code>n</code> all-or-none sets, you could expand the matrix to <code>n</code> by <code>n</code>, making it very easy to assign <code>n</code> sets to <code>n</code> numbers.</p> <p>Let\u2019s briefly discuss this second option. The all-or-none sets of events are completely independent of each other. The first set assigned to one of the numbers always works, no matter which number it gets assigned to. A 100 x 100 matrix could be used and numbers chosen randomly between 0 and 99. The consistency of the number across all elements of the set assigned to it is what matters, not the size of the matrix.</p> <p>Breaking Bifid is a wonderful puzzle and the complexity gave me tremendous opportunity to explore various Algorithm X techniques. Only after travelling down the path of complex actions did I determine how to solve the puzzle without backtracking.</p> <p></p>"},{"location":"19-customizing-your-solver/01-algorithm-x/","title":"Algorithm X","text":"<p>To have a conversation about customizing Algorithm X, it is necessary to first understand how Algorithm X works. You are welcome to study a detailed discussion in Knuth\u2019s The Art of Computer Programming or a well-done summary on Wikipedia. There is little benefit to me repeating that material here.</p> <p>In the next graphic, I have copied Knuth's algorithm as written on Wikipedia. I strongly recommend you work your way through the step-by-step Algorithm X example provided on Wikipedia to gain an understanding of how Algorithm X processes the matrix rows and columns to find solutions.</p> <p></p>"},{"location":"19-customizing-your-solver/01-algorithm-x/#long-pause","title":"Long Pause","text":"<p>As I move forward with customization options, I will assume you have a reasonable idea how the above algorithm works. I am sure you noticed you can solve a lot of exact cover problems without understanding the details of the algorithm, but if you want to do any customization, you will need a basic understanding of the internal Algorithm X mechanics. I must admit, I went through the example on Wikipedia more times than I can count as I worked my way through the various exact cover puzzles. Take as much time as you need!</p>"},{"location":"19-customizing-your-solver/01-algorithm-x/#what-can-be-customized","title":"What Can Be Customized?","text":"<p>Looking at the algorithm above, Step 2 and Step 3 both involve making a choice. In Step 2, a column is chosen from all yet-to-be-covered columns in the matrix. Once a column is chosen, Step 3 loops through all rows that cover that column and those rows are chosen in some order. In certain situations, especially when the matrix is large, these choices can make a meaningful difference.</p>"},{"location":"19-customizing-your-solver/01-algorithm-x/#always-try-this-first","title":"Always Try This First","text":"<p>You do have some influence over how rows and columns are chosen simply by how you set up the matrix. In the absence of detailed instruction, <code>AlgorithmXSolver</code> will choose columns from left to right and rows from top to bottom. In the <code>AlgorithmXSolver</code> constructor, the matrix is constructed left-to-right and top-to-bottom to mirror the order in which you built the requirements <code>list</code> and the actions <code>dictionary</code>.</p> <p><code>AlgorithmXSolver</code> does not have any detailed instructions for ordering rows, so top-to-bottom is the default. Columns are a bit different. By default, <code>AlgorithmXSolver</code> always chooses the column covered by the fewest number of rows. This is referred to as Minimum Remaining Value or MRV. But, what about ties? What if several columns have the same MRV? In what order are those columns tried? Unless instructed otherwise, <code>AlgorithmXSolver</code> breaks ties from left to right.</p> <p>Being careful about how you build your requirements <code>list</code> and your actions <code>dictionary</code> is always the easiest way to influence the ordering of choices in Steps 2 and 3. It is also the most efficient way to handle sorting of choices as the matrix is built in the order you desire, and sort order is only considered once.</p>"},{"location":"19-customizing-your-solver/01-algorithm-x/#dynamic-sorting","title":"Dynamic Sorting","text":"<p>In rare cases, you might wish to customize the sorting or rows and columns on some criteria that can change as Algorithm X works its way through the matrix. As actions are chosen to be part of the solution, tiles are placed on the gameboard and the state of the gameboard changes. Maybe you wish the state of the gameboard to influence the choice of columns or rows.</p> <p>As I was learning Algorithm X, I solved a number of puzzles using various versions of dynamic sorting. Now that I have built this playground and developed a much better understanding of Algorithm X, I must admit, I have removed all dynamic sorting from 100% of those puzzles. On several puzzles, I am very careful about how I set up the matrix, but on no puzzles do I use the customization techniques I am about to describe.</p> <p>This playground covers a lot of material, but it can never cover every possible exact cover problem. Although you may not need these strategies today, it is impossible for me to say you will never need them. </p>"},{"location":"19-customizing-your-solver/01-algorithm-x/#but-first","title":"But, First\u2026","text":"<p>Before I cover how to further customize the selection processes used in Steps 2 and 3, we must first have a short discussion about Dancing Links (DLX) and the DLX implementation used in <code>AlgorithmXSolver</code>.</p> <p></p>"},{"location":"19-customizing-your-solver/02-dancing-links/","title":"<code>DLXCell</code>","text":"<p><code>AlgorithmXSolver</code>'s DLX implementation is based on @RoboStac's solution to Constrained Latin Squares on CodinGame. Each instance of <code>DLXCell</code> is either a column header, a row header or a location of a <code>1</code> in the matrix. I add one key attribute that will be critical when customizing Algorithm X.</p> <ul> <li><code>self.title</code> - This attribute is used by the row and column headers to store the original requirement and action tuples used to set up Algorithm X.</li> </ul> <p>The cells of the matrix never use this attribute. Instead, each cell has two pointers, one to the column header and one to the row header. This gives every cell in the matrix quick access to the tuples used to create the Algorithm X matrix.</p> <p>The <code>DLXCell</code> attributes are shown below:</p> <pre><code>class DLXCell:\n    def __init__(self, title=None):\n        self.prev_x = self\n        self.next_x = self\n        self.prev_y = self\n        self.next_y = self\n\n        self.col_header = None\n        self.row_header = None\n\n        # Only used for column and row headers.\n        self.title = title\n\n        # Size quickly identifies how many rows are in any particular column.\n        self.size = 0\n</code></pre> <p>As long as the tuples you created to build a model for Algorithm X are easy to decipher, they will provide the information needed to customize the sorting of columns and/or rows.</p> <p></p>"},{"location":"19-customizing-your-solver/03-column-selection/","title":"Customizing Column Selection","text":"<p>In Step 2 of Algorithm X, a column is chosen from all remaining yet-to-be-covered columns. As is often the case with backtracking, <code>AlgorithmXSolver</code>\u2019s default is to choose the column covered by the fewest number of rows. This technique is referred to as Minimum Remaining Value (MRV). Two situations could prompt you to override this default.</p> <ol> <li> <p>You may want to specify how ties are broken when multiple columns are covered by the same number of rows.</p> </li> <li> <p>You may want to specify some non-MRV-based criteria.</p> </li> </ol> <p>To customize the sort criteria, you must override <code>AlgorithmXSolver</code>\u2019s <code>_requirement_sort_criteria(self, col_header: DLXCell)</code> method. Algorithm X loops through the column headers to determine which column to choose. Because each argument passed to the method is a column header <code>DLXCell</code>, it is easy to access:</p> <ol> <li> <p><code>col_header.size</code> - the number of rows that cover this column</p> </li> <li> <p><code>col_header.title</code> - the requirement tuple</p> </li> </ol> <p>In the <code>AlgorithmXSolver</code> code below, you see the default is to return <code>col_header.size</code>.</p> <pre><code>    # In some cases it may be beneficial to have Algorithm X try covering certain requirements\n    # before others as it looks for paths through the matrix. The default is to sort the requirements\n    # by how many actions cover each requirement, but in some cases there might be several \n    # requirements covered by the same number of actions. By overriding this method, the\n    # Algorithm X Solver can be directed to break ties a certain way or consider another way\n    # of prioritizing the requirements.\n    def _requirement_sort_criteria(self, col_header: DLXCell):\n        return col_header.size\n</code></pre> <p>In the following code block, I sketch out what an override might look like. I have made no effort to define requirements for this example, so for illustration, I will assume the requirement tuple can be unpacked into 5 distinct elements.</p> <pre><code>    def _requirement_sort_criteria(self, col_header: DLXCell):\n        _, _, c, d, _ = col_header.title\n        return (col_header.size, c, d)\n</code></pre> <p>In this example, the default <code>col_header.size</code> is still being used as the primary sort criteria, but ties are being broken first by <code>c</code> and then by <code>d</code>.</p> <p>Often, MRV is a very good choice for column selection, so you may find it rare that you consider overriding how columns are sorted. In the next section, I will look at the rows of the matrix.</p> <p></p>"},{"location":"19-customizing-your-solver/04-row-selection/","title":"Customizing Row Selection","text":"<p>By default, rows of the matrix are tried simply in the order in which they are encountered. When a column is selected, Algorithm X navigates down the column and builds a list of all rows that cover that column. These rows are tried, one-by-one, in the order Algorithm X found them.</p> <p>Customizing the order in which Algorithm X tries rows is sometimes a bit more interesting than the columns, since MRV already provides a powerful strategy for column selection.  With no strategy override, row order is based on the algorithm you used to build your actions dictionary. In the <code>AlgorithmXSolver</code> code, you can see the default is to return <code>0</code> for all rows, providing no guidance to Algorithm X.</p> <pre><code>    # In some cases it may be beneficial to have Algorithm X try certain paths through the matrix.\n    # This can be the case when there is reason to believe certain actions have a better chance than\n    # other actions at producing complete paths through the matrix. The method included here does\n    # nothing, but can be overridden to influence the order in which Algorithm X tries rows (actions) \n    # that cover some particular column.\n    def _action_sort_criteria(self, row_header: DLXCell):\n        return 0\n</code></pre> <p>To demonstrate an override situation, let\u2019s again look at Sudoku where every action probably took the following form:</p> <pre><code>action = ('place value', row, col, val)\n</code></pre> <p>The argument passed into <code>_action_sort_criteria(self, row_header: DLXCell)</code> is a row header <code>DLXCell</code> which allows easy access to the row <code>title</code> where the action tuple is stored. The following override will make sure integers for a Sudoku cell are always tried in ascending order:</p> <pre><code>    def _action_sort_criteria(self, row_header: DLXCell):\n        _, _, _, val = row_header.title\n        return val\n</code></pre> <p>The following override will make sure integers for a Sudoku cell are always tried in descending order:</p> <pre><code>    def _action_sort_criteria(self, row_header: DLXCell):\n        _, _, _, val = row_header.title\n        return -val\n</code></pre> <p>If you really want to get crazy with a dynamic strategy, the following override will order rows according to the following two criteria:</p> <ul> <li>First, how close the number is the average of all remaining cell candidates.</li> <li>Second, being lower than the average is prioritized over being higher than the average. </li> </ul> <pre><code>    def _action_sort_criteria(self, row_header: DLXCell):\n        _, row, col, val = row_header.title\n        average = sum(all remaining candidates for grid[(row, col)] / number of remaining candidates\n        return (absolute_value(average - val), val - average)\n</code></pre> <p>I understand the example above is strange, but you could try it. Hopefully, you better understand how column and row ordering can affect your Algorithm X solution. With this in mind, let's take a look at a couple of puzzles where these techniques could be used.</p> <p></p>"},{"location":"20-your-turn/01-harmless-rooks/","title":"Harmless Rooks","text":"<p>Puzzle: Harmless Rooks</p> <p>Author: @Niako</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Algorithm X is the Easy Part</p>"},{"location":"20-your-turn/01-harmless-rooks/#state-of-the-union","title":"State of the Union","text":"<p>I have not properly solved this puzzle. I have two solutions that pass all test cases and all validators. One solution uses a combination of logic and Algorithm X. The other places all rooks logically, leaving no need for Algorithm X. Both solutions will produce the wrong answer for other test cases not included in the puzzle.</p> <p>The following pages outline my still-imperfect approach.</p>"},{"location":"20-your-turn/01-harmless-rooks/#problem-statement","title":"Problem Statement","text":"<p>Harmless Rooks is a hard puzzle, but a very short Algorithm X setup can easily solve the first two test cases and get you moving in a powerful direction. Although the Algorithm X setup is not terribly complex, some background is helpful. For convenience, I have copied the entire goal statement here:</p> <p>The rook is a chess piece that can move along its current line (horizontally) or column (vertically) through any number of free (unoccupied) squares.</p> <p>In this problem, we consider an N \u00d7 N generalized chess board where the squares are either free (. in the input) or already occupied (X in the input) and hence cannot be crossed by the rooks.</p> <p>Compute the maximum number of rooks that can be placed on free squares in such a way that no two rooks threaten each other (hence two rooks on the same line/column must be separated by at least one occupied square).</p>"},{"location":"20-your-turn/01-harmless-rooks/#a-perfect-world","title":"A Perfect World","text":"<p>Rooks move along horizontal and vertical lines. On a standard 8 x 8 chessboard, there are 8 rows and 8 columns. A rook placed on location <code>(r, c)</code> threatens all locations in row  <code>r</code> and all locations in column <code>c</code>. Because there is no functional difference between a row and a column, I will refer to all rows and all columns as <code>AttackLine</code>s, an uninterrupted group of 1 or more cells that, together, make a horizontal or vertical line. A rook placed on any location in the <code>AttackLine</code> threatens all other locations in the <code>AttackLine</code>.</p> <p>Placing a single rook on a standard 8 x 8 chessboard covers two <code>AttackLine</code>s, one horizontal and one vertical. On any <code>N x N</code> chessboard, consisting of all free squares, a maximum of <code>N</code> rooks can be placed. Each rook occupies one row and one column. Using this unobstructed chessboard, the following problem could be considered:</p> <p>Given an <code>N x N</code> chessboard with all free squares, how many different ways can <code>N</code> rooks be placed on the board, such that no rook threatens any other rook?</p> <p>How could Algorithm X be set up to solve this problem? What are the requirements? Every one of the <code>N * N</code> <code>AttackLine</code>s must be covered by a rook. What are the actions? Each action is simply placing a rook at location <code>(r, c)</code> and each action coves two requirements, one for each <code>AttackLine</code> coved by the rook placement.</p> <p>Asking Algorithm X to find the number of possible configurations for values of <code>N</code> between 2 and 10 results in the following:</p> N Valid Configurations 2 2 3 6 4 24 5 120 6 720 7 5040 8 40320 9 362880 10 3628800 <p>It is not difficult to show that for any <code>N x N</code> chessboard, there are <code>N</code> factorial ways to arrange the rooks. However, I chose to illustrate how Algorithm X could produce these results to lay the groundwork for an Algorithm X approach to the oddly configured boards found in Harmless Rooks.</p>"},{"location":"20-your-turn/01-harmless-rooks/#handling-occupied-spaces","title":"Handling Occupied Spaces","text":"<p>Harmless Rooks has some large boards with many spaces already occupied. Since rooks cannot cross occupied squares, each occupied square either shortens an <code>AttackLine</code> or divides an <code>AttackLine</code> into two separate lines. Even a single location, bordered on all sides by occupied spaces, forms two <code>AttackLine</code>s, one horizontal and one vertical. Placing a rook on that isolated space occupies both <code>AttackLine</code>s.</p> <p>On a board with no occupied spaces, the maximum number of rooks is always <code>N</code>. Each rook placed covers one column and one row. Said another way, each rook covers exactly two <code>AttackLine</code>s and all <code>AttackLine</code>s are covered. As soon as occupied spaces show up on a board, it can get much more difficult to cover every <code>AttackLine</code>. The following diagrams shows all <code>AttackLine</code>s on a 5 x 5 board with a single edge square occupied.</p> <p></p> <p>The board now has 11 <code>AttackLine</code>s. Each rook placed covers exactly 2 <code>AttackLine</code>s, making it impossible to cover every <code>AttackLine</code>. However, we might consider asking Algorithm X to attempt the following:</p> <p>Try to cover every <code>AttackLine</code> by placing rooks on open squares. If no solution exists that covers all <code>AttackLine</code>s, return the length of the partial solution that gets the closest.</p> <p></p>"},{"location":"20-your-turn/02-harmless-rooks-cont/","title":"Harmless Rooks (cont.)","text":"<p>On the previous page, the following task was proposed for Algorithm X:</p> <p>Try to cover every <code>AttackLine</code> by placing rooks on open squares. If no solution exists that covers all <code>AttackLine</code>s, return the length of the partial solution that gets the closest.</p> <p>Algorithm X is designed to be efficient, and it is extremely efficient at identifying when paths are dead ends. As soon as Algorithm X determines a path will eventually be a dead end, all forward exploration stops and the algorithm backtracks. Without any customization, Algorithm X can quickly determine if all <code>AttackLine</code>s can be covered, but it is not designed to tell us how close it can get to a proper solution when no full solution is possible.</p>"},{"location":"20-your-turn/02-harmless-rooks-cont/#customizing-algorithm-x-to-be-inefficient","title":"Customizing Algorithm X To Be Inefficient","text":"<p>How does Algorithm X know when a path is a dead end? The matrix has at least one requirement that no longer has any rows that cover it. Since it is impossible for one of the (mandatory) requirements to be satisfied, Algorithm X backtracks. <code>AlgorithmXSolver</code> implements this process by sorting requirements by the number of rows remaining that cover each requirement, often referred to as Minimum Remaining Value (MRV). Columns that are not covered by any rows are sifted to the front of the line and Algorithm X immediately knows it is time to backtrack. This default behavior is found in the <code>AlgorithmXSolver</code> method <code>_requirement_sort_criteria()</code> as shown below. </p> <pre><code>    def _requirement_sort_criteria(self, col_header: DLXCell):\n        return col_header.size\n</code></pre> <p>The <code>size</code> attribute of a <code>DLXCell</code> is only meaningful when the <code>DLXCell</code> instance is a column header and it keeps track of the number of rows that still cover the requirement. <code>AlgorithmXSolver</code> will sort all remaining requirements by the number of rows covering each requirement and then pick the requirement with the minimum remaining value (number of rows).</p> <p>In this puzzle, occupied cells most likely create boards where Algorithm X cannot cover every <code>AttackLine</code> and I don\u2019t want Algorithm X to backtrack just because it finds one <code>AttackLine</code> that cannot be covered. Instead, I want Algorithm X to keep placing rooks until none of the remaining <code>AttackLine</code>s can be covered. This is easily accomplished simply be reversing the sort order to push requirements that cannot be covered to the end of the line. To implement this in your solver, override the <code>_requirement_sort_criteria()</code> method as follows:</p> <pre><code>    def _requirement_sort_criteria(self, col_header: DLXCell):\n        return -col_header.size\n</code></pre> <p>A single <code>-</code> sign is all that is needed! As long as a rook can be placed, Algorithm X will continue exploring, looking for a solution that covers all <code>AttackLine</code>s. Backtracking will only happen when the matrix shows that none of the remaining <code>AttackLine</code>s can be covered by any rook placement. </p>"},{"location":"20-your-turn/02-harmless-rooks-cont/#counting-rooks","title":"Counting Rooks","text":"<p>Just a few lines of code can customize your solver to keep track of the maximum number of rooks placed. First add two attributes in your solver\u2019s constructor:</p> <pre><code>self.rooks_placed = 0\nself.most_rooks_placed = 0\n</code></pre> <p>Then, because each action (row) is the placement of a rook at a particular location, the following overrides will keep track of the current number of rooks placed and the max number of rooks placed:</p> <pre><code>    def _process_row_selection(self, row):\n        self.rooks_placed += 1\n        self.max_rooks_placed = max(self.rooks_placed, self.max_rooks_placed)\n\n\n    def _process_row_deselection(self, row):\n        self.rooks_placed -= 1\n</code></pre> <p>We now have a fully functional solver that can finish test cases 1 and 2, but you will probably run into timeout issues after that. To solve the remaining test cases, you will need to find ways to reduce the problem space by placing rooks logically.</p> <p></p>"},{"location":"20-your-turn/03-harmless-rooks-cont/","title":"Harmless Rooks (cont.)","text":"<p>Harmless Rooks fits the same cells and groups model used on many of the previous puzzles. Each open <code>Square</code> on the board has a relationship with exactly 2  <code>AttackLine</code>s and each <code>AttackLine</code> has a relationship with 1 or more <code>Square</code>s.</p> <p></p> <p>A <code>Square</code> is uniquely identified by its <code>row</code> and <code>col</code>, but it is a bit more challenging to uniquely identify an <code>AttackLine</code>. In the class diagram above, I have added an integer <code>id</code> for each <code>AttackLine</code>. Each class also has a <code>reduce_()</code> method as seen in many puzzles before.</p>"},{"location":"20-your-turn/03-harmless-rooks-cont/#problem-space-reduction","title":"Problem-Space Reduction","text":"<p>What does it mean to reduce a <code>Square</code> or an <code>AttackLine</code>? Somehow, we need to shrink the size of the larger boards by placing rooks logically. Consider the following diagram where three <code>X</code> locations isolate a single <code>Square</code>:</p> <p></p> <p>Obviously, a rook can be placed on the isolated <code>Square</code>. Placing a rook in that location does not change what is possible with the rest of the board. Now, consider the following diagram where four <code>X</code> locations isolate a group of two <code>Squares</code>:</p> <p></p> <p>Placing a rook on either <code>Square</code> in the isolated area will eliminate 3 <code>AttackLine</code>s from the game, the two covered by the rook and the second <code>AttackLine</code> covered by the other location that is now ineligible for a rook. In this case, placing a rook on each <code>Square</code> does the same amount of damage to the board. Because these two <code>Square</code>s are isolated and neither causes more damage than the other, a rook can be placed on either <code>Square</code>, eliminating the other <code>Square</code> from consideration.</p> <p>Every time you find a location where a rook can be placed logically, <code>AttackLine</code>s and <code>Square</code>s are eliminated from future consideration. This process shrinks the size of the problem since Algorithm X only needs to know about <code>AttackLine</code>s and <code>Square</code>s that must be considered to determine the maximum rook placements going forward.</p>"},{"location":"20-your-turn/03-harmless-rooks-cont/#on-to-the-puzzle","title":"On to the Puzzle","text":"<p>To solve this puzzle with the Algorithm X implementation discussed in the previous pages, you must figure out ways to place many more rooks logically. We already handicapped Algorithm X by customizing it to be inefficient. The boards it can solve need to be a lot smaller than the large test cases.</p>"},{"location":"20-your-turn/03-harmless-rooks-cont/#repeat-disclaimer","title":"Repeat Disclaimer","text":"<p>I have not properly solved this puzzle. I have two solutions that pass all test cases and all validators. One solution uses a combination of logic and Algorithm X. The other places all rooks logically, leaving no need for Algorithm X. Both solutions will produce the wrong answer for other test cases not included in the puzzle.</p> <p>The previous pages outline my still-flawed approach.</p> <p></p>"},{"location":"20-your-turn/04-assorted-rectangular-pieces/","title":"Assorted Rectangular Pieces Puzzle","text":"<p>Kata: Assorted Rectangular Pieces Puzzle</p> <p>Sensei: @docgunthrop</p> <p>Published Difficulty: 2 kyu</p> <p>Algorithm X Complexity: No Worse than Trying to Survive a Zombie Apocalypse</p>"},{"location":"20-your-turn/04-assorted-rectangular-pieces/#strategy","title":"Strategy","text":"<p>This puzzle on Codewars is a complex exact cover problem. You are given a number of rectangular puzzle pieces and you need to use those pieces to cover all the open locations on the puzzle board. Pieces can be rotated if necessary. The Sample Test Suite has 5 test cases and the last 3 test cases all have shapes that repeat. Because there might be multiple shapes with the same size (e.g. multiple <code>2 x 3</code> shapes or multiple <code>3 x 5</code> shapes), you need to put together a strong Algorithm X model to handle multiplicity.</p> <p>Once you get a working Algorithm X setup, the real work begins. When you attempt to pass the full test suite, you get 12 seconds to complete 75 tests. I was stuck for quite a while timing out on many different variations of my solver. I tried every technique discussed in this playground.</p> <p>Right after you call the inherited <code>AlgorithmXSolver</code> constructor, add this line of code to print the number of columns and rows in the matrix:</p> <pre><code>        print(len(requirements), len(actions), file=sys.stderr, flush=True)\n</code></pre> <p>With my Algorithm X setup, a number of the 75 test cases have between 3000 and 5000 rows. One test case actually has many more rows than that. What does this tell you? It should tell you the matrix is big, and influencing how Algorithm X chooses columns and/or chooses rows could make a significant difference.</p>"},{"location":"20-your-turn/04-assorted-rectangular-pieces/#a-confession","title":"A Confession","text":"<p>I placed this puzzle in this section for a reason. Setting up Algorithm X for this puzzle requires strong attention to detail, but getting Algorithm X to find solutions for the easy test cases is not the toughest part. Optimization is where you will find the most significant challenge.</p> <p>My original solution used a clever combination of dynamic sorting for both columns and rows. I kept track of remaining open cells on the gameboard, among several other things, and made various sorting decisions based on that information. Now that my understanding of Algorithm X is much better, my current solution does not use any dynamic sorting. The ordering of rows and columns in my matrix is still very important, but I handle prioritization when the matrix is created.</p>"},{"location":"20-your-turn/04-assorted-rectangular-pieces/#making-your-solution-fast","title":"Making Your Solution Fast","text":"<p>If you want to maximize speed, you might need to add some problem-space reduction. Are there any ways you can reduce the size of the problem before building the matrix for Algorithm X? Keep in mind that this process takes time. If you attempt to add problem-space reduction, is there a way you can quantify how much benefit you get and at what cost?</p> <p></p>"},{"location":"21-final-exam/01-explanation/","title":"Final Exam Exercises","text":"<p>Each puzzle in this section was chosen because it can be expressed as an exact cover problem, and the Algorithm X setup is straightforward. These puzzles will test your understanding of Algorithm X without requiring any problem-space reduction or complex action enumeration strategies.</p> <p>After finishing each one, take a moment to review only the code you wrote. Reflect on the time and effort it took to pass all test cases. When you consider the <code>AlgorithmXSolver</code> code you had to include in your source file, your solution might feel like \u201coverkill.\u201d But imagine if that solver came from a library you simply imported \u2014 would it feel the same? You might instead appreciate how much Algorithm X streamlined the process and how powerful it is to have a reusable architecture that handles a wide range of structurally similar problems once the details are abstracted away.</p> <p>Good luck \u2014 and enjoy the elegance of Algorithm X!</p> <p></p>"},{"location":"21-final-exam/02-periodic-table-spelling/","title":"Periodic Table Spelling","text":"<p>Puzzle: Periodic Table Spelling</p> <p>Author: @Edjy</p> <p>Published Difficulty: Easy</p> <p>Algorithm X Complexity: A Benchmarking Opportunity</p>"},{"location":"21-final-exam/02-periodic-table-spelling/#overview","title":"Overview","text":"<p>It is not often an opportunity comes along to test your skills on an exact-cover puzzle classified as \u201ceasy\u201d. If you have completed a reasonable portion of this playground, you should be able to fly through this puzzle. I suggest you take this opportunity to test your knowledge and benchmark your learning. Use the following questions to reflect on your results:</p> <ul> <li>How much of your <code>AlgorithmXSolver</code> subclass were you able to write from memory?</li> <li>How many syntax errors did you need to correct?</li> <li>Did you make errors setting up your requirements and actions?</li> <li>How long did it take before you had a full solution?</li> </ul> <p>In my introduction to this playground, I made a handful of promises, including:</p> <ul> <li>You will become proficient with a powerful and repeatable problem-solving technique known as Algorithm X.</li> <li>You will experience the compelling nature of reusable software architectures.</li> <li>You will find [puzzles] significantly easier than [they] would have been otherwise.</li> <li>You will have a lot of fun.</li> </ul> <p>My hope is that this benchmarking exercise demonstrates why I made those promises.</p> <p></p>"},{"location":"21-final-exam/03-kids-blocks/","title":"Kids Blocks","text":"<p>Puzzle: Kids Blocks</p> <p>Author: @MNada</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: A Perfect Exam Exercise</p>"},{"location":"21-final-exam/03-kids-blocks/#overview","title":"Overview","text":"<p>We were all little architects once \u2014 stacking blocks into wobbly towers, knocking them down with laughter, and building them up again. In those moments, we weren\u2019t just making castles; we were discovering creativity, curiosity, and the joy of endless possibilities.</p> <p>This puzzle offers another chance to build \u2014 this time with Algorithm X. The matrix setup isn\u2019t difficult, but you\u2019ll need more than the basics to avoid timing out on the tougher test cases. With thoughtful optimization, every test and validator can be solved in under about 5% of the time limit (Python).</p> <p>It\u2019s also a good reminder that Algorithm X isn\u2019t always the entire solution. Sometimes, it\u2019s just one elegant piece of a larger design \u2014 even for puzzles of only moderate difficulty.</p> <p></p>"},{"location":"21-final-exam/04-depot-organization/","title":"Depot Organization","text":"<p>Puzzle: Depot Organization</p> <p>Author: @Unihedron</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Straightforward</p>"},{"location":"21-final-exam/04-depot-organization/#overview","title":"Overview","text":"<p>This puzzle has only 7 tiles that need to be arranged on 7 locations on the gameboard. At this point in your journey, that description should set off your exact cover alarm bells! This couldn\u2019t be more straightforward, could it? Conceptually, that is true, but a couple of quirks make this puzzle a very enjoyable challenge.</p> <p>Working with hexagons brings a little complexity to this otherwise reasonable puzzle. For more practice with hexagons, check out the following (not exact cover) challenges on CodinGame:</p> <p>Hexagonal Maze by @Remi.</p> <p>Hexagonal Maze \u2013 part 2 by @Remi.</p> <p>Coders of the Caribbean \u2013 Bot Programming</p> <p>After finishing this puzzle, be sure to take a look at Picture Puzzle where you will work with more puzzle pieces, but at least the pieces are square!</p> <p></p>"},{"location":"21-final-exam/05-fix-the-spaces/","title":"Fix the Spaces","text":"<p>Puzzle: Fix the Spaces</p> <p>Author: @Rafarafa</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Straightforward</p>"},{"location":"21-final-exam/05-fix-the-spaces/#overview","title":"Overview","text":"<p>Two years passed between my original solution to this puzzle and my new approach using Algorithm X. My memory may not be as sharp as it once was, but I clearly remember enjoying the challenge. Looking back at that old code, it\u2019s obvious I poured a lot of thought into logically narrowing down possibilities to reach a solution. With a little review, I\u2019m confident I could still follow what it\u2019s doing.</p> <p>In contrast, it took me only a few minutes to construct an exact cover solution with Algorithm X. It looks like so many other solutions I\u2019ve built since. The joy this time isn\u2019t in the grind \u2014 it\u2019s in the grace. There\u2019s real satisfaction in watching a medium-difficulty puzzle fall quickly and elegantly. It feels like playing 2-on-2 basketball with a 7-foot-3 teammate who dunks every pass I toss.</p> <p></p>"},{"location":"22-2025-and-beyond/01-overview/","title":"Going Forward","text":"<p>This playground was first published in December 2024. I have no doubt many more exact cover problems will come my way, and I look forward to seeing how well the techniques laid out here apply to each one.</p> <p>Instead of inserting new puzzles into the sections to which they might have been assigned during playground construction, those puzzles will be placed here. My hope is to provide an overview of each puzzle, but maybe a bit less guidance as to which techniques I believe fit the puzzles best.</p> <p>If you find a puzzle you would like me to consider adding to this section, please leave a comment or reach out to me in the CodinGame Forum. Below are links to all the major topics you may want to revisit if you get stuck. Good luck!</p>"},{"location":"22-2025-and-beyond/01-overview/#actions","title":"Actions","text":"<p>The individual steps you can take to build a solution.</p>"},{"location":"22-2025-and-beyond/01-overview/#requirements","title":"Requirements","text":"<p>The necessary details a solution must satisfy.</p>"},{"location":"22-2025-and-beyond/01-overview/#optional-requirements","title":"Optional Requirements","text":"<p>Details a solution may or may not satisfy, but if satisfied, they must only be satisfied one time.</p>"},{"location":"22-2025-and-beyond/01-overview/#mutual-exclusivity","title":"Mutual Exclusivity","text":"<p>Using optional requirements to enforce situations where two elements must not both be part of the same solution.</p>"},{"location":"22-2025-and-beyond/01-overview/#multiplicity","title":"Multiplicity","text":"<p>Handling situations where certain requirements must be covered more than one time.</p>"},{"location":"22-2025-and-beyond/01-overview/#problem-space-reduction","title":"Problem-Space Reduction","text":"<p>Using logic to solve part of a problem, leaving a more manageable task for Algorithm X.</p>"},{"location":"22-2025-and-beyond/01-overview/#steering-algorithm-x","title":"Steering Algorithm X","text":"<p>Keeping track of your problem's state outside the Algorithm X matrix so you can redirect Algorithm X when certain search paths are known to lead to dead ends.</p>"},{"location":"22-2025-and-beyond/01-overview/#coloring-your-requirements","title":"Coloring Your Requirements","text":"<p>Handling situations where certain requirements may be covered more than one time as long as they are covered by the same \u201ccolor\u201d.</p>"},{"location":"22-2025-and-beyond/01-overview/#all-or-none-sets-of-events","title":"All-or-None Sets of Events","text":"<p>Identifying situations where certain actions must happen together or certain elements must be the same.</p>"},{"location":"22-2025-and-beyond/01-overview/#enforcing-sameness-with-complex-actions","title":"Enforcing Sameness with Complex Actions","text":"<p>Bundling simple steps into a group of steps that must be added to a solution as a whole.</p>"},{"location":"22-2025-and-beyond/01-overview/#customizing-your-solvers-row-andor-column-selection","title":"Customizing Your Solver\u2019s Row and/or Column Selection","text":"<p>Influencing the order in which Algorithm X selects columns and/or rows as it searches the matrix for solutions.</p> <p></p>"},{"location":"22-2025-and-beyond/02-who-dunnit/","title":"Who Dunnit?","text":"<p>Puzzle: Who Dunnit?</p> <p>Author: @David Augusto Villa</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Well-Hidden Exact Cover, but Straightforward Setup</p>"},{"location":"22-2025-and-beyond/02-who-dunnit/#strategy","title":"Strategy","text":"<p>Spoiler Alert: This puzzle is an exact cover problem. </p> <p>Why do I feel the need to issue that spoiler alert? I believe the hardest part of this puzzle is figuring out that it is, indeed, an exact cover problem. The exact cover is very cleverly hidden by both the structure of the puzzle and the author\u2019s instructions, but it is there, and once you see it, setting up Algorithm X becomes straightforward.</p> <p>Hopefully, the requirements are jumping out at you. One clue must be identified from each set of evidence. The next steps get a bit more difficult.</p> <p>The most important part of solving this puzzle with Algorithm X will be how you choose to model the problem as tiles on a gameboard. What are the tiles? What does the gameboard look like? Ultimately, you need to identify a culprit, but how are you placing tiles on a gameboard to get to a place where the culprit is easily identified?</p> <p>What do I mean by \u201ccleverly hidden\u201d? My tiles on a gameboard analogy went through 4 iterations before I felt like I truly understood how to best model the task at hand. That alone is another spoiler: if you are stuck, try to find other ways of looking at your tiles on a gameboard analogy.</p> <p></p>"},{"location":"22-2025-and-beyond/03-picture-puzzle/","title":"Picture Puzzle","text":"<p>Puzzle: Picture Puzzle</p> <p>Author: @Teiglin</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Eliminating Invalid Actions Keeps Algorithm X Complexity Reasonable</p>"},{"location":"22-2025-and-beyond/03-picture-puzzle/#strategy","title":"Strategy","text":"<p>I was an original reviewer of this puzzle submission in February, 2023. At that time, I was fairly new to Algorithm X and seeing the puzzle as an exact cover never crossed my mind. Recently, @VizGhar asked if the Eternity II puzzle could be solved with Algorithm X. Thinking about this question led me to revisit this puzzle.</p> <p>The tiles on a gameboard analogy for this puzzle is straightforward. The tiles are the puzzle pieces (could it really be that simple?) and the gameboard is a grid of locations where the puzzle pieces must be placed. A basic Algorithm X setup will quickly solve all test cases except Test Case 2 and Test Case 6.</p> <p>Although I called it a \"basic\" Algorithm X setup, enumerating all possible actions is challenging. Still, I believe getting Algorithm X to work as specified above is a strong approach. To solve Test Case 2 and Test Case 6 requires some problem-space reduction.</p> <p>Because I found the problem-space reduction for this puzzle so enjoyable, I am going to share my approach here. Before clicking, give it a try on your own. I learned a lot comparing my original approach to my new approach that has been heavily influenced by this playground.</p> Spoiler Alert: Do not click unless you have tried it yourself! <p>Is this Picture Puzzle really much different than a Sudoku? The pieces need to be properly placed on a grid of locations I call <code>PuzzleCell</code>s. Let\u2019s assume we have a 5x5 puzzle to solve. The basic puzzle grid is shown in the next figure. Just like in Sudoku, I put space between each <code>PuzzleCell</code>. My reasons for doing this will be revealed shortly.</p> <p></p> <p>Before digging deeper into the gameboard, consider the pieces for a moment. When doing a picture puzzle on your kitchen table, you might first sort the pieces into the three groups shown below.</p> <p></p> <p>Corner pieces have 2 puzzle borders, non-corner edge pieces have a single puzzle border and middle pieces have no puzzle borders. This initial sorting already limits the candidates for each cell. In the following diagram, the color of each cell corresponds to the group of pieces that make up the cell\u2019s initial candidates.</p> <p></p> <p>Does this mean there are only 4 candidates for each corner piece? Yes, it does, but that is a bit misleading. A puzzle piece alone is not enough to properly distinguish one candidate from another in the middle of the puzzle. On the corners and edges, the puzzle border limits each puzzle piece to a single possible rotation. Middle pieces are different. </p> <p>In the middle of the puzzle, each piece might look different when rotated. Each unique rotation is a distinct candidate. In the 5x5 puzzle above, there are 9 middle pieces, meaning each location has up to 36 possible candidates. (Exercise for the reader: Why did I say \u201cup to\u201d?)</p> <p>In the next figure, the blue rectangles represent the puzzle border.</p> <p></p> <p>These borders are interesting because they too have candidates. I have intentionally spaced out the blue rectangles to make them align with their adjacent pieces. The middle pieces also have interesting borders. Adding all the piece borders to the diagram results in:</p> <p></p> <p>Why are these borders interesting? Each border has a set of possible values. Look at the edge pieces first. Each edge piece border, adjacent to the puzzle border, only has a single possible value. Keeping track of possible values for every blue border is critical to reducing the candidates for each cell.</p> <p>Consider the corner cell in the top left corner. At most, that cell has only 4 candidates: each of the four corner pieces, properly rotated to align the borders to match the left and top borders that only have one possible value. Using these four candidates, the possible values of the bottom and right borders (of cell <code>(0, 0)</code>) can be determined.</p> <p>Now move to the cell in <code>(row 0, column 1)</code>. The top border is limited to the puzzle border. The left border has limited possibilities that were just determined. It is now easy to loop through the candidates for this cell <code>(0, 1)</code> and eliminate candidates that violate the border possibilities. From the remaining candidates, the possibilities for the 4 borders of cell <code>(0, 1)</code> may be updated appropriately.</p> <p>I then use the exact same reducing loop, discussed many times in this playground, to loop through the rows and columns of the grid over and over until a full pass through the grid does not produce any changes.</p> <p>At this point, all cells are reduced to a single candidate for Test Cases 1 \u2013 3 and 5 \u2013 7. I will leave it to you to figure out why Test Case 4 and Test Case 8 cannot be reduced all the way to a single candidate per cell (unless you add a tiny bit more logic).</p> <p></p>"},{"location":"22-2025-and-beyond/03-picture-puzzle/#a-bit-about-solution-design","title":"A Bit About Solution Design","text":"<p>In the next diagram, I have greyed out either the horizontal borders or the vertical borders.</p> <p></p> <p>These figures make it easier to see a 6 x 5 array of horizontal borders and a 5 x 6 array of vertical borders. Ultimately every cell needs to know about 4 borders, the top, bottom, left and right. The perspective demonstrated in the figure above nicely facilitates assigning borders to a cell based on that cell\u2019s row and column.</p>"},{"location":"22-2025-and-beyond/03-picture-puzzle/#observations","title":"Observations","text":"<p>At first glance, I would never expect this much overlap between a picture puzzle and a Sudoku. I was happy enough with my original solution to this puzzle, but I am thrilled with my new approach. It is no secret that I love repeatability and seeing how similar my new solution is to every solution I built for the logic puzzles covered earlier makes my new approach significantly more powerful in my eyes.</p>"},{"location":"22-2025-and-beyond/04-nonogram-inversor/","title":"Nonogram Inversor","text":"<p>Puzzle: Nonogram Inversor</p> <p>Author: @LaurentBouvier</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Quite Challenging</p>"},{"location":"22-2025-and-beyond/04-nonogram-inversor/#spoiler-alert","title":"Spoiler Alert","text":"<p>Here I go again with a preemptive spoiler alert. This puzzle might be easier to solve with logic than it is to solve with Algorithm X. However, the Algorithm X solution is wonderfully satisfying if you choose to go down that fairly challenging path.</p>"},{"location":"22-2025-and-beyond/04-nonogram-inversor/#what-i-and-others-tried","title":"What I (and others) Tried","text":"<p>From the problem statement:</p> <p>In this version, we have only two colors, black and white.</p> <p>You will be given the length of all black groups.</p> <p>For each row and each column, we are given the lengths of each group of contiguous black cells in that row or column. I am going to refer to a group of 1 or more contiguous black cells as a segment. Each segment must be separated by 1 or more white cells. Because there is no difference between a row of cells and a column of cells, I will use the word line to generically refer to either a row or a column. Each line has some number of cells and zero or more segments. </p> <p>Consider a 5 x 5 Nonogram. My initial thought was to have a 5 x 5 gameboard and then determine all possible layouts for each line. All lines must be covered by a pattern. The various patterns for each line are the tiles that get placed on the gameboard. Because horizontal lines and vertical lines intersect, I considered using coloring or significant numbers of <code>me_requirements</code> to ensure incompatible lines were not placed in the same solution.</p> <p>Using this approach, I was able to solve Test Cases 1 and 2, but I timed out on the remaining test cases. There can be many possible patterns for a line that has multiple segments and there can be many combinations of horizontal and vertical lines that are incompatible. I needed my solution to be significantly faster, so I turned to problem-space reduction.</p> <p>Once you go down the road of problem-space reduction on this puzzle, it doesn\u2019t take long to find solutions strictly using logic. With a solution in hand, you might wonder why anyone would continue banging his or her head against the wall searching for the Algorithm X solution. Maybe you enjoy the challenge, or maybe you just embrace the pain. Either way... </p> <p>On the next page, I will go through how I built an Algorithm X solution to this puzzle.</p> <p>If you enjoy Nonograms, @5DN1L turned me on to 3 more Nonogram puzzles on Codewars with increasing levels of difficulty:</p>"},{"location":"22-2025-and-beyond/04-nonogram-inversor/#5x5-nonogram-solver","title":"5x5 Nonogram Solver","text":"<p>Kata: 5x5 Nonogram Solver</p> <p>Sensei: @Avanta</p> <p>Published Difficulty: 4 kyu</p> <p>Solving this first puzzle is slightly easier than CodinGame's Nonogram Inversor. As a doctor once said to my wife in his thick Eastern-European accent, \"Don't worry, it will get worse.\"</p>"},{"location":"22-2025-and-beyond/04-nonogram-inversor/#15x15-nonogram-solver","title":"15x15 Nonogram Solver","text":"<p>Kata: 15x15 Nonogram Solver</p> <p>Sensei: @Bubbler</p> <p>Published Difficulty: 2 kyu</p> <p>In this puzzle, you must solve 103 Nonograms in 12 seconds (Python). My original logic-based solution needed significant optimization to pass all the test cases without timing out.</p>"},{"location":"22-2025-and-beyond/04-nonogram-inversor/#multisize-nonogram-solver","title":"Multisize Nonogram Solver","text":"<p>Kata: Multisize Nonogram Solver</p> <p>Sensei: @Avanta</p> <p>Published Difficulty: 1 kyu</p> <p>I have not solved this puzzle yet. There are 60 random tests and I am only getting through the first half of those tests before timing out. I definitely need a faster approach, but the following line from the problem statement makes me wonder if I will eventually need a combination of logic and Algorithm X:</p> <p>I highly recommend not to try and use a brute force solution as some of the grids are very big. Also, you may not be able to solve all the grids by deduction alone so may have to guess one or two squares. :P</p> <p>As for a better algorithm, Donald Knuth has something to say about that! (credit again goes to @5DN1L for finding this material). Are Binary Decision Diagrams (BDDs and ZDDs) possibly what we need? I don't know the answer to that, but here are a couple of links that might lead you to some answers:</p> <ul> <li> <p>Stanford Lecture: Donald Knuth - \"Fun With Binary Decision Diagrams (BDDs)\" (June 5, 2008)</p> </li> <li> <p>Stanford Lecture: Donald Knuth\u2014\"Fun With Zero-Suppressed Binary Decision Diagrams (ZDDs)\" (2008)</p> </li> <li> <p>Ben Lynn - BDDs, ZDDs, Nonograms, etc.</p> </li> </ul> <p></p>"},{"location":"22-2025-and-beyond/05-nonograms-with-algorithm-x/","title":"Nonogram Inversor with Algorithm X","text":"<p>Puzzle: Nonogram Inversor</p> <p>Author: @LaurentBouvier</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Quite Challenging</p>"},{"location":"22-2025-and-beyond/05-nonograms-with-algorithm-x/#strategy","title":"Strategy","text":"<p>My Algorithm X approach does not do any problem-space reduction before searching for a solution. In the end, I looked at the problem in a way that did not occur to me until another CodinGamer made a comment that sent me down a path I never considered.</p> <p>As I alluded to on the previous page, I eventually gave up on placing an entire line of cells on the Nonogram gameboard all in a single action. I will go through my approach in steps in case just one or two hints help you cross the finish line.</p> Hint #1: A Little Inspiration from @VizGhar <p>In a Discord message, @VizGhar said to me:</p> <p>My actions are:</p> <ul> <li>Placing [segments] vertically/horizontally marking those spaces for half a point.</li> <li>Placing empty spaces for full point.</li> </ul> <p>Although I don\u2019t use \u201cpoints\u201d, his idea of 1/2 points and full points led me to my eventual solution, which I think feels very elegant, primarily because of his points idea.</p> Hint #2: Reverse Engineering <p>To understand how I set up my Algorithm X matrix, consider the following debug output for Test Case 1 - Dog:</p> <pre><code>len(actions)=65\nlen(requirements)=63\nlen(me_requirements)=4\n</code></pre> Spoiler #1: Tiles on a Gameboard <p>Following @VizGhar\u2019s lead, my tiles are either segments or single white space cells. The entire Nonogram gameboard must be covered by some combination of segments and white spaces. Placing a segment on the gameboard never includes any white space and placing a white space on the gameboard never covers any more than a single 1x1 cell.</p> Spoiler #2: Requirements <p>@VizGhar had a great idea with his 1/2 points and full points. All I did was convert that idea to language that felt closer to what I had done on all the puzzles before.</p> Show me the money! <ul> <li>All cells must be covered horizontally.</li> <li>All cells must be covered vertically.</li> <li>All segments must be placed on the gameboard.</li> </ul> Spoiler #3: Actions <p>I cannot take much credit for this. My actions match @VizGhar's actions exactly. It is unusual for me to have two different types of actions, but to cover the entire gameboard, it worked nicely here.</p> <ul> <li>place segment</li> <li>place white space</li> </ul> <p>Where this really gets interesting is in the process of identifying a full list of locations that are options for the placement of each segment. Based on the other segments in the line, the options are more limited than you might think.</p> Spoiler #4: Mutual Exclusivity <p>For any two contiguous segments in a single line, each action of placing the first segment (segment 1) must be considered with each action of placing the second segment (segment 2). An <code>me_requirement</code> is needed if:</p> <ul> <li>The two segments do not overlap and...</li> <li>Segment 2's placement is earlier than the right end of segment 1 + two spaces.</li> </ul> <p>Quiz: Why is an <code>me_requirement</code> not needed if the segments overlap?</p> Spoiler Wrap-Up <p>When first considering this puzzle, the overlap of rows and columns seems like it might be the most challenging part. Breaking the covering of each cell into 2 requirements, one for the horizontal covering and one for the vertical covering, magically makes sure all row/column conflicts are avoided and simplifies the Algorithm X setup. Enumerating all possible actions and identifying mutually exclusive actions will still take significant attention to detail, but the end result is well worth it!</p> <p>Good luck!</p> Quiz Answer <p>A pair of actions that try to place overlapping segments are already mutually exclusive because each action covers 1 or more of the same primary requirements.</p> <p></p>"},{"location":"22-2025-and-beyond/06-polyominoes/","title":"Polyominoes","text":"<p>Puzzle: Polyominoes</p> <p>Author: @VizGhar</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Textbook Exact Cover</p> <p></p>"},{"location":"22-2025-and-beyond/06-polyominoes/#strategy","title":"Strategy","text":"<p>Donald Knuth covers Algorithm X and Dancing Links in The Art of Computer Programming, Volume 4B Combinatorial Algorithms, Part 2. The PDF I purchased from informIT is 734 pages! In November, 2000, Knuth published a 26 page PDF titled Dancing Links on arXiv.org where it can be downloaded for free.</p> <p>Knuth\u2019s short paper is a great read. Not only does he cover Dancing Links in detail, he provides some interesting history of exact cover research and some powerful combinatoric data. Most importantly (for this page of this playground anyway), he provides significant detail on applying Algorithm X to Pentominoes, a subset of Polyominoes where every puzzle piece is made up of exactly 5 squares. Knuth\u2019s Pentominoes explanation should provide any guidance you need to finish this puzzle.</p> <p>Polyominoes uses the CodinGame Game Engine Software Development Kit (SDK). The SDK provides a viewer used to display a visual aspect to any game. Using the viewer, @VizGhar creates a beautiful visual of the polyominoes, twisting and turning as they gracefully fly across the gameboard and into place. In the words of @darkhorse64, \u201cThis [puzzle] creates a new standard for exact cover puzzles.\u201d</p> <p></p>"},{"location":"22-2025-and-beyond/07-tetrasticks/","title":"Tetrasticks","text":"<p>Puzzle: Tetrasticks</p> <p>Author: @VizGhar</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Textbook Generalized Exact Cover</p> <p></p>"},{"location":"22-2025-and-beyond/07-tetrasticks/#strategy","title":"Strategy","text":"<p>In the previous polyominoes discussion, I mentioned Donald Knuth\u2019s Dancing Links paper on arXiv.org. In that paper, Knuth also covers tetrasticks and I highly recommend studying his approach. Tetrasticks exist on the edges of cells and distinguishing horizontal edges from vertical edges requires great attention to detail, especially when considering various rotations of the game pieces.</p> <p>Rather than rehashing Knuth\u2019s material, I will cover an alternate approach, translating a 5x5 tetrasticks puzzle into an almost equivalent 11x11 polyominoes puzzle. Polyominoes is easily represented with a 2-dimensional array where piece rotations and placement options are not overly complicated. A proper translation is challenging, but you should be able to reuse your polyominoes code with minimal changes.</p>"},{"location":"22-2025-and-beyond/07-tetrasticks/#hey-google-translate-my-puzzle","title":"Hey Google, Translate My Puzzle","text":"<p>Tetrasticks are made of connected edges of a grid. Polyominoes are made of connected cells of a grid. To represent tetrasticks as polyominoes, we need a finer grid resolution that captures every original edge as a cell unit. Consider the following 5x5 tetrasticks gameboard.</p> <p></p> <p>Each edge of the grid is important. In the next diagram, I have placed an orange dot on every edge, overlapping the 6x5 grid of horizontal edges and the 5x6 grid of vertical edges.</p> <p></p> <p>Edge intersections are sometimes important because no two tetrasticks can cross each other. In the following diagram, I have added blue dots on all edge intersections, many of which could be an integral part of a proper solution.</p> <p></p> <p>The cells themselves are not important to a tetrasticks solution, but adding a dot on each cell perfectly fills in the 2-dimensional matrix. In the next diagram, I have covered each cell with a grey dot.</p> <p></p> <p>This 11x11 matrix provides the resolution necessary to capture all the interesting features of a tetrasticks puzzle. Cell edges are no longer important. The edges and every edge intersection of the original puzzle are now represented by cells.</p> <p>In the next diagram, I have replaced each dot with a cell in a 2-dimensional grid. Each white cell is an edge from the original puzzle. Each grey cell is either an edge intersection from the original puzzle or one of the cells in the original puzzle. For clarity, I have added a white <code>X</code> to the 25 cells that made up the original 5x5 tetrasticks puzzle.</p> <p></p> <p>Each cell with an <code>X</code> has 4 empty neighbors, the cell\u2019s original 4 edges that need to be covered by a tetrastick. With this new resolution, the puzzle transforms into finding a way to exactly cover the white cells, but what do the translated tetrasticks look like now?</p> <p>In this final diagram, I have put an <code>F</code> in the upper left corner, a <code>T</code>in the upper right corner, a <code>U</code> in the bottom left corner and a <code>P</code> in the bottom right corner. Each tetrastick is now a group of cells in the translated grid.</p> <p></p>"},{"location":"22-2025-and-beyond/07-tetrasticks/#final-steps","title":"Final Steps","text":"<p>The grid translation has taken shape, but you still need to translate the tetrasticks. In the problem statement, @VizGhar uses the words bounding box, referring to the smallest rectangle that completely contains each tetrastick. Translating each bounding box is the key to properly translating each tetrastick to an equivalent polyomino. Of course, you also need to create a way to identify the tetrastick joints that could be problematic.</p> <p>I began working on this puzzle before finishing polyominoes which allowed me to put some thought into writing code that could be used by both puzzles. Other than my translation code, I only had to add two lines of code to my <code>PolyominoesSolver</code>, one line to build the <code>optional_requirements</code> and a second line to add the appropriate <code>optional_requirements</code> to each action's covered requirements.</p>"},{"location":"22-2025-and-beyond/07-tetrasticks/#translations-in-general","title":"Translations in General","text":"<p>Just like one language can be translated to many other languages, the translation I cover above is not the only way to translate tetrasticks (or any other puzzle) to something more familiar. The important part of a translation is that it simplifies your task. For me, working with the horizontal edges and the vertical edges felt a bit overwhelming. Once I went down the translation path, I was able to build on top of the polyominoes concepts with which I had already become comfortable.</p> <p></p>"},{"location":"22-2025-and-beyond/08-haunted-manor/","title":"Haunted Manor","text":"<p>Puzzle: Haunted Manor</p> <p>Author: @[CG]jupoulton</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: More Confusing than a Svengoolie Movie Marathon</p>"},{"location":"22-2025-and-beyond/08-haunted-manor/#strategy","title":"Strategy","text":"<p>Even in a world overrun by the undead, there\u2019s still room for small moments of warmth \u2014  quiet laughter over a meager meal, the comforting weight of a weapon held steady, the unspoken promise between survivors. In the midst of chaos, resilience isn\u2019t just about fighting to stay alive, but finding reasons to keep going.</p> <p>This puzzle will test your resilience! Before hitting the keyboard, I highly recommend playing the online version, Undead from Simon Tatham\u2019s Portable Puzzle Collection.</p>"},{"location":"22-2025-and-beyond/08-haunted-manor/#object-model","title":"Object Model","text":"<p>A powerful object model can get you started in a good direction, and I invite you to compare this puzzle\u2019s grid to the grid found in High-Rise Buildings. In the latter, I proposed that each <code>CityView</code> has a relationship with <code>N</code> <code>Building</code>s and each <code>Building</code> has a relationship with 4 <code>CityView</code>s. More generically, the relationship could have been characterized as a many-to-many relationship. Each <code>CityView</code> groups together many <code>Building</code>s and each <code>Building</code> is part of many <code>CityView</code>s.</p> <p>The same model appears to work for Haunted Manor. Let\u2019s call the groups <code>Sightline</code>s and say that each <code>Sightline</code> groups together many <code>Cell</code>s, while each <code>Cell</code> can be a member of many <code>Sightline</code>s. Just as was done in High-Rise Buildings, it is tempting to create the following object model.</p> <p></p> <p>Anytime we encounter a many-to-many relationship, it can be beneficial to step back and consider what the relational database folks might do. Since relational databases don\u2019t directly support many-to-many relationships, they are implemented using a junction table (aka bridge table or associative table). The junction table contains foreign keys referencing both tables, and breaks the many-to-many relationship into two one-to-many relationships. In the next diagram, I have inserted a class called a <code>Visual</code> to act similar to a junction table between the <code>Sightline</code> class and the <code>Cell</code> class. </p> <p></p> <p>In coding, we can often move forward without this third class, but not always. Adding this junction class makes sense when each instance has its own interesting attributes. Each <code>Visual</code> represents an instance of one <code>Cell</code> showing up in one <code>Sightline</code>. Are there any important attributes associated with an instance of one <code>Cell</code> in a particular<code>Sightline</code>? Yes, there is!</p> <p>For each <code>Visual</code>, it is important to know if that <code>Visual</code> exists due to normal line of sight or due to reflected line of sight. The concept of a normal, line-of-sight <code>Visual</code> vs. a reflection only exists inside the relationship between one particular <code>Cell</code> and one particular <code>Sightline</code>. In the following diagram, I have added a single Boolean attribute called <code>reflection</code>.</p> <p></p> <p>Our class diagram tells a different story now. Each <code>Cell</code> has a relationship with many <code>Visual</code>s, each <code>Sightline</code> has a relationship with many <code>Visual</code>s, and each <code>Visual</code> has a relationship with exactly one <code>Cell</code> and exactly one <code>Sightline</code>. And the best part is that each <code>Visual</code> knows if it exists due to normal line of sight or reflected line of sight.</p> <p>Consider what is possible with this new model. I can try putting a Vampire in an empty <code>Cell</code>. For each <code>Visual</code> associated with that <code>Cell</code>, I need to know if that <code>Visual</code> exists due to normal line of sight or reflected line of sight. If the <code>reflection</code> attribute is <code>True</code>, the Vampire does not count as being seen in the <code>Sightline</code> because Vampires do not have reflections. However, if the <code>reflection</code> attribute is <code>False</code>, the Vampire does count as being seen in the <code>Sightline</code>.</p> <p>For this puzzle, having a third class to act as a junction is powerful. The <code>reflection</code> attribute does not belong in the <code>Cell</code> class, nor does it belong in a <code>Sightline</code> class. The <code>reflection</code> attribute only makes sense when it describes a single <code>Cell</code> showing up in a <code>Sightline</code>.</p>"},{"location":"22-2025-and-beyond/08-haunted-manor/#path-to-success","title":"Path to Success","text":"<p>With a strong object model, you are ready to construct your Algorithm X matrix. At this point, Haunted Manor and High-Rise Buildings feel a bit more different than similar. Instead, I suggest you revisit your matrix setup for There is No Spoon \u2013 Episode 2 where many of the same concepts can be found.</p> <p>Getting your matrix set up properly is challenging, but Algorithm X will find solutions to all test cases, except the 7x7 manors, very quickly. To solve the 7x7 manors requires some problem-space reduction and that is a wonderful challenge on its own. I needed to really think through sequences of events similar to what I discussed for There is No Spoon \u2013 Episode 2.</p>"},{"location":"22-2025-and-beyond/08-haunted-manor/#i-aint-afraid-of-no-ghosts","title":"I Ain\u2019t Afraid of No Ghosts","text":"<p>I love everything about this puzzle. Creating an abstract object model is challenging. The problem-space reduction is challenging. Creating a solid Algorithm X setup is challenging. If you enjoy a challenge, this puzzle is for you!</p> <p>I\u2019m no fan of scary movies, but some of us grew up with various television shows about ghosts and goblins and hopefully this puzzle brings back fond memories. If you get stuck solving this puzzle, take a break and look for inspiration in this classic 1984 subject-matter video:</p> <p>Ray Parker Jr. - Ghostbusters (Official Video)</p> <p></p>"},{"location":"22-2025-and-beyond/09-completed-mahjong-hands/","title":"Completed Mahjong Hands","text":"<p>Puzzle: Completed Mahjong Hands</p> <p>Author: @Unihedron</p> <p>Published Difficulty: Very Hard</p> <p>Algorithm X Complexity: Do Not Be Frightened by the \"Very Hard\" Label</p>"},{"location":"22-2025-and-beyond/09-completed-mahjong-hands/#overview","title":"Overview","text":"<p>Mahjong is a strategic tile-based game that originated in China, played with 144 tiles featuring Chinese characters and symbols. It requires skill, memory, and calculation as players form specific tile combinations to win.</p> <p>In this puzzle, @Unihedron presents three winning configurations. Your task is to determine whether your hand, plus a newly drawn tile, forms a valid winning combination. While two configurations are relatively simple to check, the third poses a greater challenge\u2014one that may benefit from a well-designed algorithm to simplify implementation. \ud83d\ude09</p> <p>Labeled as \"very hard,\" this puzzle might seem daunting at first. However, the skills you have honed in this playground should make solving it far more approachable than it appears.</p> <p></p>"},{"location":"22-2025-and-beyond/10-crossword/","title":"Crossword","text":"<p>Puzzle: Crossword</p> <p>Author: @Humanosaure</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Uniqueness Provides a Challenge</p>"},{"location":"22-2025-and-beyond/10-crossword/#overview","title":"Overview","text":"<p>Given two horizontal words and two vertical words, this puzzle challenges us to determine whether a valid crossword puzzle can be constructed such that all four words intersect pairwise. In the diagram below, each word's letters have been omitted, but it is easy to imagine how a properly constructed grid might appear.</p> <p></p> <p>To make things slightly more challenging, the author adds an extra twist: we are required to print the solved crossword grid when there is exactly one valid solution. Whether or not you use Algorithm X, constructing the grid is no easy feat \u2014 even when you already know where the four words must go!</p> <p>I found it particularly interesting to frame this puzzle as an exact cover problem. This unique perspective opens the door to some elegant strategies, which I\u2019ll explore in more detail below. But before diving into those details, I strongly encourage you to try solving the puzzle on your own. There are several compelling ways to approach it as an exact cover, and I believe you will find the experience both rewarding and enjoyable.</p> Spoiler Alert: There is no way to go back. <p>The first thing to notice about this puzzle is that all valid solutions form a \"box\", as illustrated in the diagram below. Each box can be as small as 3\u00d73, or as large as <code>min(h1 length, h2 length) \u00d7 min(v1 length, v2 length)</code>. Regardless of its size, the box always plays a central role.</p> <p></p> <p>From the perspective of tiles on a gameboard, each solution consists of just four actions: placing one word across the top, a second across the bottom, a third down the left side, and a fourth down the right. Simple, right? But is it enough to just match four words to four sides? No, it is not.</p> <p>Although the exact size of the box is not known upfront, placing a word on the gameboard must also specify which letters of the word go on the corners of the box. The box is part of the gameboard, but its size is determined by how words are placed\u2014specifically, which letters are used at the corners.</p> <p>In every exact cover problem we have seen so far, a solution was built from a list of actions. To build a solution for this puzzle, each action must now include four key pieces of information: the word being placed, the side it is being placed on, and the indexes of the two letters that land on the box\u2019s corners. An action might look like this:</p> <p><code>('place word', word, side, i, j)</code></p> <p>With this richer action format, valid solutions can be built from just 4 actions. Care must be taken to ensure:</p> <ul> <li>The same letter appears at each corner where sides intersect.</li> <li>Because the box is always a rectangle, the words on opposite sides must have the same distance between their respective corner letters (i.e., the same difference between <code>i</code> and <code>j</code>).</li> </ul> <p>Hopefully, you see the sameness that must be enforced. Let\u2019s explore how that plays out \u2014 using coloring versus mutual exclusivity.</p> <p></p>"},{"location":"22-2025-and-beyond/10-crossword/#enforcing-sameness-with-coloring","title":"Enforcing Sameness with Coloring","text":"<p>In the diagram below, each corner is labeled with a unique integer ID, and two key dimensions are highlighted: the box width and box height. Each action specifies letters that occupy two corners, and those corners, in turn, define either the width or the height of the box.</p> <p>Although only six requirements need to be colored, maintaining consistency across those colors is what guarantees valid solutions.</p> <p></p> <p>Each of these six requirements is colored exactly twice, creating a structure that is highly conducive to using mutual exclusivity.</p>"},{"location":"22-2025-and-beyond/10-crossword/#enforcing-sameness-with-mutual-exclusivity","title":"Enforcing Sameness with Mutual Exclusivity","text":"<p>Whenever possible, I prefer mutual exclusivity over coloring. Mutual exclusivity is a natural fit within Algorithm X, while my coloring approach is a custom adaptation that adds useful power \u2014 but at a cost.</p> <p>In the next diagram, I\u2019ve split each corner into two types of coverage: vertical and horizontal. I\u2019ve also labeled the lengths of all four sides of the box. Because each corner must be covered consistently, a set of <code>me_requirements</code> can be created to enforce that consistency. For example, corner <code>1</code> being covered <code>horizontally</code> with an <code>s</code> is mutually exclusive with the same corner being covered <code>vertically</code> with a <code>g</code>.</p> <p>This technique also applies to the box sides. For instance, the <code>Top</code> having a length of <code>3</code> is mutually exclusive with the <code>Bottom</code> having a length of <code>4</code>.</p> <p></p> <p>There is a fair amount of optimization that can be done when identifying requirements for mutual exclusivity. Only certain letters are valid for each corner in each direction, and only certain lengths are legitimate for each side. Keeping your list of <code>me_requirements</code> as small and focused as possible is crucial if you want to maximize speed and efficiency.</p>"},{"location":"22-2025-and-beyond/11-pips/","title":"Pips","text":"<p>Puzzle: Pips</p> <p>Author: @VizGhar</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Nice Exact Cover / Object-Oriented Design Opportunity</p> <p></p>"},{"location":"22-2025-and-beyond/11-pips/#strategy","title":"Strategy","text":"<p>In August 2025, the New York Times launched a daily logic game called Pips, where players place dominoes onto a grid to satisfy a set of logical conditions defined across different regions. Less than a month later, @VizGhar used the CodinGame SDK to turn Pips into a solo-game coding challenge \u2014 your task is to write a program that can solve any Pips puzzle automatically.</p> <p>The overall difficulty of this challenge falls on the easier end of \u201cmedium.\u201d Some light optimization will be required for the hardest test cases. Pips offers an excellent opportunity to sharpen both your Algorithm X techniques and your object-oriented analysis and design skills.</p> <p>Cells on the game board are grouped together by rules, similar to puzzles like High Rise Buildings, Killer Sudoku Solver, and Kakuro Solver, where groups of cells must collectively satisfy specific constraints. Pips has five different rule types, but each behaves similarly at an abstract level:</p> <ul> <li> <p>A rule may narrow the set of possible values for its member cells based on logical deductions.</p> </li> <li> <p>A rule must also be able to validate whether a given combination of values across its cells is allowed.</p> </li> </ul> <p>This structure is a natural fit for inheritance: shared abstract behavior in a base class, with custom implementations in subclasses for each rule type.</p> <p>If you\u2019ve been looking for a fun and approachable project to explore Algorithm X and object-oriented design, this is a perfect place to dive in!</p> <p></p>"},{"location":"22-2025-and-beyond/12-connect-the-colours-part-1/","title":"Connect the Colours - Part 1","text":"<p>Puzzle: Connect the Colours Part 1 - AWAITING APPROVAL</p> <p>Author: @Harry.B.</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: Textbook Algorithm X</p>"},{"location":"22-2025-and-beyond/12-connect-the-colours-part-1/#overview","title":"Overview","text":"<p>This puzzle, crafted by @Harry.B., is a stellar, visual exact-cover problem using the CodinGame SDK. It earns two thumbs up for its engaging design! To succeed, you\u2019ll need sharp grid-navigation skills to generate possible paths between pairs of same-colored endpoints. Once you\u2019ve mastered path generation, Algorithm X will efficiently find solutions for all test cases.</p> <p>Keep your code tight as things will get a lot tougher in Part 2!</p> <p></p>"},{"location":"22-2025-and-beyond/13-connect-the-colours-part-2/","title":"Connect the Colours - Part 2","text":"<p>Puzzle: Connect the Colours Part 2 - AWAITING APPROVAL</p> <p>Author: @Harry.B.</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: Textbook Algorithm X, Challenging Optimization</p>"},{"location":"22-2025-and-beyond/13-connect-the-colours-part-2/#overview","title":"Overview","text":"<p>This 2nd puzzle in @Harry.B.'s Connect the Colours series is a beast! As the test cases get tougher, the space between endpoints grows, allowing for many possible paths. Completing all test cases demands careful optimization due to the explosive growth of possible paths.</p> <p>On the next page, I'll share some ideas for optimizing your search for possible paths between endpoints. Before I do that, let\u2019s dive into what fuels the \"volcanic eruption\" of paths in this challenge.</p>"},{"location":"22-2025-and-beyond/13-connect-the-colours-part-2/#understanding-paths-in-a-2x2-grid","title":"Understanding Paths in a 2x2 Grid","text":"<p>Consider a simple 2x2 grid with one pair of endpoints, the bottom-left corner and the top-right corner. There are exactly two distinct paths connecting these points. These are known as nonintersecting (self-avoiding) rook paths, adhering to two key rules:</p> <ol> <li> <p>A path cannot intersect itself.</p> </li> <li> <p>Movement is restricted to horizontal and vertical steps, mimicking a rook\u2019s moves in chess (up, down, left, or right).</p> </li> </ol>"},{"location":"22-2025-and-beyond/13-connect-the-colours-part-2/#scaling-to-a-3x3-grid","title":"Scaling to a 3x3 Grid","text":"<p>Now, let\u2019s examine a 3x3 grid. To simplify, consider the possible paths after the first two moves from the bottom-left to the top-right corner. There are four possible combinations of initial moves as shown below.</p> <p></p> <p></p> <p></p> <p>After the initial two steps, each path branches into three additional options. This results in 12 possible paths for a 3x3 grid.</p> <p>This number may seem manageable, but the complexity escalates quickly with larger grids. Using a depth-first search in Python, I calculated the number of possible self-avoiding rook paths for larger grids:</p> <ul> <li> <p>4x4: 184 paths</p> </li> <li> <p>5x5: 8,512 paths</p> </li> <li> <p>6x6: 1,262,816 paths</p> </li> <li> <p>7x7: 575,780,564 paths</p> </li> </ul> <p>Computing the paths for a 7x7 grid took my laptop over an hour, revealing the sheer scale of this problem. My approach was na\u00efve, and the complexity of this challenge opened my eyes to the depth of research on self-avoiding paths. I eventually stumbled upon the Online Encyclopedia of Integer Sequences (OEIS), where I found data up to <code>n=27</code> and I also found...the fingerprints of, none other than, Donald Knuth.</p>"},{"location":"22-2025-and-beyond/13-connect-the-colours-part-2/#just-cant-get-enough","title":"Just Can't Get Enough","text":"<p>In 1981, pioneering English electronic band Depeche Mode released their debut album Speak &amp; Spell, featuring their first Top 10 hit, Just Can\u2019t Get Enough. The lyrics seem to tell the story of a romantic obsession \u2014 but a tongue-in-cheek theory holds that it\u2019s really about the band\u2019s deep, unshakable love for integer sequences.</p> <p></p> <p></p> <p></p> <p>Seventeen years earlier, in 1964 \u2014 long before synthesizers were filling dance floors \u2014 mathematician Neil J. A. Sloane began compiling collections of these integer sequences. His work eventually grew into two printed books (1973 and 1995) and later evolved into an email service and, in 1996, a public website. Today, the Online Encyclopedia of Integer Sequences (OEIS) is home to 386,574 sequences (as of August 2025) \u2014 more than enough to ensure that even a synth-pop mathematician just can\u2019t get enough.</p> <p>Topic A007764 on the OEIS has all the information you need if you'd like to search for the next number in the sequence of non-intersecting rook paths. The topic was originally authored by David Radcliffe and Donald Knuth. In the next table, I have included the number of rook paths for <code>n=1</code> to <code>n=14</code>.</p> n Number of Rook Paths 1 1 2 2 3 12 4 184 5 8,512 6 1,262,816 7 575,780,564 8 789,360,053,252 9 3,266,598,486,981,642 10 41,044,208,702,632,496,804 11 1,568,758,030,464,750,013,214,100 12 182,413,291,514,248,049,241,470,885,236 13 64,528,039,343,270,018,963,357,185,158,482,118 14 69,450,664,761,521,361,664,274,701,548,907,358,996,488 <p>Are you thinking to yourself, \"I just can't get enough?\" Click here to see the full list from <code>n=1</code> to <code>n=27</code>.</p>"},{"location":"22-2025-and-beyond/13-connect-the-colours-part-2/#now-thats-big","title":"Now That's Big","text":"<p>The number of rook paths for <code>n=27</code> contains 164 digits! The science news website, Live Science, estimates there are 10<sup>82</sup> atoms in the observable universe. To get to 10<sup>164</sup>, we have to give every one of those atoms its own full universe!</p> <p>This leaves me with two research questions on my to-do list:</p> <ol> <li> <p>How do I calculate something that big? \ud83e\udd2f</p> </li> <li> <p>How do I prove to my friends my calculation is accurate? \ud83d\ude0e</p> </li> </ol>"},{"location":"22-2025-and-beyond/13-connect-the-colours-part-2/#ht-depeche-mode","title":"h/t Depeche Mode","text":"<p>Depeche Mode - Just Can't Get Enough (TOTP 1981)</p> <p></p>"},{"location":"22-2025-and-beyond/14-connect-the-colours-part-2-%28cont.%29/","title":"Connect the Colours - Part 2 (cont.)","text":"<p>Coming soon...</p>"},{"location":"22-2025-and-beyond/14-connect-the-colours-part-2-notes/","title":"Connect the Colours - Part 2 (cont.)","text":"<p>On the previous page...</p>"},{"location":"22-2025-and-beyond/14-connect-the-colours-part-2-notes/#strategy","title":"Strategy","text":"<p>Alright, Tim \u2014 let\u2019s unpack this carefully, because there\u2019s a subtle but important difference between those two approaches.</p> <p>We\u2019ll compare them along how Python computes the hash, memory use, speed, and collision likelihood.</p>"},{"location":"22-2025-and-beyond/14-connect-the-colours-part-2-notes/#1-whats-being-hashed","title":"1. What\u2019s Being Hashed","text":""},{"location":"22-2025-and-beyond/14-connect-the-colours-part-2-notes/#case-a-hashing-a-list-of-x-y-tuples","title":"Case A: Hashing a list of <code>(x, y)</code> tuples","text":"<pre><code>hash(tuple(list_of_xy))\n</code></pre> <ul> <li>You\u2019re hashing all coordinates explicitly.</li> <li>The hash is computed from each tuple\u2019s hash, in order.</li> <li>The <code>hash()</code> function for a tuple works roughly like:</li> </ul> <p><pre><code>h = seed\nfor item in tuple:\n    h = h * constant ^ hash(item)\nh = finalize(h)\n</code></pre> * Each <code>(x, y)</code> is itself a tuple, so its hash also combines <code>hash(x)</code> and <code>hash(y)</code>.</p>"},{"location":"22-2025-and-beyond/14-connect-the-colours-part-2-notes/#case-b-hashing-bitboard_int-last_xy_tuple","title":"Case B: Hashing <code>(bitboard_int, last_xy_tuple)</code>","text":"<pre><code>hash((bitboard_int, last_xy))\n</code></pre> <ul> <li>The first element is a single integer representing all the other <code>(x, y)</code>s (except the last).</li> <li>The second element is the last coordinate tuple.</li> <li>Now Python\u2019s tuple hash only does two element-level hashes \u2014 much less work.</li> <li>The integer\u2019s hash is just itself in Python (modulo some tweaks for <code>-1</code>).</li> </ul>"},{"location":"22-2025-and-beyond/14-connect-the-colours-part-2-notes/#2-performance","title":"2. Performance","text":"<ul> <li> <p>Case A:</p> </li> <li> <p>Time complexity: <code>O(n)</code> where <code>n</code> is number of tuples in the list.</p> </li> <li>More Python-level work: multiple nested hash calls.</li> <li> <p>Case B:</p> </li> <li> <p>Time complexity: <code>O(1)</code> \u2014 just hashing one int + one tuple.</p> </li> <li>Most of the heavy lifting is the single integer hash, which is very fast.</li> </ul> <p>So if <code>n</code> is large, Case B is much faster.</p>"},{"location":"22-2025-and-beyond/14-connect-the-colours-part-2-notes/#3-memory-footprint","title":"3. Memory footprint","text":"<ul> <li>Case A: You keep the whole list of tuples in memory (unless you generate it on the fly).   Overhead: Python object headers for each tuple + list overhead.</li> <li> <p>Case B: You store:</p> </li> <li> <p>One integer (bitboard)</p> </li> <li>One tuple for the last <code>(x, y)</code>     That\u2019s way less memory \u2014 especially if <code>n</code> is big.</li> </ul>"},{"location":"22-2025-and-beyond/14-connect-the-colours-part-2-notes/#4-collision-risk","title":"4. Collision risk","text":"<ul> <li> <p>Case A:</p> </li> <li> <p>Every <code>(x, y)</code> is part of the hash, so two different lists are very unlikely to collide unless Python\u2019s hash space is overwhelmed (practically negligible).</p> </li> <li> <p>Case B:</p> </li> <li> <p>Depends on how you encode the bitboard.</p> </li> <li>If your integer encoding is unique for every possible combination of <code>(x, y)</code> except the last, collisions are only as likely as in Case A.</li> <li>But if your bitboard is compressed in a way that can produce the same integer for two different configurations, you\u2019ll introduce extra collision risk.</li> </ul>"},{"location":"22-2025-and-beyond/14-connect-the-colours-part-2-notes/#5-practical-trade-offs","title":"5. Practical trade-offs","text":"Aspect List of <code>(x, y)</code> tuples <code>(bitboard_int, last_tuple)</code> Hash speed Slower (<code>O(n)</code>) Faster (<code>O(1)</code>) Memory use Higher Lower Collision risk Very low Depends on encoding Ease of debug Easier to inspect Bitboard may be opaque Order sensitivity Preserved naturally Preserved if encoding does <p>Bottom line: If performance and memory are critical (and your bitboard encoding is collision-free for your domain), hashing <code>(bitboard_int, last_xy)</code> is leaner and faster. If you want maximum clarity and minimum risk of encoding errors, hashing the full tuple list is safer \u2014 but slower.</p> <p>If you want, I can time both approaches in Python for, say, 1000 <code>(x, y)</code> coordinates to see how much faster the bitboard approach is. Would you like me to do that next?</p> <p>I ran the benchmark for 15 <code>(x, y)</code> coordinates, hashing each case 50,000 times:</p> <ul> <li>Full list of tuples: \\~0.0518 seconds</li> <li>(bitboard_int, last_xy): \\~0.0122 seconds</li> <li>Speedup: \\~4.24\u00d7 faster</li> </ul> <p>So for tens of thousands of hash checks per run, the bitboard + head approach should cut hashing time down to about a quarter of what it would be otherwise \u2014 and save memory at the same time.</p> <p>Since you don\u2019t care about the snake\u2019s shape, only its occupied cells and the head position, the bitboard + head combo is exactly the kind of compact, low-collision representation that Python\u2019s hash can handle efficiently.</p>"},{"location":"22-2025-and-beyond/15-battleship-solitaire/","title":"Battleship Solitaire","text":"<p>Puzzle: Battleship Solitaire - AWAITING APPROVAL</p> <p>Author: @VizGhar</p> <p>Published Difficulty: Hard</p> <p>Algorithm X Complexity: A Bit of Everything</p> <p></p>"},{"location":"22-2025-and-beyond/15-battleship-solitaire/#strategy","title":"Strategy","text":"<p>Having completed a good number of exact cover problems, I didn\u2019t expect this puzzle to throw me for such a loop. Coming up with an abstract model to fit the tiles-on-a-gameboard analogy turned out to be more difficult than expected.</p> <p>Actions: What are the tiles being placed? The full ships? The individual ship parts? Should water cells be represented at all, or are they implied by ship placement? Modeling each possible ship placement as a single action tends to work best, but it quickly raises new constraints around overlap and adjacency.</p> <p>Mutual Exclusivity: How can I ensure two ships do not touch, not even diagonally? In this puzzle, \u201cno touching\u201d extends beyond simple cell overlap \u2014 the exclusion zones around ships must also be considered. How can I determine if two potential ship placements are mutually exclusive?</p> <p>Multiplicity and Steering: How can I ensure the proper number of ship cells appear in each row and column, and that the correct number of ships of each size are used? Representing the ship inventory and row/column quotas as separate constraint sets provides good control here, though it takes careful thought to keep the model both complete and minimal.</p> <p>The test case progression for this puzzle is extremely well done, letting you build your Algorithm X requirements and actions step by step. With a solid DLX setup, you\u2019ll solve many test cases cleanly, and a small bit of logic based on the initial gameboard hints will take you close to the finish line.</p> <p>Solving these Battleship Solitaire grids without backtracking is a wonderful experience in itself. To explore strategies for introducing more hints or logical deductions before searching with Algorithm X, consider playing a few games by hand.</p>"},{"location":"22-2025-and-beyond/15-battleship-solitaire/#solving-logic-puzzle-logically","title":"Solving Logic Puzzle Logically \ud83d\udcaf","text":"<p>All Battleship Solitaire test cases and validators can be solved without making any guesses. It\u2019s not an easy row to hoe, but if you enjoy a pure logic challenge, this one delivers. Click here to see my ongoing progress toward solving as many logic puzzles as possible \u2014 strictly with reasoning, no guessing, and no backtracking.</p> <p></p>"},{"location":"22-2025-and-beyond/16-magnets/","title":"Magnets","text":"<p>Puzzle: Magnets - AWAITING APPROVAL</p> <p>Author: @VizGhar</p> <p>Published Difficulty: Medium</p> <p>Algorithm X Complexity: </p> <p></p>"},{"location":"22-2025-and-beyond/16-magnets/#strategy","title":"Strategy","text":"<p>@VizGhar\u2019s Magnets puzzle is a polarizing test of logic, where every decision attracts or repels another. You must fill the grid with polarized magnets and neutral wooden blocks. To keep the grid stable, no two orthogonal cells can share the same polarity \u2014 no two <code>+</code> cells or two <code>\u2013</code> cells may touch. Each row and column must also satisfy its given counts of positive and negative poles.</p> <p>A basic Algorithm X setup will get you most of the way there, but the toughest test cases require a bit of extra optimization \u2014 something you can approach in several ways. As you might expect by now, I chose a round of logical problem-space reduction that trimmed the hardest grids down to smaller, solvable cores that Algorithm X could finish effortlessly.</p> <p>This puzzle is based on Magnets from Simon Tatham\u2019s Portable Puzzle Collection. Logical deduction feels a bit more elusive here than in many other puzzles, but playing a few rounds by hand is a great way to uncover useful strategies and develop a stronger intuition for the puzzle\u2019s magnetic dynamics.</p>"},{"location":"22-2025-and-beyond/16-magnets/#solving-logic-puzzles-logically","title":"Solving Logic Puzzles Logically \ud83d\udcaf","text":"<p>All Magnets test cases and validators can be solved purely by logic, without a single guess. Click here to see my ongoing progress toward solving as many logic puzzles as possible\u2014strictly with logic, no guessing, no backtracking.</p> <p></p>"},{"location":"23-solver-translations/01-overview/","title":"Solver Translations","text":"<p>On the following pages are various language translations of the provided <code>AlgorithmXSolver</code>. I am not the author of any of these translations. CodinGamers with significantly more language expertise than me have taken on the task of writing these translations and sharing their code. I owe each of them a debt of gratitude.</p>"},{"location":"23-solver-translations/01-overview/#quality-guarantee","title":"Quality Guarantee","text":"<p>For each translation, either the author or I have completed several puzzles using the translation and feel confident in the functionality. I spent two years working with and refining my Python solver. Obviously, we can\u2019t do that with each translation. However, I will make this pseudo guarantee:</p> <p>If you run into issues with any of these translations, post a note in the CodinGame Forum's Algorithm X / DLX Thread and I feel confident the CodinGame community will do their best to get you the help you need.</p>"},{"location":"23-solver-translations/01-overview/#translation-inventory","title":"Translation Inventory","text":"<p>Click the links below for each translation. If you do not see your preferred language, please consider writing a translation and allowing me to share it here with the community.</p> <p>Ruby</p> <p>Kotlin</p> <p>PHP</p> <p></p>"},{"location":"23-solver-translations/02-ruby/","title":"Ruby","text":"<p>Translation Author: @Rafarafa</p> <p>Ruby is a high-level, dynamically typed programming language known for its readability and ease of use. Ruby shares many similarities with Python, such as automatic memory management and object-oriented principles.</p> <p>@Rafarafa has provided a word for word translation, even preserving the comments found in the provided Python code. Using the Ruby solver below is extremely similar to the Python examples found in the playground.</p>"},{"location":"23-solver-translations/02-ruby/#key-difference","title":"Key Difference","text":"<p>My Python <code>AlgorithmXSolver</code> makes extensive use of <code>tuple</code>s. Because Ruby does not have <code>tuple</code>s, you will use <code>array</code>s for requirements and actions. These <code>array</code>s will be used as keys in a <code>hash</code>, so take appropriate care to ensure the <code>array</code> elements never change.</p> <p>Be sure to scan through @Rafarafa's other comments for information regarding other minor differences.</p>"},{"location":"23-solver-translations/02-ruby/#example-9x9-sudoku","title":"Example - 9x9 Sudoku","text":"<pre><code>class SudokuSolver &lt; AlgorithmXSolver\n\n  def initialize(grid, values)\n\n    # Build requirements and actions.\n\n    super(requirements, actions)\n  end\nend\n\nn = 9\ngrid = n.times.map { gets.chomp.split(\"\") }\nsolver = SudokuSolver.new(grid, [*\"1\"..n.to_s].take(n).join)\nsolution = solver.solve.take(1).first\n\nsolution.each do | _, row, col, val|\n  grid[row][col] = val\nend\n</code></pre>"},{"location":"23-solver-translations/02-ruby/#the-solver-code","title":"The Solver Code","text":"<pre><code># Last edit: 2025-01-15 by @Rafarafa\n#\n# Port to ruby of @Timinator's python implementation:\n# https://www.codingame.com/playgrounds/156252/algorithm-x/the-algorithmxsolver\n#\n# The comments have been preserved verbatim, except for the necessary\n# changes to match ruby's conventions (__init__ &gt; initialize etc.)\n\n################################################\n################################################\n\nrequire 'set'\n\n#  This solution uses Knuth's Algorithm X and his Dancing Links (DLX):\n#  (DLX-Based Algorithm X Solver Last Revised 01 December 2024)\n#\n#  For a detailed explanation and tutorial, please see the Algorithm X\n#  playground on Tech.io by following the link in @Timinator's CodinGame profile:\n#\n#  https://www.codingame.com/profile/2df7157da821f39bbf6b36efae1568142907334/playgrounds\n#\n\n#  DLXCell is one cell in the Algorithm X matrix. This implementation was mostly\n#  copied from @RoboStac's solution to Constrained Latin Squares on www.codingame.com.\n#\n#  https://www.codingame.com/training/medium/constrained-latin-squares\n#\nclass DLXCell\n  attr_accessor :prev_x, :next_x, :prev_y, :next_y, :col_header, :row_header, :title, :size\n\n  def initialize(title = nil)\n    @prev_x = self\n    @next_x = self\n    @prev_y = self\n    @next_y = self\n\n    @col_header = nil\n    @row_header = nil\n\n    # Only used for column and row headers\n    @title = title\n\n    # Size quickly identifies how many rows are in any particular column\n    @size = 0\n  end\n\n  def remove_x\n    @prev_x.next_x = @next_x\n    @next_x.prev_x = @prev_x\n  end\n\n  def remove_y\n    @prev_y.next_y = @next_y\n    @next_y.prev_y = @prev_y\n  end\n\n  def restore_x\n    @prev_x.next_x = self\n    @next_x.prev_x = self\n  end\n\n  def restore_y\n    @prev_y.next_y = self\n    @next_y.prev_y = self\n  end\n\n  def attach_horiz(other)\n    n = @prev_x\n    other.prev_x = n\n    n.next_x = other\n    @prev_x = other\n    other.next_x = self\n  end\n\n  def attach_vert(other)\n    n = @prev_y\n    other.prev_y = n\n    n.next_y = other\n    @prev_y = other\n    other.next_y = self\n  end\n\n  def remove_column\n    remove_x\n    node = @next_y\n    while node != self\n      node.remove_row\n      node = node.next_y\n    end\n  end\n\n  def restore_column\n    node = @prev_y\n    while node != self\n      node.restore_row\n      node = node.prev_y\n    end\n    restore_x\n  end\n\n  def remove_row\n    node = @next_x\n    while node != self\n      node.col_header.size -= 1\n      node.remove_y\n      node = node.next_x\n    end\n  end\n\n  def restore_row\n    node = @prev_x\n    while node != self\n      node.col_header.size += 1\n      node.restore_y\n      node = node.prev_x\n    end\n  end\n\n  def select\n    node = self\n    loop do\n      node.remove_y\n      node.col_header.remove_column\n      node = node.next_x\n      break if node == self\n    end\n  end\n\n  def unselect\n    node = @prev_x\n    while node != self\n      node.col_header.restore_column\n      node.restore_y\n      node = node.prev_x\n    end\n    node.col_header.restore_column\n    node.restore_y\n  end\nend\n\nclass AlgorithmXSolver\n  attr_accessor :solution, :solution_count, :history, :solution_is_valid\n\n  # R - an array of requirements. The initialize() method converts R to a hash, but R must\n  #     originally be passed in as a simple array of requirements. Each requirement is an array\n  #     of values that uniquely identify that requirement from all other requirements.\n  #\n  # A - must be passed in as a hash - keys are actions, values are arrays of covered requirements\n  #\n  # O - array of optional requirements. They can be covered, but they never cause failure.\n  #     Optional requirements are important because if they get covered, no other action can\n  #     also cover that same requirement. Also referred to as \"at-most-one-time constraints\".\n  #\n  def initialize(requirements, actions, optional = [])\n    @A = actions\n    @R = requirements + optional\n    @O = optional.to_set\n\n    # The array of actions (rows) that produce the current path through the matrix.\n    @solution = []\n    @solution_count = 0\n\n    # A history can be added to a subclass to allow Algorithm X to handle \"multiplicity\".\n    # In the basic Solver, nothing is ever put into the history. A subclass can override\n    # the _process_row_selection() method to add history in cases of multiplicity.\n    @history = [Set.new]\n\n    # For the basic Algorithm X Solver, all solutions are always valid. However, a subclass\n    # can add functionality to check solutions as they are being built to steer away from\n    # invalid solutions. The basic Algorithm X Solver never modifies this attribute.\n    @solution_is_valid = true\n\n    # Create a column in the matrix for every requirement.\n    @matrix_root = DLXCell.new\n    @matrix_root.size = 10_000_000\n    @matrix_root.title = 'root'\n\n    @col_headers = @R.map { |requirement| DLXCell.new(requirement) }\n\n    # Row headers are never attached to the rest of the DLX matrix. They are only used\n    # currently to keep track of the action associated with each row.\n    @row_headers = Hash[@A.keys.map { |action| [action, DLXCell.new(action)] }]\n\n    @R = Hash[@R.zip(@col_headers)]\n\n    @col_headers.each { |col_header| @matrix_root.attach_horiz(col_header) }\n\n    # Create a row in the matrix for every action.\n    @A.each do |action, covered_requirements|\n      previous_cell = nil\n\n      covered_requirements.each do |requirement|\n        next_cell = DLXCell.new\n        next_cell.col_header = @R[requirement]\n        next_cell.row_header = @row_headers[action]\n        next_cell.col_header.attach_vert(next_cell)\n        next_cell.col_header.size += 1\n\n        if previous_cell\n          previous_cell.attach_horiz(next_cell)\n        else\n          previous_cell = next_cell\n        end\n      end\n    end\n  end\n\n  def solve\n    # Proxy to emulate Python yield semantics.\n    #\n    # If only a set amount of solutions is required, this should be called\n    # together with the `take` method. Note that if we `take` n elements, it \n    # forces an early exit as soon as we reach those n elements, resulting\n    # in a performance increase.\n    #\n    # That is, if you only want the first solution do:\n    # &gt;&gt;&gt; solution = solver.solve.take(1).first\n    # \n    # Instead of:\n    # &gt;&gt;&gt; solution = solver.solve.next\n    #\n    # Since this last one will still explore after finding the first solution.\n    # Note that this can cause \"stack level too deep (SystemStackError)\" on\n    # very demanding puzzles such as 25x25 Sudoku.\n    Enumerator.new { |yielder| solve_go(yielder) }\n  end\n\n  def solve_go(yielder)\n    # Algorithm X Step 1:\n    #\n    # Choose the column (requirement) with the best value for \"sort criteria\". For\n    # the basic implementation of sort criteria, Algorithm X always chooses the column\n    # covered by the fewest number of actions. Optional requirements are not eligible\n    # for this step.\n    best_column = @matrix_root\n    best_value = 'root'\n\n    node = @matrix_root.next_x\n    while node != @matrix_root\n      # Optional requirements (at-most-one-time constraints) are never chosen as best.\n      if !@O.include?(node.title)\n        # Get the sort criteria for this requirement (column).\n        value = _requirement_sort_criteria(node)\n        if best_column == @matrix_root || value &lt; best_value\n          best_column = node\n          best_value = value\n        end\n        node = node.next_x\n      else\n        # Optional requirements stop the search for the best column.\n        node = @matrix_root\n      end\n    end\n\n    if best_column == @matrix_root\n      _process_solution\n      if @solution_is_valid\n        @solution_count += 1\n        yielder &lt;&lt; @solution.dup\n      end\n      return\n    end\n\n    # Build an array of all actions (rows) that cover the chosen requirement (column).\n    actions = []\n    node = best_column.next_y\n    while node != best_column\n      actions &lt;&lt; node\n      node = node.next_y\n    end\n\n    # The next step is to loop through all possible actions. To prepare for this,\n    # a new level of history is created. The history for this new level starts out\n    # as a complete copy of the most recent history.\n    @history.push(@history.last.dup)\n\n    # Loop through the possible actions sorted by the given sort criteria. A basic\n    # Algorithm X implementation does not provide sort criteria. Actions are tried\n    # in the order they happen to occur in the matrix.\n    actions.sort_by { |n| _action_sort_criteria(n.row_header) }.each do |node|\n      select(node: node)\n      solve_go(yielder) if @solution_is_valid\n      deselect(node: node)\n\n      # All backtracking results in going back to a solution that is valid.\n      @solution_is_valid = true\n    end\n\n    @history.pop\n  end\n\n  # Algorithm X Step 4 - Details:\n  #\n  # The select method updates the matrix when a row is selected as part of a solution.\n  # Other rows that satisfy overlapping requirements need to be deleted and in the end,\n  # all columns satisfied by the selected row get removed from the matrix.\n  def select(node:)\n    node.select\n    @solution &lt;&lt; node.row_header.title\n    _process_row_selection(node.row_header.title)\n  end\n\n  # Algorithm X Step 4 - Clean Up:\n  #\n  # The select() method selects a row as part of the solution being explored. Eventually that\n  # exploration ends and it is time to move on to the next row (action). Before moving on,\n  # the matrix and the partial solution need to be restored to their prior states.\n  def deselect(node:)\n    node.unselect\n    @solution.pop\n    _process_row_deselection(node.row_header.title)\n  end\n\n  # In cases of multiplicity, this method can be used to ask Algorithm X to remember that\n  # it has already tried certain things. For instance, if Emma wants two music lessons per\n  # week, trying to put her first lesson on Monday at 8am is no different than trying to put\n  # her second lesson on Monday at 8am. See the Algorithm X Playground for more details,\n  # specifically Mrs. Knuth - Part III.\n  def _remember(item_to_remember)\n    if @history.last.include?(item_to_remember)\n      @solution_is_valid = false\n    else\n      @history.last.add(item_to_remember)\n    end\n  end\n\n  # In some cases it may be beneficial to have Algorithm X try certain paths through the matrix.\n  # This can be the case when there is reason to believe certain actions have a better chance than\n  # other actions at producing complete paths through the matrix. The method included here does\n  # nothing, but can be overridden to influence the order in which Algorithm X tries rows (actions)\n  # that cover some particular column.\n  def _action_sort_criteria(_row_header)\n    0\n  end\n\n  # In some cases it may be beneficial to have Algorithm X try covering certain requirements\n  # before others as it looks for paths through the matrix. The default is to sort the requirements\n  # by how many actions cover each requirement, but in some cases there might be several\n  # requirements covered by the same number of actions. By overriding this method, the\n  # Algorithm X Solver can be directed to break ties a certain way or consider another way\n  # of prioritizing the requirements.\n  def _requirement_sort_criteria(col_header)\n    col_header.size\n  end\n\n  # The following method can be overridden by a subclass to add logic to perform more detailed solution\n  # checking if invalid paths are possible through the matrix. Some problems have requirements that\n  # cannot be captured in the basic requirements array passed into the initialize() method. For instance,\n  # a solution might only be valid if it fits certain parameters that can only be checked at intermediate\n  # steps. In a case like that, this method can be overridden to add the functionality necessary to\n  # check the solution.\n  #\n  # If the subclass logic results in an invalid solution, the 'solution_is_valid' attribute should be set\n  # to False instructing Algorithm X to stop progressing down this path in the matrix.\n  def _process_row_selection(row); end\n\n  # This method can be overridden by a subclass to add logic to perform more detailed solution\n  # checking if invalid paths are possible through the matrix. This method goes hand-in-hand with the\n  # _process_row_selection() method above to \"undo\" what was done above.\n  def _process_row_deselection(row); end\n\n  # This method can be overridden to instruct Algorithm X to do something every time a solution is found.\n  # For instance, Algorithm X might be looking for the best solution or maybe each solution must be\n  # validated in some way. In either case, the solution_is_valid attribute can be set to False\n  # if the current solution should not be considered valid and should not be generated.\n  def _process_solution; end\nend\n</code></pre>"},{"location":"23-solver-translations/03-kotlin/","title":"Kotlin","text":"<p>Translation Author: @VizGhar</p> <p>Kotlin is a modern, statically typed programming language designed for conciseness, safety, and interoperability with Java. Kotlin has become the preferred language for Android app development.</p> <p>@VizGhar provides a tutorial and examples on his GitHub page, but I want to cover 2 things here that differ from my Python <code>AlgorithmXSolver</code>. The first is a simple switch from <code>tuple</code>s to <code>data class</code>es, an idea I wish I had thought of 2 years ago. The second is a difference in code structure due to a minor difference between Python and Kotlin.</p>"},{"location":"23-solver-translations/03-kotlin/#requirements-and-actions","title":"Requirements and Actions","text":"<p>Instead of <code>tuple</code>s for requirements and actions, @VizGhar uses <code>data class</code>es, a similar, but more powerful container for data elements. Consider the 4 types of requirements for Sudoku. Each cell must be covered with a number, each number must appear in each row, each number must appear in each column and each number must appear in each box. @VizGhar creates 4 separate data classes, each of which inherits from a generic <code>Requirement</code>.</p> <p>In my Python, each of my <code>tuple</code>s begins with a string that identifies one of the 4 requirement types. In @VizGhar\u2019s Kotlin, the class identifies one of the 4 requirement types and the strings become unnecessary.</p> <p>Before building your solver subclass, you need to define classes for your requirements and actions. In the following code snippet, I have defined the 4 types of requirements and the 1 action type found in Sudoku.</p> <pre><code>sealed interface Requirement {\n    data class CellCovered(val row: Int, val col: Int) : Requirement\n    data class BoxCovered(val box: Int, val value: Char) : Requirement\n    data class RowCovered(val row: Int, val value: Char) : Requirement\n    data class ColumnCovered(val col: Int, val value: Char) : Requirement\n}\n\ndata class Action(val row: Int, val col: Int, val value: Char)\n</code></pre>"},{"location":"23-solver-translations/03-kotlin/#solver-construction-and-initialization","title":"Solver Construction and Initialization","text":"<p>Using my Python solver, the following process has been suggested as standard practice:</p> <ol> <li>Create a subclass that inherits from <code>AlgorithmXSolver</code>.</li> <li>Override the constructor to build requirements and actions.</li> <li>Prior to exiting the subclass constructor, call the superclass constructor passing the newly built requirements and actions.</li> </ol> <p>In Kotlin, your solver subclass cannot override the inherited constructor to build requirements and actions before passing them to the inherited constructor. Requirements and actions must be built before initializing your subclass solver. In the following 9x9 Sudoku example, I have added a function called <code>createSolver</code> (per @VizGhar's instructions), which builds the requirements and actions before creating an instance of <code>SudokuSolver</code>.</p>"},{"location":"23-solver-translations/03-kotlin/#example-9x9-sudoku","title":"Example - 9x9 Sudoku","text":"<pre><code>class SudokuSolver(requirements: List&lt;Requirement&gt;, actions: Map&lt;Action, List&lt;Requirement&gt;&gt;) : \n            DLXSolver&lt;Requirement, Action&gt;(requirements, actions) {\n\n    override fun processSolution(solution: List&lt;Action&gt;): Boolean {\n\n        // Using the Actions in the solution, build a grid and print the solved Sudoku.\n\n        return true    // Return true to stop looking for more solutions.\n    }\n}\n\n\nfun createSolver(grid: List&lt;CharArray&gt;, values: String): SudokuSolver {\n\n    val requirements = mutableListOf&lt;Requirement&gt;()\n\n    // Build the requirements.\n\n    val actions = mutableMapOf&lt;Action, List&lt;Requirement&gt;&gt;()\n\n    // Build the actions.\n\n    return SudokuSolver(requirements, actions)\n}\n\n\nfun main() {\n    createSolver(List(9) { readln().toCharArray() }, \"123456789\").solve()\n}\n</code></pre>"},{"location":"23-solver-translations/03-kotlin/#the-solver-code","title":"The Solver Code","text":"<p>For even more details, code examples and most importantly, the Kotlin <code>DLXSolver</code> code, please visit @VizGhar's GitHub repository.</p> <p></p>"},{"location":"23-solver-translations/04-php/","title":"PHP","text":"<p>Translation Author: @TBali</p> <p>PHP is a high-level, interpreted language primarily used for web development. Its deep integration with HTML makes it a popular choice for server-side scripting. While PHP supports many modern programming constructs, it lacks native support for <code>tuple</code>s \u2014 structures that are frequently used in my Python-based <code>AlgorithmXSolver</code>, particularly as dictionary keys.</p> <p>To address this, @TBali defines classes for both requirements and actions. Each instance of these classes includes a unique string stored in a <code>hash</code> attribute. In the PHP implementation of <code>AlgorithmXSolver</code>, these unique strings are used in place of Python's <code>tuple</code>s. This approach results in a smooth and intuitive user experience that closely mirrors the original Python logic.</p>"},{"location":"23-solver-translations/04-php/#abstract-requirements-and-actions","title":"Abstract Requirements and Actions","text":"<p>The next code snippet shows the abstract classes for requirements and actions provided with the PHP <code>AlgorithmXSolver</code>. Each problem-specific implementation must define subclasses that extend these two classes.</p> <pre><code>&lt;?php\n// --------------------------------------------------------------------\n/**\n * A single requirement to be used in the solver.\n *\n * Actual puzzle requirement class shall extend this and set its `hash` property in its constructor.\n */\nabstract class Requirement\n{\n    /**\n     * @var string\n     */\n    protected $hash;\n\n    public function hash(): string\n    {\n        return $this-&gt;hash;\n    }\n}\n\n\n// --------------------------------------------------------------------\n/**\n * A single action to be used in the solver.\n *\n * Actual puzzle requirement class shall extend this and set its `hash` property in its constructor.\n * Before passing list of actions to the solver, the `reqs` property must be filled with list of requirements.\n */\nabstract class Action\n{\n    /** @var string */\n    protected $hash;\n\n    /**\n     * The list of requirements that this action covers.\n     *\n     * @var array&lt;int, Requirement&gt;\n     */\n    public $reqs = [];\n\n    public function hash(): string\n    {\n        return $this-&gt;hash;\n    }\n}\n?&gt;\n</code></pre>"},{"location":"23-solver-translations/04-php/#problem-specific-requirements-and-actions","title":"Problem-Specific Requirements and Actions","text":"<p>To use @TBali\u2019s PHP solver, you must first create subclasses for your problem-specific requirements and actions.  These subclasses must assign a string value to the inherited <code>hash</code> attribute. Consider 9x9 Sudoku, where there are four types of requirements:</p> <ol> <li>Every cell must contain exactly one value.</li> <li>Each value must appear exactly once in every row.</li> <li>Each value must appear exactly once in every column.</li> <li>Each value must appear exactly once in every 3\u00d73 box.</li> </ol> <p>To represent these constraints, I define four separate subclasses \u2014 each corresponding to one of the above requirements \u2014 all inheriting from the generic <code>Requirement</code> base class.</p> <p>Each subclass assigns a string to the inherited <code>hash</code> attribute. The string format is intentionally designed to resemble the tuple representations used in my Python-based implementation, preserving clarity and structure.</p> <pre><code>&lt;?php\nclass CellCovered extends Requirement\n{\n    /** @var int */\n    public $row;\n    /** @var int */\n    public $col;\n\n    public function __construct(int $row, int $col)\n    {\n        $this-&gt;row = $row;\n        $this-&gt;col = $col;\n        $this-&gt;hash = \"cell covered $row $col\";\n    }\n}\n\n\nclass ValueInRow extends Requirement\n{\n    /** @var int */\n    public $row;\n    /** @var string */\n    public $val;\n\n    public function __construct(int $row, string $val)\n    {\n        $this-&gt;row = $row;\n        $this-&gt;val = $val;\n        $this-&gt;hash =\"value in row $row $val\";\n    }\n}\n\n\nclass ValueInCol extends Requirement\n{\n    /** @var int */\n    public $col;\n    /** @var string */\n    public $val;\n\n    public function __construct(int $col, string $val)\n    {\n        $this-&gt;col = $col;\n        $this-&gt;val = $val;\n        $this-&gt;hash = \"value in col $col $val\";\n    }\n}\n\nclass ValueInBox extends Requirement\n{\n    /** @var int */\n    public $box;\n    /** @var string */\n    public $val;\n\n    public function __construct(int $box, string $val)\n    {\n        $this-&gt;box = $box;\n        $this-&gt;val = $val;\n        $this-&gt;hash = \"value in box $box $val\";\n    }\n}\n?&gt;\n</code></pre> <p>Next, a problem-specific subclass must be declared that extends the abstract <code>Action</code> class.</p> <pre><code>&lt;?php\nclass PlaceValue extends Action\n{\n    /** @var int */\n    public $row;\n    /** @var int */\n    public $col;\n    /** @var string */\n    public $val;\n\n    public function __construct(int $row, int $col, string $val)\n    {\n        $this-&gt;row = $row;\n        $this-&gt;col = $col;\n        $this-&gt;val = $val;\n        $this-&gt;hash = \"place value $row $col $val\";\n    }\n}\n?&gt;\n</code></pre>"},{"location":"23-solver-translations/04-php/#example-9x9-sudoku","title":"Example - 9x9 Sudoku","text":"<pre><code>&lt;?php\nclass SudokuSolver extends AlgorithmXSolver {\n\n    public function __construct(array $grid, string $values) {\n\n        $requirements = [];\n        $actions = [];\n\n        # Build the requirements and actions. Remember that the `req` attribute inherited\n        # from the abstract class Action is a list that must contain all the requirements\n        # covered by the action.\n\n        parent::__construct($requirements, $actions);\n   }\n}\n\n\n$solver = new SudokuSolver($sudoku, '123456789');\n\nforeach ($solver-&gt;solve() as $solution) {\n    foreach ($solution as $action) {\n\n        # Use the attributes of the $action to build the solution:\n        #      $action-&gt;row\n        #      $action-&gt;col\n        #      $action-&gt;val\n\n    }\n    break;\n}\n\n# print the solution\n?&gt;\n</code></pre>"},{"location":"23-solver-translations/04-php/#mutual-exclusivity","title":"Mutual Exclusivity","text":"<p>My Python-based implementation uses <code>tuple</code>s to create requirements for mutual exclusivity. The PHP <code>AlgorithmXSolver</code> code comes with an <code>MERequirement</code> class that takes 2 strings in its constructor, each string uniquely identifying one of the mutually exclusive items. The following code implements the <code>me_requirement</code>s for loud instruments as seen in Mrs. Knuth Part II:</p> <pre><code>&lt;?php\n    $me_requirements = [New MERequirement(\"loud instrument F 8\", \"loud instrument F 9\"), \n                        New MERequirement(\"loud instrument F 9\", \"loud instrument F 10\"),\n                        New MERequirement(\"loud instrument F 10\", \"loud instrument F 11\")];\n?&gt;\n</code></pre> <p>Of course, you will be using loops in your solution and your ultimate code will look more similar to:</p> <pre><code>&lt;?php\n    $me_requirements[] = New MERequirement(\"loud instrument $day $hour_1\", \"loud instrument $day $hour_2\"); \n?&gt;\n</code></pre> <p>The <code>MERequirement</code> class includes a <code>contains(string $me_item)</code> method to make searching for covered requirements easy when identifying requirements covered by an action:</p> <pre><code>&lt;?php\n    if (in_array($student-&gt;instrument, LOUD_INSTRUMENTS)) {\n        $me_item = \"loud instrument $day $hour\";\n        foreach ($me_requirements as $me) {\n            if ($me-&gt;contains($me_item)) {\n                $action-&gt;reqs[] = $me;\n            }\n        }\n    }\n?&gt;\n</code></pre>"},{"location":"23-solver-translations/04-php/#multiplicity","title":"Multiplicity","text":"<p>The Python <code>AlgorithmXSolver</code> uses memory to avoid redundant searches by adding <code>tuple</code>s of data to the solver's memory. In the PHP solver, the same functionality exists, but a <code>string</code> of data must be passed to the <code>remember()</code> method instead of a <code>tuple</code>. Implementing the Mrs. Knuth Part III example discussed in the Python section looks like this:</p> <pre><code>&lt;?php\n    protected function process_row_selection(Action $row): void\n    {\n        $this-&gt;remember(\"$row-&gt;name $row-&gt;day $row-&gt;hour\");\n    }\n?&gt;\n</code></pre>"},{"location":"23-solver-translations/04-php/#the-solver-code","title":"The Solver Code","text":"<pre><code>&lt;?php\n// --------------------------------------------------------------------\n/**\n * Last edit: 2025-05-15 by @TBali\n *\n * Port to PHP of @Timinator's python implementation:\n * @see https://www.codingame.com/playgrounds/156252/algorithm-x/the-algorithmxsolver\n *\n * @see https://en.wikipedia.org/wiki/Dancing_Links\n */\n\n// --------------------------------------------------------------------\n/**\n * A single cell in the matrix for a DLX-based Algorithm X solver.\n * Based on a Python code made by @Timinator, which was in turn based on a code by @RoboStac.\n */\nclass DLXCell\n{\n    /** @var DLXCell */\n    public $prev_x;\n    /** @var DLXCell */\n    public $next_x;\n    /** @var DLXCell */\n    public $prev_y;\n    /** @var DLXCell */\n    public $next_y;\n    /** @var DLXCell */\n    public $col_header;\n    /** @var DLXCell */\n    public $row_header;\n\n    /**\n     * Only used for column and row headers.\n     *\n     * @var null|Action|Requirement|string\n     */\n    public $title;\n\n    /**\n     * Size quickly identifies how many rows are in any particular column.\n     *\n     * @var int\n     */\n    public $size = 0;\n\n    public function __construct(?string $title = null)\n    {\n        $this-&gt;prev_x = $this;\n        $this-&gt;next_x = $this;\n        $this-&gt;prev_y = $this;\n        $this-&gt;next_y = $this;\n        $this-&gt;title = $title;\n    }\n\n    public function remove_x(): void\n    {\n        $this-&gt;prev_x-&gt;next_x = $this-&gt;next_x;\n        $this-&gt;next_x-&gt;prev_x = $this-&gt;prev_x;\n    }\n\n    public function remove_y(): void\n    {\n        $this-&gt;prev_y-&gt;next_y = $this-&gt;next_y;\n        $this-&gt;next_y-&gt;prev_y = $this-&gt;prev_y;\n    }\n\n    public function restore_x(): void\n    {\n        $this-&gt;prev_x-&gt;next_x = $this;\n        $this-&gt;next_x-&gt;prev_x = $this;\n    }\n\n    public function restore_y(): void\n    {\n        $this-&gt;prev_y-&gt;next_y = $this;\n        $this-&gt;next_y-&gt;prev_y = $this;\n    }\n\n    public function attach_horiz(self $other): void\n    {\n        $node = $this-&gt;prev_x;\n        $other-&gt;prev_x = $node;\n        $node-&gt;next_x = $other;\n        $this-&gt;prev_x = $other;\n        $other-&gt;next_x = $this;\n    }\n\n    public function attach_vert(self $other): void\n    {\n        $node = $this-&gt;prev_y;\n        $other-&gt;prev_y = $node;\n        $node-&gt;next_y = $other;\n        $this-&gt;prev_y = $other;\n        $other-&gt;next_y = $this;\n    }\n\n    public function remove_column(): void\n    {\n        $this-&gt;remove_x();\n        $node = $this-&gt;next_y;\n        while ($node !== $this) {\n            $node-&gt;remove_row();\n            $node = $node-&gt;next_y;\n        }\n    }\n\n    public function restore_column(): void\n    {\n        $node = $this-&gt;prev_y;\n        while ($node !== $this) {\n            $node-&gt;restore_row();\n            $node = $node-&gt;prev_y;\n        }\n        $this-&gt;restore_x();\n    }\n\n    public function remove_row(): void\n    {\n        $node = $this-&gt;next_x;\n        while ($node !== $this) {\n            --$node-&gt;col_header-&gt;size;\n            $node-&gt;remove_y();\n            $node = $node-&gt;next_x;\n        }\n    }\n\n    public function restore_row(): void\n    {\n        $node = $this-&gt;prev_x;\n        while ($node !== $this) {\n            ++$node-&gt;col_header-&gt;size;\n            $node-&gt;restore_y();\n            $node = $node-&gt;prev_x;\n        }\n    }\n\n    public function select(): void\n    {\n        $node = $this;\n        do {\n            $node-&gt;remove_y();\n            $node-&gt;col_header-&gt;remove_column();\n            $node = $node-&gt;next_x;\n        } while ($node !== $this);\n    }\n\n    public function unselect(): void\n    {\n        $node = $this-&gt;prev_x;\n        while ($node !== $this) {\n            $node-&gt;col_header-&gt;restore_column();\n            $node-&gt;restore_y();\n            $node = $node-&gt;prev_x;\n        }\n        $node-&gt;col_header-&gt;restore_column();\n        $node-&gt;restore_y();\n    }\n}\n\n\n// --------------------------------------------------------------------\n/**\n * A single requirement to be used in the solver.\n *\n * Actual puzzle requirement class shall extend this and set its `hash` property in its constructor.\n */\nabstract class Requirement\n{\n    /**\n     * @var string\n     */\n    protected $hash;\n\n    public function hash(): string\n    {\n        return $this-&gt;hash;\n    }\n}\n\n\n// --------------------------------------------------------------------\n/**\n * A single requirement to be used in the solver to enforce mutual exclusivity.\n * \n * @see https://www.codingame.com/playgrounds/156252/algorithm-x/mutual-exclusivity\n * @see https://www.codingame.com/playgrounds/156252/algorithm-x/php\n * \n */\nclass MERequirement extends Requirement\n{\n    /** @var string */\n    public $me_item_1;\n    /** @var string */\n    public $me_item_2;\n\n    public function __construct(string $me_item_1, string $me_item_2)\n    {\n        $this-&gt;me_item_1 = $me_item_1;\n        $this-&gt;me_item_2 = $me_item_2;\n        $this-&gt;hash = $me_item_1 . \" \" . $me_item_2;\n    }\n\n    public function contains(string $me_item) : bool\n    {\n        return $me_item === $this-&gt;me_item_1 || $me_item === $this-&gt;me_item_2;\n    }\n}\n\n\n// --------------------------------------------------------------------\n/**\n * A single action to be used in the solver.\n *\n * Actual puzzle requirement class shall extend this and set its `hash` property in its constructor.\n * Before passing list of actions to the solver, the `reqs` property must be filled with list of requirements.\n */\nabstract class Action\n{\n    /** @var string */\n    protected $hash;\n\n    /**\n     * The list of requirements that this action covers.\n     *\n     * @var array&lt;int, Requirement&gt;\n     */\n    public $reqs = [];\n\n    public function hash(): string\n    {\n        return $this-&gt;hash;\n    }\n}\n\n\n// --------------------------------------------------------------------\n/**\n* DLX-based Algorithm X solver.\n*\n* This solution uses Knuth's Algorithm X and his Dancing Links (DLX)\n* Difference: using separate classes for requirements and actions instead of tuples.\n*\n*/\nclass AlgorithmXSolver\n{\n    /**\n     * A hashmap of requirements.\n     *\n     * @var array&lt;string, Requirement&gt;\n     */\n    protected $R = [];\n\n    /**\n     * A hashmap of actions.\n     *\n     * @var array&lt;string, Action&gt;\n     */\n    protected $A = [];\n\n    /**\n     * A hashmap of optional requirements.\n     *\n     * @var array&lt;string, Requirement&gt;\n     */\n    protected $O = [];\n\n    /**\n     * The list of actions (rows) that produce the current path through the matrix.\n     *\n     * @var array&lt;int, Action&gt;\n     */\n    protected $solution = [];\n\n    /** @var int */\n    public $solution_count = 0;\n\n    /**\n     * A history can be added to a subclass to allow Algorithm X to handle \"multiplicity\".\n     * In the basic Solver, nothing is ever put into the history. A subclass can override\n     * the `process_row_selection()` method to add history in cases of multiplicity.\n     *\n     * @var array&lt;int, array&lt;string, bool&gt;&gt;\n     */\n    protected $history = [[]];\n\n    /**\n     * For the basic Algorithm X Solver, all solutions are always valid. However, a subclass\n     * can add functionality to check solutions as they are being built to steer away from\n     * invalid solutions. The basic Algorithm X Solver never modifies this attribute.\n     *\n     * @var bool\n     */\n    protected $solution_is_valid = true;\n\n    /** @var DLXCell */\n    protected $matrix_root;\n\n    /** @var array&lt;string, DLXCell&gt; */\n    protected $col_headers = [];\n\n    /**\n     * Row headers are never attached to the rest of the DLX matrix. They are only used\n     * currently to keep track of the action associated with each row.\n     *\n     * @var array&lt;string, DLXCell&gt;\n     */\n    protected $row_headers = [];\n\n    /**\n     * R - a list of requirements.\n     * A - a list of actions (object Action also contains the lists of covered requirements).\n     * O - a list of optional requirements. They can be covered, but they never cause failure.\n     *     Optional requirements are important because if they get covered, no other action can\n     *     also cover that same requirement. Also referred to as \"at-most-one-time constraints\".\n     *\n     * @param array&lt;int, Requirement&gt; $R\n     * @param array&lt;int, Action&gt;      $A\n     * @param array&lt;int, Requirement&gt; $O\n     */\n    public function __construct(array $R, array $A, array $O = [])\n    {\n        $R_with_O = array_merge($R, $O);\n        foreach ($R_with_O as $req) {\n            $this-&gt;R[$req-&gt;hash()] = $req;\n        }\n        foreach ($O as $req) {\n            $this-&gt;O[$req-&gt;hash()] = $req;\n        }\n        $this-&gt;matrix_root = new DLXCell('root');\n        $this-&gt;matrix_root-&gt;size = 10000000;\n        foreach ($R_with_O as $req) {\n            $node = new DLXCell();\n            $node-&gt;title = $req;\n            $this-&gt;col_headers[$req-&gt;hash()] = $node;\n        }\n        foreach ($A as $action) {\n            $node = new DLXCell();\n            $node-&gt;title = $action;\n            $this-&gt;row_headers[$action-&gt;hash()] = $node;\n        }\n        foreach ($this-&gt;col_headers as $node) {\n            $this-&gt;matrix_root-&gt;attach_horiz($node);\n        }\n        foreach ($A as $action) {\n            $this-&gt;A[$action-&gt;hash()] = $action;\n            $previous_cell = null;\n            foreach ($action-&gt;reqs as $req) {\n                $next_cell = new DLXCell();\n                $next_cell-&gt;col_header = $this-&gt;col_headers[$req-&gt;hash()];\n                $next_cell-&gt;row_header = $this-&gt;row_headers[$action-&gt;hash()];\n                $next_cell-&gt;col_header-&gt;attach_vert($next_cell);\n                ++$next_cell-&gt;col_header-&gt;size;\n                if (!is_null($previous_cell)) {\n                    $previous_cell-&gt;attach_horiz($next_cell);\n                } else {\n                    $previous_cell = $next_cell;\n                }\n            }\n        }\n    }\n\n    /**\n     * Algorithm X Step 1:\n     *\n     * Choose the column (requirement) with the best value for \"sort criteria\". For\n     * the basic implementation of sort criteria, Algorithm X always chooses the column\n     * covered by the fewest number of actions. Optional requirements are not eligible\n     * for this step.\n     */\n    public function solve(): \\Generator\n    {\n        $best_column = $this-&gt;matrix_root;\n        $best_value  = 0;\n        $node = $this-&gt;matrix_root-&gt;next_x;\n        while ($node !== $this-&gt;matrix_root) {\n            // Optional requirements (at-most-one-time constraints) are never chosen as best.\n            if (!($node-&gt;title instanceof Requirement) or !isset($this-&gt;O[$node-&gt;title-&gt;hash()])) {\n                // Get the sort criteria for this requirement (column).\n                $value = $this-&gt;requirement_sort_criteria($node);\n                if (($best_column === $this-&gt;matrix_root) or ($value &lt; $best_value)) {\n                    $best_column = $node;\n                    $best_value  = $value;\n                }\n                $node = $node-&gt;next_x;\n            } else {\n                // Optional requirements stop the search for the best column.\n                $node = $this-&gt;matrix_root;\n            }\n        }\n        if ($best_column === $this-&gt;matrix_root) {\n            $this-&gt;process_solution();\n            if ($this-&gt;solution_is_valid) {\n                ++$this-&gt;solution_count;\n                yield $this-&gt;solution;\n            }\n        } else {\n            // Build a list of all actions (rows) that cover the chosen requirement (column).\n            $actions = [];\n            $node = $best_column-&gt;next_y;\n            while ($node !== $best_column) {\n                $actions[] = $node;\n                $node = $node-&gt;next_y;\n            }\n            // The next step is to loop through all possible actions. To prepare for this,\n            // a new level of history is created. The history for this new level starts out\n            // as a complete copy of the most recent history.\n            $this-&gt;history[] = $this-&gt;history[count($this-&gt;history) - 1];\n            // Loop through the possible actions sorted by the given sort criteria. A basic\n            // Algorithm X implementation does not provide sort criteria. Actions are tried\n            // in the order they happen to occur in the matrix.\n            usort($actions, function (DLXCell $a, DLXCell $b): int {\n                return $this-&gt;action_sort_criteria($a-&gt;row_header) &lt;=&gt; $this-&gt;action_sort_criteria($b-&gt;row_header);\n            });\n            foreach ($actions as $node) {\n                $this-&gt;select($node);\n                if ($this-&gt;solution_is_valid) {\n                    foreach ($this-&gt;solve() as $s) {\n                        yield $s;\n                    }\n                }\n                $this-&gt;deselect($node);\n                // All backtracking results in going back to a solution that is valid.\n                $this-&gt;solution_is_valid = true;\n            }\n            array_pop($this-&gt;history);\n        }\n    }\n\n    /**\n     * Algorithm X Step 4 - Details:\n     *\n     * The select method updates the matrix when a row is selected as part of a solution.\n     * Other rows that satisfy overlapping requirements need to be deleted and in the end,\n     * all columns satisfied by the selected row get removed from the matrix.\n     */\n    protected function select(DLXCell $node): void\n    {\n        $node-&gt;select();\n        if (!$node-&gt;row_header-&gt;title instanceof Action) {\n            throw new \\Exception('impossible');\n        }\n        $this-&gt;solution[] = $node-&gt;row_header-&gt;title;\n        $this-&gt;process_row_selection($node-&gt;row_header-&gt;title);\n    }\n\n    /**\n     * Algorithm X Step 4 - Clean Up:\n     *\n     * The select() method selects a row as part of the solution being explored. Eventually that\n     * exploration ends and it is time to move on to the next row (action). Before moving on,\n     * the matrix and the partial solution need to be restored to their prior states.\n     */\n    protected function deselect(DLXCell $node): void\n    {\n        $node-&gt;unselect();\n        array_pop($this-&gt;solution);\n        if (!$node-&gt;row_header-&gt;title instanceof Action) {\n            throw new \\Exception('impossible');\n        }\n        $this-&gt;process_row_deselection($node-&gt;row_header-&gt;title);\n    }\n\n    /**\n     * In cases of multiplicity, this method can be used to ask Algorithm X to remember that\n     * it has already tried certain things. For instance, if Emma wants two music lessons per\n     * week, trying to put her first lesson on Monday at 8am is no different than trying to put\n     * her second lesson on Monday at 8am. See the Algorithm X Playground for more details,\n     * specifically Mrs. Knuth - Part III.\n     */\n    protected function remember(string $item_to_remember): void\n    {\n        if (isset($this-&gt;history[count($this-&gt;history) - 1][$item_to_remember])) {\n            $this-&gt;solution_is_valid = false;\n        } else {\n            $this-&gt;history[count($this-&gt;history) - 1][$item_to_remember] = true;\n        }\n    }\n\n    /**\n     * In some cases it may be beneficial to have Algorithm X try certain paths through the matrix.\n     * This can be the case when there is reason to believe certain actions have a better chance than\n     * other actions at producing complete paths through the matrix. The method included here does\n     * nothing, but can be overridden to influence the order in which Algorithm X tries rows (actions)\n     * that cover some particular column.\n     */\n    protected function action_sort_criteria(DLXCell $row_header): int\n    {\n        return 0;\n    }\n\n    /**\n     * In some cases it may be beneficial to have Algorithm X try covering certain requirements\n     * before others as it looks for paths through the matrix. The default is to sort the requirements\n     * by how many actions cover each requirement, but in some cases there might be several\n     * requirements covered by the same number of actions. By overriding this method, the\n     * Algorithm X Solver can be directed to break ties a certain way or consider another way\n     * of prioritizing the requirements.\n     */\n    protected function requirement_sort_criteria(DLXCell $col_header): int\n    {\n        return $col_header-&gt;size;\n    }\n\n    /**\n     * The following method can be overridden by a subclass to add logic to perform more detailed solution\n     * checking if invalid paths are possible through the matrix. Some problems have requirements that\n     * cannot be captured in the basic requirements list passed into the `__contruct()` method. For instance,\n     * a solution might only be valid if it fits certain parameters that can only be checked at intermediate\n     * steps. In a case like that, this method can be overridden to add the functionality necessary to\n     * check the solution.\n     * If the subclass logic results in an invalid solution, the `solution_is_valid` attribute should be set\n     * to false instructing Algorithm X to stop progressing down this path in the matrix.\n     */\n    protected function process_row_selection(Action $row): void\n    {\n    }\n\n    /**\n     * This method can be overridden by a subclass to add logic to perform more detailed solution\n     * checking if invalid paths are possible through the matrix. This method goes hand-in-hand with the\n     * `process_row_selection()` method above to \"undo\" what was done above.\n     */\n    protected function process_row_deselection(Action $row): void\n    {\n    }\n\n    /**\n     * This method can be overridden to instruct Algorithm X to do something every time a solution is found.\n     * For instance, Algorithm X might be looking for the best solution or maybe each solution must be\n     * validated in some way. In either case, the `solution_is_valid` attribute can be set to False\n     * if the current solution should not be considered valid and should not be generated.\n     */\n    protected function process_solution(): void\n    {\n    }\n}\n?&gt;\n</code></pre>"},{"location":"24-odds-and-ends/01-solving-with-logic-only/","title":"Solving Logic Puzzles Logically","text":"<p>Many logic puzzles can be solved with no guessing at all. On this page, I will keep track of my personal progress toward solving all logic puzzles with logic alone, no guessing and no backtracking.</p> Puzzle Results Sudoku Solver \u2705 Test Case 1: Very Easy\u2705 Test Case 2: Easy\u2705 Test Case 3: Intermediate/Hard\u274c Test Case 4: World's Hardest Sudoku 16x16 Sudoku \u2705 Test Case 1: Test 1\u2705 Test Case 2: Test 2\u274c Test Case 3: Test 3\u274c Test Case 4: Test 4\u274c Test Case 5: Test 5\u274c Test Case 6: Test 6 25x25 Sudoku \u2705 Test Case 1: Test 1\u274c Test Case 2: Test 2\u274c Test Case 3: Test 3\u274c Test Case 4: Test 4\u274c Test Case 5: Test 5 Mini Sudoku Solver \ud83d\udcaf \u2705 Test Case 1: Test 1\u2705 Test Case 2: Test 2\u2705 Test Case 3: Test 3\u2705 Test Case 4: Test 4 Futoshiki Solver \ud83d\udcaf \u2705 Test Case 1: No comparisons\u2705 Test Case 2: Comparisons only horizontal\u2705 Test Case 3: Comparisons only vertical\u2705 Test Case 4: 5x5\u2705 Test Case 5: 7x7\u2705 Test Case 6: More 5x5\u2705 Test Case 7: 4x4\u2705 Test Case 8: 6x6\u2705 Test Case 9: More 6x6\u2705 Test Case 10: 3x3\u2705 Test Case 11: 1x1 Takuzu Solver \ud83d\udcaf \u2705 Test Case 1: Test 4x4\u2705 Test Case 2: Test 6x6\u2705 Test Case 3: Test 8x8\u2705 Test Case 4: Test 10x10\u2705 Test Case 5: Test 12x12\u2705 Test Case 6: Test 8x8 Hard\u2705 Validator 1: Validator 4x4\u2705 Validator 2: Validator 6x6\u2705 Validator 3: Validator 8x8\u2705 Validator 4: Validator 10x10\u2705 Validator 5: Validator 12x12\u2705 Validator 6: Validator 8x8 Hard Suguru Solver \u2705 Test Case 1: 4x5\u274c Test Case 2: 8x8\u2705 Test Case 3: 15x10\u2705 Test Case 4: 20x20 Killer Sudoku Solver \ud83d\udcaf \u2705 Test Case 1: Easy\u2705 Test Case 2: Medium\u2705 Test Case 3: Hard\u2705 Test Case 4: Expert Killer Sudoku Extreme Challenge \ud83d\udcaf \u2705 Test Case 1: 1 Puzzle - Easy\u2705 Test Case 2: 1 Hard Puzzle - Fewer Cages\u2705 Test Case 3: 2 Puzzles\u2705 Test Case 4: 8 Puzzles\u2705 Test Case 5: 16 Puzzles\u2705 Test Case 6: 32 Puzzles\u2705 Test Case 7: 40 Puzzles Kakuro Solver \u2705 Test Case 1: Example 1 (3 * 3)\u2705 Test Case 2: Test 2 (4 * 4)\u2705 Test Case 3: Test 3 (1 * 3)\u2705 Test Case 4: Example 2 (5 * 5)\u2705 Test Case 5: Test 5 (9 * 8)\u2705 Test Case 6: Test 6 (9 * 9)\u2705 Test Case 7: Test 7 (12 * 10)\u2705 Test Case 8: Test 8 (18 * 10)\u2705 Test Case 9: Test 9 (15 * 15)\u274c Test Case 10: Test 10 (7 * 7) There is no Spoon - Episode 2 \u2705 Test Case 1: Simplest\u2705 Test Case 2: Simpler\u2705 Test Case 3: Simple\u2705 Test Case 4: Basic\u2705 Test Case 5: Intermediate 1\u2705 Test Case 6: Intermediate 2\u2705 Test Case 7: Intermediate 3\u2705 Test Case 8: Advanced\u274c Test Case 9: Multiple solutions 1\u2705 Test Case 10: Back to basics\u274c Test Case 11: CG\u274c Test Case 12: Multiple solutions 2\u274c Test Case 13: Expert Battleship Solitaire \ud83d\udcaf \u2705 Test Case 1: Only-spots-left\u2705 Test Case 2: The-rest-is-water\u2705 Test Case 3: Water-on-corners\u2705 Test Case 4: Surround-whole-boat\u2705 Test Case 5: Only-place-it-could-fit\u2705 Test Case 6: Seaman\u2705 Test Case 7: Petty Officer First Class\u2705 Test Case 8: Senior Chief Petty Officer\u2705 Test Case 9: Command Master Chief Petty Officer\u2705 Test Case 10: Chief Warrant Officer\u2705 Test Case 11: Lieutenant Junior Grade\u2705 Test Case 12: Lieutenant Commander\u2705 Test Case 13: Captain\u2705 Test Case 14: Rear Admiral\u2705 Test Case 15: Admiral\u2705 Validator 1: Only-spots-left\u2705 Validator 2: The-rest-is-water\u2705 Validator 3: Water-on-corners\u2705 Validator 4: Surround-whole-boat\u2705 Validator 5: Only-place-it-could-fit\u2705 Validator 6: Petty Officer\u2705 Validator 7: Chief Petty Officer\u2705 Validator 8: Master Chief Petty Officer\u2705 Validator 9: Master Chief Petty Officer Of The Navy\u2705 Validator 10: Ensign\u2705 Validator 11: Lieutenant\u2705 Validator 12: Commander\u2705 Validator 13: Rear Admiral Lower Half\u2705 Validator 14: Vice Admiral\u2705 Validator 15: Fleet Admiral Magnets \ud83d\udcaf \u2705 Test Case 1: Simple\u2705 Test Case 2: Easy\u2705 Test Case 3: Tricky\u2705 Test Case 4: Advanced\u2705 Test Case 5: Hard\u2705 Test Case 6: Expert\u2705 Test Case 7: Brutal\u2705 Test Case 8: Impossible\u2705 Validator 1: Simple\u2705 Validator 2: Easy\u2705 Validator 3: Tricky\u2705 Validator 4: Advanced\u2705 Validator 5: Hard\u2705 Validator 6: Expert\u2705 Validator 7: Brutal\u2705 Validator 8: Impossible <p></p>"},{"location":"24-odds-and-ends/02-revision-history/","title":"Revision History","text":"Date Details Coming Soon \ud83c\udfae Connect the Colours - Part 1 Coming Soon \ud83c\udfae Connect the Colours - Part 2 Coming Soon \ud83c\udfae Battleship Solitaire Coming Soon \ud83c\udfae Magnets October 5, 2025 \ud83c\udfae Pips added. May 17, 2025 <code>AlgorithmXSolver</code> \u27a1\ufe0f PHP translation added. April 5, 2025 Crossword added. April 5, 2025 Fix the Spaces added. April 2, 2025 Completed Mahjong Hands added. March 25, 2025 Depot Organization added. March 25, 2025 Haunted Manor added. March 19, 2025 <code>AlgorithmXSolver</code> \u27a1\ufe0f Kotlin translation added. March 19, 2025 <code>AlgorithmXSolver</code> \u27a1\ufe0f Ruby translation added. March 19, 2025 Kids Blocks added. March 10, 2025 \ud83c\udfae Tetrasticks added. March 6, 2025 \ud83c\udfae Polyominoes added. February 23, 2025 Periodic Table Spelling added. February 21, 2025 Nonogram Inversor added. February 21, 2025 Networking puzzle added to practice reducing sets of events. January 20, 2025 Picture Puzzle added. December 28, 2024 Initial playground publication."},{"location":"24-odds-and-ends/03-afterword/","title":"The Chances are a Million to One","text":"<p>When @5DN1L first suggested I do an Algorithm X playground, I ran the idea past my wife. I told her, \u201cI do not want to do it, and even if I did want to do it, the chances of me actually finishing it are a million to one.\u201d She smiled and said...</p> <p>\"Then there's still a chance.\"</p> <p>She was quoting one of the greatest motivational movies of all time, Chicken Run:</p>"},{"location":"24-odds-and-ends/03-afterword/#never-give-up","title":"Never Give Up","text":"<p>As I look back over my Algorithm X journey, I did a lot of interesting things that supported the possibility that I may never finish this playground. I made a shocking number of Algorithm X blunders, several of which were not discovered until a year or more after they pushed my approach down some very strange paths.</p> <p>@5DN1L and I shared a lot of ideas over the past two years. We sometimes didn\u2019t see eye to eye, and that always made me wonder what I was missing. I originally stuck with my plan to build this playground simply because I told @5DN1L I would do it. Somewhere along the journey, the process became fun.</p> <p>The best part of this process was discovering and correcting my biggest mistakes. After completing my first draft, I truly thought I was very close to the finish line. @5DN1L had brought up the idea of \u201ccoloring\u201d and Knuth\u2019s Algorithm C many times, but I was able to complete all puzzles without any coloring\u2026until @5DN1L added Agent X, Mission 2 - Mysterious Cryptogram to his list. A few months later, I had eaten several servings of humble pie, coloring had been added and the playground had grown by 25%.</p> <p>Whatever it is you want to accomplish, tell somebody your plan. Make sure it is somebody you would be very uncomfortable telling, \u201cI changed my mind. I\u2019m not going to do it anymore.\u201d I don\u2019t think @5DN1L and I ever talked specifically about accountability, but it was there, and it is a significant reason I never gave up.</p>"},{"location":"24-odds-and-ends/03-afterword/#whats-next","title":"What\u2019s Next","text":"<p>If you enjoyed this playground, the obvious tasks to consider next are implementing Knuth\u2019s Algorithm M and Algorithm C. If you dive into his material, you will see many more single letter algorithms you might also explore. If you do go down those paths, please reach out to me in the CodinGame Forum and I will gladly add a link here to your playground!</p> <p></p>"}]}